# Переменные в C#

Переменная — это именованная область памяти, используемая для хранения данных, которые могут изменяться во время 
выполнения программы. Она имеет тип, который определяет, какие данные можно хранить в переменной, и как они будут обрабатываться.

Переменные программы хранятся в оперативной памяти компьютера, которая выделяется программе операционной системой.

Как уже было сказано в определение переменные на то и переменные, что их значение может меняться во время выполнения программы
или они даже могут быть удалены из памяти, например сборщиком мусора, если они уже не нужны для выполнения программы.

Естественно, что по завершении работы программы все переменные которые она использовала так же удаляются из памяти.

Переменные могут получать свои значения не посредственно в ходе выполнения программы из пользовательского ввода, читаться из
файлов или баз данных, а так же быть на прямую заданы в коде программы.

Значения переменных так же могут выводиться на экран, принтер, файл, базу данных, отправляться по сети и т.п.

Каждая переменная имеет **тип**, **имя** и **значение (данные)**.

Например:
```C#
int price = 100;
```
В данном случае `int` - это тип переменной, `price` - это имя переменной, а `100` - это значение переменной. 

Рассматривайте переменную как ящик куда можно что-то поместить, вынуть и поместить что-то другое. Но поскольку C# строго
типизированный язык в определенные ящики, можно помещать только определенные типы данных.

Разные типы данных имеют разные размеры поэтому для них выделяются разные по размеру ящики. То есть для хранения переменных
разных типов в памяти компьютера выделяется различное количество бит.

В приведенном выше примере для переменной типа `int` в памяти выделяется 32 бита, что равно 4 байтам. Переменные типа `int` могут
содержать значения от -2,147,483,648 до 2,147,483,647.

А вот пример переменой типа `byte`:
```C#
byte ascii_symbol = 108;
```
Для переменной типа `byte` выделяется 8 бит, что рано 1 байту. Переменные типа `byte` могут содержать значения от 0 до 255.

## Представление информации в памяти компьютера
Память измеряется в байтах. Один байт содержит 8 бит. 

**Что такое бит и байт?**
- **Бит** — это минимальная единица информации в компьютере, которая может принимать два значения: **0** или **1**.
- **Байт** — это последовательность из 8 бит. Он является стандартной минимальной единицей хранения данных в памяти компьютера.

**Как представляется информация в памяти компьютера?**

Компьютерная память устроена как огромный набор ячеек, каждая из которых может содержать 1 байт. В каждом байте 
хранятся 8 бит, которые могут быть **0** или **1**. Эти комбинации кодируют числа, символы, инструкции и другие данные 
с помощью кодировок (например, ASCII или Unicode для текста).

**Почему 1 байт может представлять 256 значений?**

Каждый бит в байте может быть либо **0**, либо **1**. Количество возможных комбинаций из 8 бит вычисляется как:  

$2^8 = 256$  

Таким образом, байт может представлять числа от **0 до 255** (если без знака) или от **-128 до 127** (если используется знак).  
Пример:
- `00000000` (все биты = 0) — это 0.
- `11111111` (все биты = 1) — это 255.

**Перевод из двоичной в десятичную**

Возьмем число **1011** (двоичное).  
Каждая цифра двоичного числа, в зависимости от своего положения (начиная справа), имеет вес, равный степени двойки, начиная с нуля:

| Вес цифры  | Цифра | Степень двойки | Значение |
|------------|-------|----------------|----------|
| 3 (слева)  | 1     | $2^3 = 8$      | 8        |
| 2          | 0     | $2^2 = 4$      | 0 (потому что 0 × 4 = 0) |
| 1          | 1     | $2^1 = 2$      | 2        |
| 0 (справа) | 1     | $2^0 = 1$      | 1        |

Теперь складываем только значения, которые **не равны 0**:  
$8 + 0 + 2 + 1 = 11$

**Результат:** $1011_2 = 11_{10}$

**Почему пропадает "4" в примере?**

В двоичной системе каждая **0** означает, что значение этой степени двойки не используется.  
В примере $1011_2$, цифра **0** на позиции $2^2$ даёт $0 * 4 = 0$, поэтому $4$ не добавляется в сумму.

**Перевод из десятичной в двоичную**

Возьмем число **13** (десятичное) и разделим целочисленным делением на 2, чтобы получить остатки:

1. **$13 \div 2 = 6$**, остаток **$1$**.
2. **$6 \div 2 = 3$**, остаток **$0$**.
3. **$3 \div 2 = 1$**, остаток **$1$**.
4. **$1 \div 2 = 0$**, остаток **$1$**.

Теперь записываем остатки **снизу вверх**:  
$1\ 1\ 0\ 1$

**Результат:** $13_{10} = 1101_2$


**Что такое целочисленное деление с остатком?**

В **целочисленном делении** результатом является только **целая часть** от деления, а остаток — это то, что "остается", 
если делимое не делится нацело.

Формула:  
$$
Делимое = (Делитель \times ЦелаяЧасть) + Остаток
$$

При этом:
- Остаток всегда меньше делителя.

Разберем $ 1 ÷ 2$ в контексте целочисленного деления с остатком:
1. Сколько раз $2$ помещается в $1$ без превышения? Ответ: $0$ раз (**целая часть = 0**).
2. Что осталось после этого? Осталось всё исходное число $1$, потому что $2$ в $1$ "не помещается".

Результат:  

$1 ÷  2 = 0 \, (\text{целая часть}) \, \text{и остаток 1}$.

**Объяснение целочисленного деления через раздачу пирогов:**

1. У тебя есть **13 пирогов**, ты раздаёшь их **группами по 2 пирога**. Раздавать можно только **целые** пироги. Резать пироги нельзя.
2. На каждом шаге:
    - Считаем, сколько раз можно раздать **по 2 целых пирога** (**целая часть деления**).
    - Считаем, сколько пирогов осталось (**остаток**).

**Шаги деления $13 \div 2$:**
1. **Первый шаг:**
    - У тебя есть $13$ пирогов. Сколько раз можно раздать по $2$ пирога?  
      $13 \div 2 = 6$ (**целая часть = 6**).
    - После раздачи $6 \times 2 = 12$ пирогов у тебя остался **1 пирог** (**остаток = 1**).

2. **Второй шаг:**
    - Теперь $6$ пирогов сколько раз можно раздать по $2$ пирога?  
      $6 \div 2 = 3$ (**целая часть = 3**).
    - После раздачи $3 \times 2 = 6$ пирогов осталось **0 пирогов** (**остаток = 0**).

3. **Третий шаг:**
    - Теперь  $3$ пирога сколько раз можно раздать по $2$?  
      $3 \div 2 = 1$ (**целая часть = 1**).
    - После раздачи $1 \times 2 = 2$ пирогов остался **1 пирог** (**остаток = 1**).

4. **Четвёртый шаг:**
    - И так остался $1$ пирог. Сколько раз можно раздать по $2$?  
      $1 \div 2 = 0$ (**целая часть = 0**). $0$ пирогов вы можете раздать. Поэтому у вас остается **1 пирог** (**остаток = 1**).
    - После раздачи $0 \times 2 = 0$ пирогов остался **1 пирог** (**остаток = 1**).

**Как собрать двоичное число:**
Остатки, которые мы получили (1, 0, 1, 1), записываем **снизу вверх**:  

$13_{10} = 1101_2$

**Кратко что мы проделали:**
1. На каждом шаге ты раздаёшь пироги **по 2 штуки за раз**.
2. Что остаётся после раздачи — это **остаток**, который записывается как разряд двоичного числа.
3. Процесс продолжается, пока у тебя не закончатся пироги (целая часть не станет 0).

### Представление отрицательных целых чисел в двоичной системе

Если двоичное число интерпретируется как знаковое, то старший бит (самый левый) указывает 
на знак числа:
- `0` — положительное число.
- `1` — отрицательное число.

**Общие шаги перевода отрицательного числа в двоичную систему**

1. **Найти двоичное представление положительного аналога числа.**
   - Например, для `-60` сначала возьмем `60`.

2. **Дополнить двоичное представление до разрядности типа.**
   - Например, если используем 8 бит, то записываем число в формате `0011_1100`.

3. **Инвертировать биты (заменить 1 на 0 и 0 на 1).**

4. **Добавить 1 к результату.**

### Пример: перевод числа `-60` в двоичную систему для 8-битного представления

1. **Положительный аналог числа:**
   - Число `60` в двоичной системе:
     ```
     60 (десятичное) = 0011_1100 (двоичное).
     ```

2. **Инверсия всех битов:**
   - Инвертируем (заменяем 1 на 0 и 0 на 1):
     ```
     0011_1100 → 1100_0011.
     ```

3. **Добавление 1:**
   - Прибавляем 1 к результату:
     ```
     1100_0011 + 1 = 1100_0100.
     ```

4. **Результат:**
   - Число `-60` в дополнительном коде для 8 бит:
     ```
     -60 = 1100_0100.
     ```

### Пример: перевод из двоичной системы обратно в десятичную: пример с `1100_0100`

1. **Проверить знак числа:**
   - Если старший бит равен 1 (в данном случае `1`), то число отрицательное.

2. **Инвертировать все биты:**
   - Инвертируем:
     ```
     1100_0100 → 0011_1011.
     ```

3. **Вычесть 1:**
   - Вычитаем 1:
     ```
     0011_1011 - 1 = 0011_1100.
     ```

4. **Перевести в десятичное:**
   - Число `0011_1100` в десятичной системе:
     ```
     0011_1100 = 60.
     ```

5. **Добавить знак:**
   - Так как старший бит изначально был 1, результат:
     ```
     -60.
     ```

Когда самый старший бит числа интерпретируется как знак числа, такое представление называют **дополнительным кодом** или
**Two's Complement**.

### Представление вещественных чисел
**Вещественное число** — это число с дробной частью, например: 42.021, 3.14 или -0.5. Такие числа нужны для точных расчетов, 
например, в физике или инженерии.

Поскольку числа в компьютере хранятся в двоичной системе (в виде 0 и 1). Для вещественных чисел используется специальный 
стандарт хранения — **IEEE 754**. Этот стандарт описывает, как представить вещественное число в виде трех частей:

### 1. **Знак** (1 бит): {id="1-1_1"}
- Если число положительное, бит равен 0.
- Если число отрицательное, бит равен 1.

### 2. **Порядок** (8 бит для float, 11 бит для double):
- Это смещение, которое показывает, на сколько разрядов нужно сдвинуть десятичную (а точнее, двоичную) точку.
- Порядок хранится с добавлением **смещения (bias)**:
    - Для `float` смещение = 127.
    - Для `double` смещение = 1023.

### 3. **Мантисса** (23 бита для float, 52 бита для double):
- Мантисса хранит значимые разряды числа, записанные в двоичном виде. Число всегда **нормализуется** так, чтобы первый разряд был равен 1 (**он не хранится явно, называется скрытым битом**).

### Для чего нужно смещение (bias)?
Смещение позволяет записывать как положительные, так и отрицательные значения экспоненты без дополнительных битов на знак:
- Если экспонента равна $E$, то в памяти хранится $E + bias$.
- Например, для `float`, если $E = -1$, то хранится $127 + (-1) = 126$.

#### Почему bias = 127 для float?
Смещение выбирается как половина диапазона экспоненты. Для 8 бит:
- Диапазон $[0, 255$, следовательно, bias = $127$.

Для `double` (11 бит):
- Диапазон $[0, 2047]$, следовательно, bias = $1023$.

### Аналогия для лучшего понимания bias {id="bias_1"}
Представьте, что вам нужно записывать как положительные, так и отрицательные числа, но вы можете использовать 
только положительные числа. Например:
- У вас есть диапазон чисел от $-50$ до $+50$.
- Вы добавляете $+50$ ко всем числам, чтобы диапазон стал $0$ до $100$.
    - $+50$ превращается в $100$,
    - $0$ превращается в $50$,
    - $-50$ превращается в $0$.

Точно так же добавляется смещение $+127$ для хранения истинного порядка в положительном виде.

### Что такое нормализованное число?
**Нормализованное число** — это такое представление числа, при котором его значимая часть записывается в виде числа, 
начинающегося с $1,$ (единица с запятой) и умножается на степень числа $2$. Это удобно, потому что все числа в 
таком формате имеют одинаковую структуру, что упрощает их хранение и обработку в компьютере.

Давайте разберем это на простом примере с числом $42,02$.

### 1. Число в десятичной системе: {id="1_2"}
Число $42,021$ — это обычное число, записанное в привычном десятичном формате.

Теперь переведем его в двоичную систему.

### 2. Преобразование числа в двоичную систему: {id="2_2"}
В двоичной системе это число будет выглядеть так:  
$
42,021_{10} = 101010.000001_2
$

**Расшифруем:**
- **Целая часть $42_{10}$** в двоичной системе это $101010_2$
- **Дробная часть $0,021_{10}$** в двоичной системе это примерно $0.000001_2$

Итак, $42,021_{10}$ в двоичной системе выглядит как $101010.000001_2$

### 3. Приведение к нормализованному виду: {id="3_3"}
Теперь нужно записать это число так, чтобы значимая часть числа начиналась с $1,$ а оставшуюся часть числа мы умножим 
на степень числа $2$.

#### Шаги:
1. **Переместим двоичную точку (запятую):**  
   Двигаем запятую так, чтобы перед ней осталась только одна $1$.  
   $$
   101010.000001_2 \rightarrow 1.01010000001_2
   $$
   (Мы сдвинули точку на 5 позиций влево. Это и будет степенью двойки)

2. **Запишем степень двойки:**  
   Чтобы вернуть число в исходное состояние, нужно умножить его на $2^5$, так как мы сдвинули точку на 5 позиций влево.

**Итоговое нормализованное представление:**  
$$
42,021_{10} = 1.01010000001_2 \times 2^5.
$$

### Зачем такие сложности?
- **Экономия места:** В нормализованном виде в памяти хранится только значимая часть (мантисса) и степень (порядок). Это позволяет не тратить место на незначащие нули.
- **Унификация:** Все числа представлены одинаково, что упрощает операции над ними (сложение, умножение и т.д.).

### Пояснение более простыми словами:
Представь, падаван, что у тебя есть число $42,021$, записанное в виде $101010.000001$ в двоичной системе. Чтобы сделать 
его удобным для хранения, мы «передвигаем» точку (запятую) так, чтобы число начиналось с $1$. Мы как будто говорим:
- "Возьмём $1.01010000001$, но чтобы вернуть точку назад на место, нужно умножить это число на $2^5$."

Так мы получаем **нормализованное представление** числа:  
$$
1.01010000001_2 \times 2^5.
$$

### Подробный пошаговый пример преобразования числа 42,021 в двоичное представление

Для преобразования числа $42,021$ в формат IEEE 754 (32-битное представление с плавающей точкой, или **float**), 
нам нужно выполнить несколько шагов. Включая преобразование целой и дробной части в двоичное представление, нормализацию, 
а также кодирование в соответствии с стандартом IEEE 754.

Давайте разберем это шаг за шагом, подробно объяснив, как это работает.

### Шаг 1: Представление числа в двоичной системе {id="1_3"}

#### 1.1. Целая часть {id="1-1_2"}
Целая часть числа — это $42$. Преобразуем её в двоичную систему, деля на 2 и записывая остатки:

$$
42 \div 2 = 21 \, \text{(остаток 0)}
$$
$$
21 \div 2 = 10 \, \text{(остаток 1)}
$$
$$
10 \div 2 = 5 \, \text{(остаток 0)}
$$
$$
5 \div 2 = 2 \, \text{(остаток 1)}
$$
$$
2 \div 2 = 1 \, \text{(остаток 0)}
$$
$$
1 \div 2 = 0 \, \text{(остаток 1)}
$$

Теперь читаем остатки снизу вверх:

$$
42_{10} = 101010_2
$$

#### 1.2. Дробная часть
Дробная часть — это $0,021$. Чтобы перевести её в двоичную систему, умножаем её на 2 и записываем целую часть каждого 
результата. Повторяем процесс, пока дробь не станет равной 0 (или пока точность не станет достаточной).

$$
0,021 \times 2 = 0,042 \quad (\text{целая часть } 0)
$$
$$
0,042 \times 2 = 0,084 \quad (\text{целая часть } 0)
$$
$$
0,084 \times 2 = 0,168 \quad (\text{целая часть } 0)
$$
$$
0,168 \times 2 = 0,336 \quad (\text{целая часть } 0)
$$
$$
0,336 \times 2 = 0,672 \quad (\text{целая часть } 0)
$$
$$
0,672 \times 2 = 1,344 \quad (\text{целая часть } 1)
$$
$$
0,344 \times 2 = 0,688 \quad (\text{целая часть } 0)
$$
$$
0,688 \times 2 = 1,376 \quad (\text{целая часть } 1)
$$
$$
0,376 \times 2 = 0,752 \quad (\text{целая часть } 0)
$$
$$
0,752 \times 2 = 1,504 \quad (\text{целая часть } 1)
$$

Мы можем продолжить этот процесс, но для удобства останавливаемся на $10$-м шаге. Записываем целую часть сверху вниз.
Таким образом, дробная часть $0,021$ в двоичной системе примерно равна $000001_2$ (при точности 10 знаков после запятой).
Почему примерно? Мы взяли первые шесть цифр дробной части, посчитав что такой точности достаточно.

#### 1.3. Объединение целой и дробной части
Теперь объединяем целую часть и дробную:

$$
42,021_{10} = 101010,000001_2
$$

### Шаг 2: Нормализация числа {id="2_3"}

Нормализовать число — это привести его к виду, где перед запятой будет стоять единица. Для этого сдвигаем запятую на 
несколько позиций влево.

$$
101010,000001_2 \rightarrow 1,01010000001_2 \times 2^5
$$

Мы сдвинули запятую на 5 позиций влево, поэтому степень двойки (порядок) будет равна 5.

### Шаг 3: Определение компонентов IEEE 754

IEEE 754 использует три компонента для представления вещественного числа:
- **Знак** (1 бит)
- **Порядок** (8 бит)
- **Мантисса** (23 бита)

#### 3.1. Знак
Поскольку число $42,021$ положительное, то **бит знака** будет равен $0$.

#### 3.2. Порядок
Порядок равен 5 (так как мы сдвинули запятую на 5 позиций влево). В формате IEEE 754 порядок кодируется с использованием 
смещения (bias). Для формата с одинарной точностью (32 бита) смещение равно $127$.

Значение порядка $E$ с учётом смещения:

$$
E = 5 + 127 = 132
$$

Теперь преобразуем $132$ в двоичную систему:

$$
132_{10} = 10000100_2
$$

Так что порядок в двоичном представлении будет $10000100_2$.

#### 3.3. Мантисса {id="3-3_1"}
Мантисса — это значимая часть числа без ведущей единицы (так как она всегда равна $1$ в нормализованном представлении). 
Мы оставляем только цифры после запятой:

$$
1,01010000001_2 \quad \text{(мантисса без ведущей единицы)}
$$

Остальные биты дополняем нулями до 23 бит:

$$
01010000010000000000000_2
$$

### Шаг 4: Запись числа в формате IEEE 754

Теперь мы можем собрать все части вместе:

- **Знак**: $0$
- **Порядок**: $10000100_2$
- **Мантисса**: $01010000010000000000000_2$

Записываем всё это в виде:

$$
0 \, \text{(знак)} \, | \, 10000100 \, \text{(порядок)} \, | \, 01010000010000000000000 \, \text{(мантисса)}
$$

Итак, окончательное представление числа $42,021$ в формате IEEE 754 (32-битное) будет:

$$
0 \, 10000100 \, 01010000010000000000000
$$

Это было совсем не много математики необходимой для понимания двоичной системы счисления и как числа хранятся в памяти в
двоичном виде, а так же сколько бит памяти для этого требуется.

А теперь возвращаемся к теме переменных.

## Основные правила именования переменных в C#
1. **Определение переменной:**
   - Перед использованием переменную необходимо определить.
   - Синтаксис определения переменной:
     ```c#
     тип имя_переменной;
     ```
2. **Требования к имени переменной:**
   - Имя может содержать **буквы, цифры и символ подчеркивания** (`_`).
   - **Первый символ** имени должен быть **буквой или символом подчеркивания**.
   - **Запрещено** использовать пробелы, знаки пунктуации или специальные символы.
   - Имя **не может быть ключевым словом** языка C# (например, `int`, `class` и т.д.).
   - **Чувствительность к регистру**: `age` и `Age` считаются разными именами.

3. **Стиль именования:**
   - Используйте **camelCase** для локальных переменных и полей с модификатором `private`.
   - Используйте **PascalCase** для открытых (`public`) полей, свойств, методов и имен типов.

4. **Семантическая ясность:**
   - Имя должно быть **осмысленным** и отражать суть переменной. Например, вместо `x` лучше использовать `age`, `totalAmount`, и т.д.
   - Избегайте слишком длинных или слишком коротких имен, если это не оправдано.

5. **Особые правила:**
   - Для полей класса рекомендуется использовать префикс `_` (например, `_totalAmount`) в закрытых (`private`) переменных.
   - Константы (`const`) и статические переменные (`static readonly`) именуются **заглавными буквами** с подчеркиванием (`UPPER_CASE_WITH_UNDERSCORES`).

### Таблица стилей именования и использования
| **Стиль**             | **Примеры**                  | **Использование**                                                                 |
|------------------------|------------------------------|-----------------------------------------------------------------------------------|
| **Верблюжий регистр (camelCase)** | `totalAmount`, `orderDetail` | Локальные переменные, закрытые (`private`) поля.                                 |
| **Прописной стиль (PascalCase)** | `Name`, `TotalAmount`, `Run` | Имена типов, открытых (`public`) полей, свойств, методов, классов.               |
| **Заглавные буквы (UPPER_CASE)** | `MAX_VALUE`, `DEFAULT_PORT`  | Константы и статические поля (`const`, `static readonly`).                        |

### Примеры использования:
- Локальная переменная:
  ```c#
  int totalAmount = 100;
  ```
- Закрытое поле класса:
  ```c#
  private int _totalAmount;
  ```
- Открытое свойство:
  ```c#
  public int TotalAmount { get; set; }
  ```
- Константа:
  ```c#
  private const int MAX_USERS = 1000;
  ```

Перед типами переменных, в примерах выше стоят инструкции модификаторов доступа. Всё это было кратко описано в главе 
["Элементы языка C#"](GrammarAndTerminologyCSharp.md).

Тут мы так же немного затронули константы. Про них будет в следующей теме.

## Целочисленные переменные

>Этот раздел по целочисленным переменным достаточно объемный, так как на примере целочисленных переменных будут объяснены
> и общие принципы для всех типов переменных.
{style="note"}

В C# есть несколько встроенных типов для целых чисел, которые различаются по размеру, диапазону и знаковости. 
Вот их подробное описание:

| **Тип**       | **Размер (в байтах)** | **Диапазон значений**                  | **Значение по умолчанию** |
|----------------|-----------------------|-----------------------------------------|---------------------------|
| **sbyte**     | 1                     | -128 до 127                            | 0                         |
| **byte**      | 1                     | 0 до 255                               | 0                         |
| **short**     | 2                     | -32,768 до 32,767                      | 0                         |
| **ushort**    | 2                     | 0 до 65,535                            | 0                         |
| **int**       | 4                     | -2,147,483,648 до 2,147,483,647        | 0                         |
| **uint**      | 4                     | 0 до 4,294,967,295                     | 0                         |
| **long**      | 8                     | -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807 | 0 |
| **ulong**     | 8                     | 0 до 18,446,744,073,709,551,615        | 0                         |
| **nint** *(с версии C# 9.0)*  | Зависит от платформы | -2³¹ до 2³¹-1 (32-битная платформа) или -2⁶³ до 2⁶³-1 (64-битная платформа) | 0 |
| **nuint** *(с версии C# 9.0)* | Зависит от платформы | 0 до 2³²-1 (32-битная платформа) или 0 до 2⁶⁴-1 (64-битная платформа) | 0 |


**Ключевые особенности**
1. **`sbyte`** и **`short`**: знаковые типы для небольших чисел.
2. **`byte`** и **`ushort`**: беззнаковые версии для тех же диапазонов.
3. **`int`** и **`uint`**: основные типы для работы с числами среднего размера.
4. **`long`** и **`ulong`**: предназначены для больших чисел.
5. **`nint`** и **`nuint`**: зависят от платформы и используются для работы с указателями или низкоуровневым кодом.

Исходя из ваших нужд вы можете использовать тот или иной тип переменных.

Переменные на уровне класса можно просто объявить, или же сразу при объявлении присвоить значение. Если переменной 
на уровне класса при объявлении не присваивается значение явно, то ей присваивается значение по умолчанию.

> Переменные внутри методов класса должны обязательно инициализироваться каким-либо значением.
> {style="warning"}

Значение переменной присваивается при помощи оператора `=` (присваивания).

Давай уже, падаван, попрактикуемся. Создай консольное приложение `ex0015_integer_vars` при помощи шаблона `tinyconsole`
в папке episode02 и добавь его в файл решения episode02.sln. Это можно сделать как в командной строке так и в любой IDE.

Приведи файл Program.cs к следующему виду:

```C#
namespace ex0015_integer_vars;

class Program
{
    static sbyte sbyteDefault;
    static sbyte byteDefault;
    static short shortDefault;
    static ushort ushortDefault;
    static int intDefault;
    static uint uintDefault;
    static long longDefault;
    static ulong ulongDefault;
    static nint nintDefault;
    static nuint nuintDefault;

    static void Main()
    {
        WriteLine("Типы целочисленных переменных в C#");
        WriteLine(new string('-', 34));

        // sbyte
        sbyte sbyteMin = sbyte.MinValue;
        sbyte sbyteMax = sbyte.MaxValue;
        
        WriteLine($"Тип: sbyte");
        WriteLine($"Минимум: {sbyteMin}");
        WriteLine($"Максимум: {sbyteMax}");
        WriteLine($"Значение по умолчанию: {sbyteDefault}");
        WriteLine();

        // byte
        byte byteMin = byte.MinValue;
        byte byteMax = byte.MaxValue;
        WriteLine($"Тип: byte");
        WriteLine($"Минимум: {byteMin}");
        WriteLine($"Максимум: {byteMax}");
        WriteLine($"Значение по умолчанию: {byteDefault}");
        WriteLine();

        // short
        short shortMin = short.MinValue;
        short shortMax = short.MaxValue;
        WriteLine($"Тип: short");
        WriteLine($"Минимум: {shortMin}");
        WriteLine($"Максимум: {shortMax}");
        WriteLine($"Значение по умолчанию: {shortDefault}");
        WriteLine();

        // ushort
        ushort ushortMin = ushort.MinValue;
        ushort ushortMax = ushort.MaxValue;
        WriteLine($"Тип: ushort");
        WriteLine($"Минимум: {ushortMin}");
        WriteLine($"Максимум: {ushortMax}");
        WriteLine($"Значение по умолчанию: {ushortDefault}");
        WriteLine();

        // int
        int intMin = int.MinValue;
        int intMax = int.MaxValue;
        WriteLine($"Тип: int");
        WriteLine($"Минимум: {intMin}");
        WriteLine($"Максимум: {intMax}");
        WriteLine($"Значение по умолчанию: {intDefault}");
        WriteLine();

        // uint
        uint uintMin = uint.MinValue;
        uint uintMax = uint.MaxValue;
        WriteLine($"Тип: uint");
        WriteLine($"Минимум: {uintMin}");
        WriteLine($"Максимум: {uintMax}");
        WriteLine($"Значение по умолчанию: {uintDefault}");
        WriteLine();

        // long
        long longMin = long.MinValue;
        long longMax = long.MaxValue;
        WriteLine($"Тип: long");
        WriteLine($"Минимум: {longMin}");
        WriteLine($"Максимум: {longMax}");
        WriteLine($"Значение по умолчанию: {longDefault}");
        WriteLine();

        // ulong
        ulong ulongMin = ulong.MinValue;
        ulong ulongMax = ulong.MaxValue;
        WriteLine($"Тип: ulong");
        WriteLine($"Минимум: {ulongMin}");
        WriteLine($"Максимум: {ulongMax}");
        WriteLine($"Значение по умолчанию: {ulongDefault}");
        WriteLine();

        // nint (платформо-зависимый тип)
        nint nintMin = nint.MinValue;
        nint nintMax = nint.MaxValue;
        WriteLine($"Тип: nint");
        WriteLine($"Минимум: {nintMin}");
        WriteLine($"Максимум: {nintMax}");
        WriteLine($"Значение по умолчанию: {nintDefault}");
        WriteLine();

        // nuint (платформо-зависимый тип)
        nuint nuintMin = nuint.MinValue;
        nuint nuintMax = nuint.MaxValue;
        
        WriteLine($"Тип: nuint");
        WriteLine($"Минимум: {nuintMin}");
        WriteLine($"Максимум: {nuintMax}");
        WriteLine($"Значение по умолчанию: {nuintDefault}");
        WriteLine();
    }
}
```

**Первый** запуск программы даст следующий вывод (показана часть вывода):

![Целочисленные переменные в C#](int_vars01.png){ border-effect="line"  thumbnail="true" width="700" }

Как видите компилятор вывел предупреждение, что поскольку некоторые переменные не были инициализированы значениями, то
им было присвоено значение по умолчанию.

При втором запуске таких предупреждений уже не будет.

![Целочисленные переменные в C#](int_vars02.png){ border-effect="line"  thumbnail="true" width="700" }

Если вы хотите увидеть эти предупреждения снова, дайте команду `dotnet clean` в папке проекта.

В этой программе следует обратить внимание на блок объявления десяти переменных в самом начале программы. То есть в классе
Program. И попытаться понять почему другие переменные были объявлены и инициализированы значениями внутри метода Main().

**Переменные за пределами метода `Main`**

Переменные вроде `sbyteDefault`, `byteDefault` и другие определены как **поля класса** (на уровне класса), 
а не как локальные переменные внутри метода. Причины этого:

- **Доступ к значению по умолчанию без явного инициализатора**: Поля класса автоматически инициализируются значением по умолчанию, если не задать его явно. Это позволяет продемонстрировать значения по умолчанию, такие как `0` для целочисленных типов, без необходимости явно присваивать их внутри метода.
- **Локальные переменные требуют явной инициализации**: Если бы мы определили эти переменные внутри метода `Main`, компилятор потребовал бы явного присваивания значения, так как локальные переменные в C# не получают значение по умолчанию автоматически.
- **Повторное использование**: Поля класса могут быть доступны из разных методов, если потребуется. Это делает их более гибкими, чем локальные переменные, которые доступны только внутри метода, где они объявлены.

**Почему использовано ключевое слово `static`**

Все поля, такие как `sbyteDefault`, объявлены с модификатором `static`. Это связано с тем, что метод `Main()` тоже 
объявлен как `static`. В C# метод `Main` — это точка входа для программы, и компилятор требует, чтобы он был статическим.

Поле или метод, помеченные ключевым словом `static`, принадлежат самому классу, а не конкретному экземпляру этого класса. 
В данном случае:
- Метод `Main` принадлежит классу `Program`, а не объекту класса `Program`.
- Поля, к которым обращается метод `Main`, также должны быть статическими, иначе метод `Main` не сможет к ним обратиться.

Если бы поля `sbyteDefault`, `byteDefault` и т.д. не были статическими, то для доступа к ним внутри `Main()` потребовалось 
бы создавать экземпляр класса `Program`. Например:
```c#
Program program = new Program();
Console.WriteLine(program.sbyteDefault); // доступ через объект
```
Это избыточно и не имеет смысла в данном случае.

**Подведем итоги**
- Поля класса, объявленные как `static`, используются для демонстрации значений по умолчанию, так как они автоматически инициализируются компилятором.
- Метод `Main()` также статический, чтобы быть точкой входа программы.
- Статические поля и метод могут обращаться друг к другу без создания экземпляра класса.

**Пример для иллюстрации разницы**

Вот как программа могла бы выглядеть без использования `static` для полей:

```c#
namespace ex0015_integer_vars;

class Program
{
    sbyte sbyteDefault; // Поле экземпляра класса

    static void Main()
    {
        Program program = new Program(); // Создаем объект класса
        Console.WriteLine(program.sbyteDefault); // Теперь доступ через объект
    }
}
```

В этом примере для доступа к полю `sbyteDefault` требуется создать объект класса, потому что поле не является статическим. 
Это лишний шаг в нашем случае, так как переменные используются только в статическом контексте.

Скорее всего вам было не всё понятно в этих объяснениях, так как мы ещё не проходили что такое класс и экземпляр класса.
Вы всё это скоро узнаете. Пока намотайте на ус 😊.

Хотя давайте это же самое ещё раз проговорим чуток другими словами, возможно будет понятнее.

В C# при объявлении переменной, если ей не присваивается значение явно, то для нее автоматически задается **значение по умолчанию**. 
Однако есть нюансы:

1. **Локальные переменные** (объявленные внутри методов) **не инициализируются автоматически**, и попытка их использования до явного присваивания значения приведет к ошибке компиляции. Например:
   ```c#
   void PrintField() // это метод, не путайте с классом
   {
       int field; // Ошибка: локальная переменная не инициализирована
       Console.WriteLine(field); // Ошибка компиляции
   }
   ```

2. **Поля классов** и **переменные уровня класса/структуры** автоматически получают **значение по умолчанию**. Например:
   ```c#
   class Example
   {
       int field; // Поле получает значение по умолчанию: 0

       void PrintField()
       {
           Console.WriteLine(field); // Вывод: 0
       }
   }
   ```
Переменные, объявленные в методе (**локальные переменные**), не инициализируются автоматически значениями по умолчанию. 
Это сделано для повышения **производительности** и **безопасности*** кода.

**Производительность кода**

Локальные переменные существуют только во время выполнения метода (в пределах его **стека**). Если бы компилятор 
автоматически присваивал значения по умолчанию каждой локальной переменной, это добавляло бы лишние операции и замедляло 
выполнение программы, особенно в методах, которые часто вызываются. Вместо этого ответственность за инициализацию ложится 
на программиста.

**Безопасность кода**

Если бы локальные переменные автоматически инициализировались значениями по умолчанию, это могло бы скрыть ошибки, 
возникающие из-за пропущенной инициализации. Например, разработчик может забыть присвоить нужное значение переменной, 
но компилятор этого не заметит, так как значение по умолчанию уже будет установлено. Принудительная инициализация 
заставляет программиста явно задавать значения, что делает код более предсказуемым и понятным.

Пример ошибки:
```c#
int result; // Нет ошибки, если бы значение по умолчанию было присвоено
Console.WriteLine(result); // Вывод "0" мог бы ввести в заблуждение, т.к. 0 может не быть ожидаемым результатом.
```

Локальные переменные чаще используются для временных вычислений, и их значения обычно устанавливаются сразу после объявления. 
Поэтому разработчики C# решили не нагружать систему автоматической инициализацией локальных переменных, 
так как это редко бывает необходимо.

Пример правильного подхода:
```c#
int sum = 0; // Явная инициализация
for (int i = 0; i < 10; i++)
{
    sum += i;
}
```

**Итог. Почему поля инициализируются автоматически, а локальные переменные — нет?**
- **Поля (переменные класса)** связаны с объектом, и их жизненный цикл равен жизненному циклу объекта. Они хранятся в куче, инициализация значениями по умолчанию помогает избежать случайных ошибок.
- **Локальные переменные** короткоживущие, хранятся в стеке, и их основной задачей является хранение временных данных. Явная инициализация повышает контроль над их использованием.

К сожалению без оперирования понятиями классов, методов и объектов, объяснить все эти моменты было бы не возможно. И хотя мы ещё не
изучали что такое класс и метод класса, вы уже соприкоснулись с этими понятиями и нейронные связи в вашем мозгу уже прямо
сейчас начали расти. Чувствуете как мозги закипают? 😊 Это нейроночки у вас в мозгу растут. Вы становитесь умнее и умнее.
Хотя, возможно, пока вы это и не замечаете 😊. Да пребудет с тобой сила, падван.

>Все эти вещи, которые мы тут разжевывали касательно места, где объявляется переменная, общие для всех переменных, 
>не зависимо от их типа.

И ещё один момент. Как вы помните в главе ["Структура проекта C#"](Csharp-project-structure.md) 
мы подробно разбирали операторы верхнего уровня. Одной из причин почему их ввели, было упрощение изучения C# и снижение
порога вхождения. Хотя на самом деле, ни класс Program, ни статический метод Main, ни куда не девались. Их
просто скрыли чтобы не пугать начинающих. Но в любом случае они есть и от того что их скрыли легче не становится 😊.
Не находите? И на мой взгляд с этими вещами начинать работать и разбираться нужно в самом начале.

## Целочисленные литералы
В C# целочисленные литералы — это фиксированные значения, которые используются для представления целых чисел в коде. 
Они могут быть записаны в различных форматах: десятичном, шестнадцатеричном, двоичном и с использованием суффиксов, 
чтобы указать конкретный тип числа.

**Типы целочисленных литералов:**
1. **Десятичные (Decimal)**  
   Значение записывается как обычное целое число без какого-либо префикса. Всегда интерпретируется компилятором как число типа `int`.
   Пример: `42`, `-1000`.

2. **Шестнадцатеричные (Hexadecimal)**  
   Используется префикс `0x` или `0X`. Число записывается с использованием цифр `0–9` и букв `A–F` (или `a–f`). Всегда интерпретируется компилятором как положительное число типа `int`.  
   Пример: `0x2A`, `0xFF`.

3. **Двоичные (Binary)**  
   Используется префикс `0b` или `0B`. Число записывается с использованием цифр `0` и `1`. Всегда интерпретируется компилятором как положительное число типа `int`.
   Пример: `0b101010`.

4. **Суффиксы для указания типа литерала**:
   - `L` или `l` — для типа `long`.  
     Пример: `42L`.
   - `U` или `u` — для типа `uint`.  
     Пример: `42U`.
   - `UL`, `ul`, `LU`, `lu` — для типа `ulong`.  
     Пример: `42UL`.
   - Без суффиксов литералы по умолчанию имеют тип `int`.

5. **Разделители цифр (Digit Separators)**  
   Символ `_` используется для разделения цифр для улучшения читаемости, но не влияет на значение.  
   Пример: `1_000_000`, `0b1101_0101`.

Давайте немного попрактикуемся. Создайте проект `ex0016_int_literals` при помощи шаблона `tinyconsole`. Добавьте его в решение
`episode02.sln`.

```c#
namespace IntegerLiteralsExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // Десятичный литерал
            int decimalLiteral = 42;
            WriteLine($"Десятичный: {decimalLiteral}");

            // Шестнадцатеричный литерал
            int hexLiteral = 0x2A;
            WriteLine($"Шестнадцатеричный: {hexLiteral}");

            // Двоичный литерал
            int binaryLiteral = 0b101010;
            WriteLine($"Двоичный: {binaryLiteral}");

            // Литералы с суффиксами
            long longLiteral = 42L;
            uint uintLiteral = 42U;
            ulong ulongLiteral = 42UL;

            WriteLine($"Суффиксы:");
            WriteLine($"  long: {longLiteral}");
            WriteLine($"  uint: {uintLiteral}");
            WriteLine($"  ulong: {ulongLiteral}");

            // Литералы с разделителями цифр
            int largeNumber = 1_000_000;
            int binaryWithSeparators = 0b1010_1010_1111_0000;

            WriteLine($"С разделителями цифр:");
            WriteLine($"  Большое число: {largeNumber}");
            WriteLine($"  Двоичный: {binaryWithSeparators}");
        }
    }
}
```
Выполните программу.

Вывод программы будет такой:
```
Десятичный: 42
Шестнадцатеричный: 42
Двоичный: 42
Суффиксы:
  long: 42
  uint: 42
  ulong: 42
С разделителями цифр:
  Большое число: 1000000
  Двоичный: 43760
```
Как видите сами литералы не влияют на то как реально хранятся данные и их вывод на экран. Это просто синтаксический сахар
добавленный в язык для удобства написания и чтения.

Так же обратите внимание на название пространства имен. Как я говорил название для пространства имен вы можете выбирать любое.

>В C# типы литералов и операций зависят от их записи и контекста. Тип `int` используется по умолчанию для большинства 
>целочисленных литералов и операций, но это не единственный вариант.
{style="warning"}

Давайте разберемся что это значит на практике. Создайте проект `ex0017_int_leterals_default_type` при помощи шаблона `tinyconsole`. 
Добавьте его в решение `episode02.sln`. И затем приведите код в `Program.cs` К следующему виду:

![Целочисленные литералы в C#](int_vars03.png){ border-effect="line"  thumbnail="true" width="700" }

В этом варианте кода 5 ошибок. Но эти ошибки относятся к двум видам: [CS0031](https://learn.microsoft.com/ru-ru/dotnet/csharp/misc/cs0031?f1url=%3FappId%3Droslyn%26k%3Dk(CS0031)) и [CS0266](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/compiler-messages/cs0266?f1url=%3FappId%3Droslyn%26k%3Dk(CS0266)).
О чём нам и сообщает VSCode.

**Наша задача чтобы в переменных a0b, a0x, b, c оказалось значение -60. А в переменной d значение 60.**

В 10 строке в двоичном представлении с помощью двоичного литерала записано десятичное число 196. Но если это число интерпретировать
как знаковое, то есть первая слева единица означает отрицательное число, то это будет число -60.

То же самое относится к 11 строке. Только там число 196 записано в шестнадцатеричном формате.

Как уже говорилось двоичные и шестнадцатеричные литералы интерпретируются компилятором как числа типа `int` без знака.

Что мы имеем по этому поводу. Во-первых, тип `int` шире чем тип `byte`. То есть мы пытаемся запихнуть значение типа `int`
в переменную типа `byte`, то есть запихнуть большой ящик в маленький. Посмотрите сколько бит занимают типы `byte` и `int`.
Во вторых посмотрите диапазон чисел которые может представлять тип `sbyte` (от -128 до 127). Число 196 в него явно не
помещается. А вот число -60 помещается. То есть нам надо сделать чтобы число 196 стало интерпретироваться как знаковое.
Этого можно добиться разрешив операцию переполнения типа.

**Переполнение типов** в C# происходит, когда значение выходит за пределы допустимого диапазона для конкретного типа данных. 
В таком случае, в зависимости от режима выполнения (`checked` или `unchecked`), либо генерируется исключение 
`OverflowException`, либо результат "заворачивается" по кругу.

### Что происходит при переполнении?
1. **В режиме `unchecked`**:
   - Число "заворачивается" в пределах допустимого диапазона.
   - Для `sbyte` значение `196` преобразуется в `-60`:
      - 196 в двоичной системе: `1100_0100`.
      - Для типа `sbyte`, старший бит интерпретируется как знак, поэтому это отрицательное число.
      - Чтобы узнать значение: инвертируем (`0011_1011`), добавляем 1 (`0011_1100` = 60), и ставим знак `-`.

2. **В режиме `checked`**:
   - Попытка выполнить переполнение приводит к выбросу исключения `OverflowException`.

С исключениями в C# мы познакомимся попозже.

Компилятор C# выполняет проверки переполнения для некоторых случаев например, литералы, которые явно не помещаются в целевой тип.
Это как раз наш случай. Давайте попробуем сделать явное приведение литерала к типу `sbyte`. То есть как бы обрезать большой ящик
и запихнуть его в маленький 😊. Приведите программу к следующему виду:

![Целочисленные литералы в C#](int_vars04.png){ border-effect="line"  thumbnail="true" width="700" }

Мы использовали операцию приведения к типу. Для типа `sbyte` она выглядит так `(sbyte)` перед значением которое приводится
к этому типу.

Видите что в 13 строке теперь нет ошибки? А в 12 строке ошибка сохранилась. Но она уже стала другой [CS0221](https://learn.microsoft.com/ru-ru/dotnet/csharp/misc/cs0221?f1url=%3FappId%3Droslyn%26k%3Dk(CS0221)).
Так же этот тип ошибки поменялся и для строк 10 и 11. Ошибка для строки 14 осталась без изменений.

Давайте пока сосредоточим внимание на строках 12 и 13. Ведь там по существу происходит одно и тоже. Присвоение числа 196
переменной типа `sbyte` причем с приведением значения к этому типу. Почему же в одном случае есть ошибка в другом нет?
А так же рассмотрим 14 строку, так как она тоже интересна. Там ведь у нас тоже есть приведение к типу `sbyte` и кроме того

Разница между строками `c = (sbyte)intN;` и `b = (sbyte)196;` заключается в **разной обработке компилятором литералов и переменных** 
при явном приведении типов. Давайте разберём это шаг за шагом:

### 1. Проблема с литералом `196` в строке `b = (sbyte)196;`
- **Литералы в C# анализируются на этапе компиляции.**
    - Литерал `196` — это значение типа `int`.
    - Компилятор видит, что значение `196` выходит за пределы диапазона типа `sbyte` (-128...127).
    - **Ошибка компиляции** возникает сразу, так как компилятор пытается предотвратить переполнение ещё до выполнения программы.

Даже с явным приведением, как `(sbyte)196`, компилятор **не разрешает такую запись**, так как переполнение уже очевидно на этапе компиляции.

### 2. Почему строка `c = (sbyte)intN;` работает?
- **Переменная `intN` — это значение типа `int`, известное только во время выполнения программы.**
    - Компилятор не знает, чему будет равно `intN` (даже если оно объявлено как `196`).
    - Компилятор допускает явное приведение `(sbyte)intN`, полагая, что разработчик осознаёт риск переполнения.
    - Во время выполнения программы значение `196` будет преобразовано в `sbyte` с **переполнением**, результатом будет `-60`.
 
### 3. Почему компилятор ведёт себя по-разному? {id="3_1"}
Компилятор C# различает **литералы** и **переменные** для обработки явных приведений:
- Для **литералов**:
    - Если переполнение очевидно на этапе компиляции (например, `196` для типа `sbyte`), компилятор генерирует **ошибку компиляции**.
- Для **переменных**:
    - Приведение типов всегда разрешено, даже если во время выполнения это вызовет переполнение.

### 4. Почему строка `d = (sbyte)intN - 136;` выдаёт ошибку?
Эта строка более сложная:
- Оператор `-` имеет более высокий приоритет, чем приведение типа `(sbyte)`.
- Выражение `intN - 136` сначала вычисляется как **значение типа `int`**, а результатом будет `60` (тип `int`).
- Затем компилятор пытается присвоить значение `60` переменной типа `sbyte`, что вызывает ошибку, так как для приведения к `sbyte` требуется явное приведение всего выражения:
  ```c#
  d = (sbyte)(intN - 136);
  ```

### Резюме по переполнению типов
1. **Литералы** анализируются на этапе компиляции. Если значение выходит за пределы допустимого диапазона, компилятор выдаёт ошибку, даже при явном приведении.
2. **Переменные** проверяются только на этапе выполнения. Компилятор допускает приведение, даже если оно приведёт к переполнению.
3. Для сложных выражений результат промежуточных операций всегда имеет тип `int` (или более широкий тип), и приведение необходимо делать для всего выражения.

Теперь нам осталось разрешить явно переполнение в строках с 10 по 13. А 14 поправить как писалось чуть выше. Приводим программу к следующему виду:

```C#
namespace IntLiteralsDefaultVal;

class Program
{
    static sbyte a0b, a0x, b, c, d;
    static int intN = 196;

    static void Main()
    {
        a0b = unchecked((sbyte)0b1100_0100); // 196 без знаковое, -60 знаковое
        a0x = unchecked((sbyte)0xC4); // 196 без знаковое, -60 знаковое
        b = unchecked((sbyte)196);
        c = (sbyte)intN;
        d = (sbyte)(intN - 136);

        WriteLine($"{a0b} {a0x} {b} {c} {d} {intN}");
    }
}
```
Запускаем и получаем результат: `-60 -60 -60 -60 60 196`

### **Подведем итоги по целочисленным литералам:**
1. **Десятичный** литерал — это обычное число, которое мы видим в повседневной жизни.
2. **Шестнадцатеричный** и **двоичный** литералы удобны для работы с низкоуровневыми данными, такими как цвета или побитовые операции.
3. **Шестнадцатеричный** и **двоичный** литералы всегда интерпретируются компилятором как положительные числа.
4. **Разделители цифр** делают код более читаемым, особенно для больших чисел или сложных двоичных представлений.
5. **Целочисленные литералы** имеют тип **`int`** по умолчанию.
6. **Суффиксы** могут определить другие типы для литералов: `long`, `ulong` или `uint`.
7. Для литералов надо явно указывать операцию разрешения переполнения `unchecked` если это необходимо.

В этом упражнении мы затронули операцию приведения типов и явного разрешения переполнения. Узнали что такое переполнение 
и как ведет себя компилятор со всем этим добром. Могу предположить, что если вы только начинаете изучать C# это всё может
выглядеть не понятным. Просто продолжай, падаван, и свет истины откроется тебе!

## Операции над целочисленными типами
В C# над целочисленными типами возможны следующие операции:

### 1. **Арифметические операции**
- `+` (Сложение)
- `-` (Вычитание)
- `*` (Умножение)
- `/` (Деление)
- `%` (Остаток от деления)

### 2. **Инкремент и декремент**
- `++` (Инкремент — увеличение на 1, префиксный и постфиксный)
- `--` (Декремент — уменьшение на 1, префиксный и постфиксный)

### 3. **Побитовые операции**
- `&` (Побитовая И)
- `|` (Побитовая ИЛИ)
- `^` (Побитовая исключающая ИЛИ)
- `~` (Побитовое НЕ)
- `<<` (Сдвиг влево)
- `>>` (Сдвиг вправо)

### 4. **Логические операции**
Результатом логических операций над любыми типами всегда является логическое значение: `true` или `false`. 
- `==` (Равно)
- `!=` (Не равно)
- `<` (Меньше)
- `>` (Больше)
- `<=` (Меньше или равно)
- `>=` (Больше или равно)

### 5. **Операции присваивания**
- `=` (Присваивание)
- `+=` (Сложение с присваиванием)
- `-=` (Вычитание с присваиванием)
- `*=` (Умножение с присваиванием)
- `/=` (Деление с присваиванием)
- `%=` (Остаток с присваиванием)
- `&=` (Побитовая И с присваиванием)
- `|=` (Побитовая ИЛИ с присваиванием)
- `^=` (Побитовая исключающая ИЛИ с присваиванием)
- `<<=` (Сдвиг влево с присваиванием)
- `>>=` (Сдвиг вправо с присваиванием)

### 6. **Унарные операции:**
- (смена знака числа)
+ (явное указание положительного числа, редко используется)

### 7. **Приведение типов**
- Неявное приведение выполняется автоматически (меньший тип → больший):  
  Например, `int` → `long`.
- `(<type>)`Явное приведение (больший тип → меньший):  
  Например, `long` → `int`.

### 8. **Операции проверки переполнения:**
- В режиме checked генерируется исключение при переполнении.
- В режиме unchecked переполнение игнорируется.

Теперь практика по всем операциям над целочисленными типами. Создайте проект `ex0018_int_operations` при помощи 
шаблона `tinyconsole`. Добавьте его в решение `episode02.sln`. Файл `Program.cs` приведите к следующему виду:

```c#
using System;

namespace IntegerOperations;

class Program
{
    static void Main(string[] args)
    {
        // Арифметические операции
        int a = 10; // объявление переменной a и инициализация её значением 10
        int b; // объявление переменной b
        b = 3; //  присвоение переменной b значения 3
        WriteLine("Арифметические операции:");
        WriteLine($"Значения в начале демонстрации a = {a},   b = {b}");
        WriteLine($"{a} + {b} = {a + b}");
        WriteLine($"{a} - {b} = {a - b}");
        WriteLine($"{a} * {b} = {a * b}");
        WriteLine($"{a} / {b} = {a / b}");
        WriteLine($"{a} % {b} = {a % b}");
        WriteLine($"Значения в конце демонстрации a = {a},   b = {b}");

        // Инкремент и декремент
        WriteLine("\nИнкремент и декремент:");
        int c = 5;
        WriteLine($"Значение в начале демонстрации c = {c}");
        WriteLine($"Префиксный инкремент ++c: {c} -> {++c}"); // сначала применяется операция ++ потом выводится значение
        WriteLine($"Постфиксный инкремент c++: {c++} -> {c}"); // сперва выводится значение потом применяется операция ++
        WriteLine($"Префиксный декремент --c: {c} -> {--c}"); // сначала применяется операция -- потом выводится значение
        WriteLine($"Постфиксный декремент c--: {c--} -> {c}"); // сперва выводится значение потом применяется операция --
        ++c; // увеличили значение переменной c на 1
        WriteLine($"Значение в конце демонстрации c = {c}");

        // Побитовые операции
        WriteLine("\nПобитовые операции в десятичном представлении:");
        a = 5; // присвоили переменной a значение 5 в двоичном виде это 0101
        b = 3; // присвоили переменной b значение 3 в двоичном виде это 0011
        WriteLine($"Значения в начале демонстрации a = {a},   b = {b}");
        WriteLine($"{a} & {b} = {a & b}"); // 0001
        WriteLine($"{a} | {b} = {a | b}"); // 0111
        WriteLine($"{a} ^ {b} = {a ^ b}"); // 0110
        WriteLine($"~{a} = {~a}");       // ...1010 (дополнение до отрицательного числа)
        WriteLine($"{a} << 1 = {a << 1}"); // 1010
        WriteLine($"{a} >> 1 = {a >> 1}"); // 0010
        WriteLine($"Значения в конце демонстрации a = {a},   b = {b}\n");

        BitwiseOperatins.ShowInBinary(); // вызов статического метода ShowInBinary() статического класса BitwiseOperatins

        // Логические операции
        WriteLine("\nЛогические операции:");
        a = 15; // присвоили переменной a значение 15
        b = 5; // присовили переменной b значение 5
        WriteLine($"Значения в начале демонстрации a = {a},   b = {b}");
        WriteLine($"{a} == {b}: {a == b}");
        WriteLine($"{a} != {b}: {a != b}");
        WriteLine($"{a} > {b}: {a > b}");
        WriteLine($"{a} < {b}: {a < b}");
        WriteLine($"{a} >= {b}: {a >= b}");
        WriteLine($"{a} <= {b}: {a <= b}");
        WriteLine($"Значения в конце демонстрации a = {a},   b = {b}");

        // Операции присваивания
        WriteLine("\nОперации присваивания:");
        int d = 10;
        WriteLine($"Значение в начале демонстрации d = {d}");
        d += 5; WriteLine($"{d} += 5 -> {d}");
        d -= 3; WriteLine($"{d} -= 3 -> {d}");
        d *= 2; WriteLine($"{d} *= 2 -> {d}");
        d /= 4; WriteLine($"{d} /= 4 -> {d}");
        d %= 3; WriteLine($"{d} %= 3 -> {d}");
        d &= 2; WriteLine($"{d} &= 2 -> {d}");
        d |= 1; WriteLine($"{d} |= 1 -> {d}");
        d ^= 3; WriteLine($"{d} ^= 3 -> {d}");
        d <<= 2; WriteLine($"{d} <<= 2 -> {d}");
        d >>= 1; WriteLine($"{d} >>= 1 -> {d}");
        WriteLine($"Значение в конце демонстрации d = {d}");

        // Унарная операция смены знака
        WriteLine("\nУнарная операция смены знака:");
        int originalNumber = 42; // Исходное число
        int negativeNumber = -originalNumber; // Меняем знак на отрицательный        
        int positiveNumber = -negativeNumber; // Меняем знак обратно на положительный
        WriteLine($"Исходное число: {originalNumber}");
        WriteLine($"Число с отрицательным знаком: {negativeNumber}");
        WriteLine($"Число с положительным знаком: {positiveNumber}");

        // Приведение типов
        WriteLine("\nПриведение типов:");
        long bigValue = 1000L;
        int smallValue = (int)bigValue; // Явное приведение
        WriteLine($"Явное приведение: long -> int: {smallValue}");
        int value = 100;
        long largeValue = value; // Неявное приведение
        WriteLine($"Неявное приведение: int -> long: {largeValue}");

        // Операции проверки переполнения
        WriteLine("\nПроверка переполнения:");
        sbyte x = unchecked((sbyte)196); // 196 выходит за пределы диапазона sbyte
        WriteLine($"С разрешенным переполнением unchecked: x = {x}"); // Ожидается результат: -60

        // Пример с checked: будет выброшено исключение OverflowException
        WriteLine($"\nС запрещенным переполнением checked:");
        try
        {
            int z = 196;
            WriteLine($"\nz = {z}");
            sbyte y = checked((sbyte)z);
            WriteLine($"Checked: y = {y}");
        }
        catch (OverflowException ex)
        {
            WriteLine($"Checked: Переполнение типа: {ex.Message}");
        }

        try
        {
            int z = -128;
            WriteLine($"\nz = {z}");
            sbyte y = checked((sbyte)z);
            WriteLine($"Checked: y = {y}");
        }
        catch (OverflowException ex)
        {
            WriteLine($"Checked: Переполнение типа: {ex.Message}");
        }
    }
}
```

Затем в каталоге проекта `ex0018_int_operations` создайте файл `BitwiseOperations.cs` со следующим содержимым:

```C#
using System;

namespace IntegerOperations;

public static class BitwiseOperatins
{
    public static void ShowInBinary()
    {
        // Положительные переменные
        byte a = 0b0011_1100; // 60 в десятичной системе
        byte b = 0b0000_1101; // 13 в десятичной системе
        WriteLine($"a: {a} (десятичные), {Convert.ToString(a, 2).PadLeft(8, '0')} (двоичные)");
        WriteLine($"b: {b} (десятичные), {Convert.ToString(b, 2).PadLeft(8, '0')} (двоичные)");

        // Отрицательная переменная (двоичный литерал для -60)
        sbyte negA = unchecked((sbyte)0b1100_0100); // Двоичный литерал для -60
        WriteLine($"negA: {negA} (десятичные), {Convert.ToString((byte)negA, 2).PadLeft(8, '0')} (двоичные)");

        WriteLine("\n=== Побитовые операции для byte и sbyte в двоичном и десятичном представлении ===");

        // Побитовая И (AND)
        byte andResult = (byte)(a & b);
        WriteLine($"a & b: {Convert.ToString(a, 2).PadLeft(8, '0')} & {Convert.ToString(b, 2).PadLeft(8, '0')} = {Convert.ToString(andResult, 2).PadLeft(8, '0')} (двоичные), {a} & {b} = {andResult} (десятичные)");

        // Побитовая ИЛИ (OR)
        byte orResult = (byte)(a | b);
        WriteLine($"a | b: {Convert.ToString(a, 2).PadLeft(8, '0')} | {Convert.ToString(b, 2).PadLeft(8, '0')} = {Convert.ToString(orResult, 2).PadLeft(8, '0')} (двоичные), {a} | {b} = {orResult} (десятичные)");

        // Побитовая исключающая ИЛИ (XOR)
        byte xorResult = (byte)(a ^ b);
        WriteLine($"a ^ b: {Convert.ToString(a, 2).PadLeft(8, '0')} ^ {Convert.ToString(b, 2).PadLeft(8, '0')} = {Convert.ToString(xorResult, 2).PadLeft(8, '0')} (двоичные), {a} ^ {b} = {xorResult} (десятичные)");

        // Побитовая инверсия (NOT)
        byte notA = (byte)~a;
        sbyte notNegA = (sbyte)~negA;
        WriteLine($"~a: ~{Convert.ToString(a, 2).PadLeft(8, '0')} = {Convert.ToString(notA, 2).PadLeft(8, '0')} (двоичные), ~{a} = {notA} (десятичные)");
        WriteLine($"~negA: ~{Convert.ToString((byte)negA, 2).PadLeft(8, '0')} = {Convert.ToString((byte)notNegA, 2).PadLeft(8, '0')} (двоичные), ~{negA} = {notNegA} (десятичные)");

        WriteLine("\n=== Побитовые сдвиги для byte и sbyte в двоичном и десятичном представлении ===");

        // Сдвиг влево
        byte shiftLeftA = (byte)(a << 2);
        sbyte shiftLeftNegA = (sbyte)(negA << 2);
        WriteLine($"a << 2: {Convert.ToString(a, 2).PadLeft(8, '0')} << 2 = {Convert.ToString(shiftLeftA, 2).PadLeft(8, '0')} (двоичные), {a} << 2 = {shiftLeftA} (десятичные)");
        WriteLine($"negA << 2: {Convert.ToString((byte)negA, 2).PadLeft(8, '0')} << 2 = {Convert.ToString((byte)shiftLeftNegA, 2).PadLeft(8, '0')} (двоичные), {negA} << 2 = {shiftLeftNegA} (десятичные)");

        // Сдвиг вправо
        byte shiftRightA = (byte)(a >> 2);
        sbyte shiftRightNegA = (sbyte)(negA >> 2);
        WriteLine($"a >> 2: {Convert.ToString(a, 2).PadLeft(8, '0')} >> 2 = {Convert.ToString(shiftRightA, 2).PadLeft(8, '0')} (двоичные), {a} >> 2 = {shiftRightA} (десятичные)");
        WriteLine($"negA >> 2: {Convert.ToString((byte)negA, 2).PadLeft(8, '0')} >> 2 = {Convert.ToString((byte)shiftRightNegA, 2).PadLeft(8, '0')} (двоичные), {negA} >> 2 = {shiftRightNegA} (десятичные)");
    }
}
```
Структура проекта у вас должна выглядеть после этого так:

![Операции над целочисленными типами в C#](int_vars05.png){ border-effect="line"  thumbnail="true" width="700" }

Выполните наш проект. Результат должен быть таким:

```
Арифметические операции:
Значения в начале демонстрации a = 10,   b = 3
10 + 3 = 13
10 - 3 = 7
10 * 3 = 30
10 / 3 = 3
10 % 3 = 1
Значения в конце демонстрации a = 10,   b = 3

Инкремент и декремент:
Значение в начале демонстрации c = 5
Префиксный инкремент ++c: 5 -> 6
Постфиксный инкремент c++: 6 -> 7
Префиксный декремент --c: 7 -> 6
Постфиксный декремент c--: 6 -> 5
Значение в конце демонстрации c = 6

Побитовые операции в десятичном представлении:
Значения в начале демонстрации a = 5,   b = 3
5 & 3 = 1
5 | 3 = 7
5 ^ 3 = 6
~5 = -6
5 << 1 = 10
5 >> 1 = 2
Значения в конце демонстрации a = 5,   b = 3

a: 60 (десятичные), 00111100 (двоичные)
b: 13 (десятичные), 00001101 (двоичные)
negA: -60 (десятичные), 11000100 (двоичные)

=== Побитовые операции для byte и sbyte в двоичном и десятичном представлении ===
a & b: 00111100 & 00001101 = 00001100 (двоичные), 60 & 13 = 12 (десятичные)      
a | b: 00111100 | 00001101 = 00111101 (двоичные), 60 | 13 = 61 (десятичные)      
a ^ b: 00111100 ^ 00001101 = 00110001 (двоичные), 60 ^ 13 = 49 (десятичные)      
~a: ~00111100 = 11000011 (двоичные), ~60 = 195 (десятичные)
~negA: ~11000100 = 00111011 (двоичные), ~-60 = 59 (десятичные)

=== Побитовые сдвиги для byte и sbyte в двоичном и десятичном представлении ===  
a << 2: 00111100 << 2 = 11110000 (двоичные), 60 << 2 = 240 (десятичные)
negA << 2: 11000100 << 2 = 00010000 (двоичные), -60 << 2 = 16 (десятичные)       
a >> 2: 00111100 >> 2 = 00001111 (двоичные), 60 >> 2 = 15 (десятичные)
negA >> 2: 11000100 >> 2 = 11110001 (двоичные), -60 >> 2 = -15 (десятичные)      

Логические операции:
Значения в начале демонстрации a = 15,   b = 5
15 == 5: False
15 != 5: True
15 > 5: True
15 < 5: False
15 >= 5: True
15 <= 5: False
Значения в конце демонстрации a = 15,   b = 5

Операции присваивания:
Значение в начале демонстрации d = 10
15 += 5 -> 15
12 -= 3 -> 12
24 *= 2 -> 24
6 /= 4 -> 6
0 %= 3 -> 0
0 &= 2 -> 0
1 |= 1 -> 1
2 ^= 3 -> 2
8 <<= 2 -> 8
4 >>= 1 -> 4
Значение в конце демонстрации d = 4

Унарная операция смены знака:
Исходное число: 42
Число с отрицательным знаком: -42
Число с положительным знаком: 42

Приведение типов:
Явное приведение: long -> int: 1000
Неявное приведение: int -> long: 100

Проверка переполнения:
С разрешенным переполнением unchecked: x = -60

С запрещенным переполнением checked:

z = 196
Checked: Переполнение типа: Arithmetic operation resulted in an overflow.

z = -128
Checked: y = -128
```
Не пугайтесь если вам не всё понятно. Это нормально. Особенно в файле `BitwiseOperations.cs`. Там много магии силы. Хотя
на самом деле там ни чего сложного нет, просто форматирование вывода. Чтобы красиво было. Сейчас постараюсь всё объяснить.

Давайте разберем первый блок где выполняются арифметические операции.

![Операции над целочисленными типами в C#](int_vars06.png){ border-effect="line"  thumbnail="true" width="700" }

Этот код демонстрирует базовые арифметические операции в языке C#. Рассмотрим его работу и особенности.

### **Что делает код:**

1. **Объявление и инициализация переменных:**
    - Переменная `a` объявлена и сразу инициализирована значением `10`:
      ```c#
      int a = 10;
      ```
      Это называется **объявление с инициализацией**.
    - Переменная `b` сначала объявлена:
      ```c#
      int b;
      ```
      А затем ей присвоено значение `3`:
      ```c#
      b = 3;
      ```
      Это называется **объявление без инициализации**.

2. **Вывод исходных значений:**
    - Вывод текста с начальным значением переменных:
      ```c#
      WriteLine($"Значения в начале демонстрации a = {a},   b = {b}");
      ```
      Интерполяция строки (строке предшествует знак `$`) (`$"..."`) используется для динамической вставки значений переменных `a` и `b` в текст.

3. **Арифметические операции:**
    - Выполняются базовые операции: сложение (`+`), вычитание (`-`), умножение (`*`), деление (`/`), и остаток от деления (`%`).
    - Результаты каждой операции выводятся с помощью команды (пример для операции сложения):
      ```c#
      WriteLine($"{a} + {b} = {a + b}");
      ```
      Здесь значения `a` и `b` подставляются в строку, а выражение `a + b` вычисляется и отображается как результат.

4. **Вывод конечных значений переменных:**
    - В конце демонстрации выводятся значения переменных `a` и `b`:
      ```c#
      WriteLine($"Значения в конце демонстрации a = {a},   b = {b}");
      ```
      Они остаются неизменными, так как в процессе выполнения операций их значения не перезаписываются.

### **Почему переменные `a` и `b` не изменились?**
- Все арифметические операции выполняются с использованием значений `a` и `b`, но **результаты этих операций нигде не сохраняются**.
- Например:
  ```c#
  a + b;
  ```
  Этот результат вычисляется и сразу передается в метод `WriteLine` для вывода, но переменные `a` и `b` остаются без изменений.

### **Как происходит вычисление и вывод результата?**

1. **Вычисление:**
    - Например, для строки:
      ```c#
      WriteLine($"{a} + {b} = {a + b}");
      ```
      Сначала выполняются следующие шаги:
        - Берется текущее значение `a` (10) и `b` (3).
        - Производится сложение `10 + 3`, результат — `13`.
    - Затем результат подставляется в строку.

2. **Вывод:**
    - Метод `WriteLine` выводит текст в консоль. Строка, переданная в метод, формируется с использованием интерполяции (`$"..."`), 
    - где значения переменных и результаты операций подставляются в указанные места в строке.

### **Разница между операторами `/` и `%`:**
1. **`/` — деление (division):**
    - Делит одно число на другое и возвращает **целую часть результата** (для целых чисел).
    - Например:
      ```c#
      10 / 3 → 3
      ```
      Дробная часть (остаток) отбрасывается.

2. **`%` — остаток от деления (modulus):**
    - Возвращает **остаток от деления**.
    - Например:
      ```c#
      10 % 3 → 1
      ```
      Это остаток, который остается после выполнения целого деления.

### **Пример вывода в консоли:**
```
Арифметические операции:
Значения в начале демонстрации a = 10,   b = 3
10 + 3 = 13
10 - 3 = 7
10 * 3 = 30
10 / 3 = 3
10 % 3 = 1
Значения в конце демонстрации a = 10,   b = 3
```

### **Резюме:**
1. Переменные `a` и `b` не изменяются, так как операции не изменяют их значения.
2. Арифметические операции выполняются с текущими значениями `a` и `b`, результаты сразу передаются в метод `WriteLine`.
3. Операторы `/` и `%` работают с целочисленным делением: `/` возвращает целую часть, `%` — остаток.

Надеюсь с этим самым простым блоком операций всё понятно, падаван.

Теперь разберем следующий блок с инкрементом и декрементом.

![Операции над целочисленными типами в C#](int_vars07.png){ border-effect="line"  thumbnail="true" width="700" }

Этот код демонстрирует два вида операций инкремента (`++`) и декремента (`--`) в C# и объясняет их различия. Рассмотрим работу кода и разберем особенности.

### **Инкремент и декремент:**
Инкремент (`++`) увеличивает значение переменной на единицу.  
Декремент (`--`) уменьшает значение переменной на единицу.

Обе операции бывают **префиксными** и **постфиксными**, что определяет порядок выполнения операции относительно 
использования значения переменной.

### **Различия между префиксным и постфиксным инкрементом/декрементом:**

1. **Префиксный инкремент/декремент (`++c` или `--c`):**
    - Операция выполняется **до** использования значения переменной.
    - Сначала значение переменной изменяется, а затем используется в выражении.

2. **Постфиксный инкремент/декремент (`c++` или `c--`):**
    - Операция выполняется **после** использования значения переменной.
    - Сначала используется текущее значение переменной в выражении, а затем оно изменяется.

### **Разбор работы кода:**

1. **Начальное значение переменной:**
   ```c#
   int c = 5;
   WriteLine($"Значение в начале демонстрации c = {c}");
   ```
   Переменная `c` инициализирована значением `5`. Это значение выводится в консоль.

2. **Префиксный инкремент:**
   ```c#
   WriteLine($"Префиксный инкремент ++c: {c} -> {++c}");
   ```
    - Сначала переменная `c` увеличивается на 1 (становится `6`).
    - Затем новое значение (`6`) используется для вывода.
    - Результат:
      ```
      Префиксный инкремент ++c: 5 -> 6
      ```

3. **Постфиксный инкремент:**
   ```c#
   WriteLine($"Постфиксный инкремент c++: {c++} -> {c}");
   ```
    - Сначала используется текущее значение переменной `c` (это `6`).
    - Затем `c` увеличивается на 1 (становится `7`).
    - Результат:
      ```
      Постфиксный инкремент c++: 6 -> 7
      ```

4. **Префиксный декремент:**
   ```c#
   WriteLine($"Префиксный декремент --c: {c} -> {--c}");
   ```
    - Сначала `c` уменьшается на 1 (становится `6`).
    - Затем новое значение (`6`) используется для вывода.
    - Результат:
      ```
      Префиксный декремент --c: 7 -> 6
      ```

5. **Постфиксный декремент:**
   ```c#
   WriteLine($"Постфиксный декремент c--: {c--} -> {c}");
   ```
    - Сначала используется текущее значение переменной `c` (это `6`).
    - Затем `c` уменьшается на 1 (становится `5`).
    - Результат:
      ```
      Постфиксный декремент c--: 6 -> 5
      ```

6. **Увеличение переменной вне вывода:**
   ```c#
   ++c;
   ```
    - Префиксный инкремент увеличивает `c` на 1 (становится `6`).

7. **Конечное значение переменной:**
   ```c#
   WriteLine($"Значение в конце демонстрации c = {c}");
   ```
    - Выводится итоговое значение `c`, равное `6`.

### **Почему значение переменной `c` меняется?** {id="c_1"}
Операции `++` и `--` непосредственно изменяют значение переменной `c`.  
Каждый вызов этих операций:
- Увеличивает (`++`) или уменьшает (`--`) значение переменной.
- Это изменение записывается в переменную, поэтому её значение обновляется.

### **Пример вывода в консоли:**
```
Инкремент и декремент:
Значение в начале демонстрации c = 5
Префиксный инкремент ++c: 5 -> 6
Постфиксный инкремент c++: 6 -> 7
Префиксный декремент --c: 7 -> 6
Постфиксный декремент c--: 6 -> 5
Значение в конце демонстрации c = 6
```

### **Резюме:**
1. Префиксный инкремент/декремент изменяет значение **до** использования переменной.
2. Постфиксный инкремент/декремент изменяет значение **после** использования переменной.
3. Изменение переменной сохраняется, поскольку операции `++` и `--` напрямую модифицируют значение переменной в памяти.

Теперь рассмотрим блок с побитовыми операциями.

![Операции над целочисленными типами в C#](int_vars08.png){ border-effect="line"  thumbnail="true" width="700" }

Побитовые операции в программировании позволяют работать с числами на уровне их двоичного представления (нолей и единиц). Давайте разберем приведенный код и подробно объясним, как он работает.

### **Исходные данные:**
1. `a = 5`
    - В двоичном виде: `0101` (четыре бита).
2. `b = 3`
    - В двоичном виде: `0011`.

Эти числа будут использоваться для выполнения различных побитовых операций.

### **Побитовые операции:**

#### 1. **Логическое "И" (`&`)** {id="1_1"}
```c
WriteLine($"{a} & {b} = {a & b}");
```
- Операция `&` берет каждый бит двух чисел и выполняет логическое "И":
    - Результат будет `1`, только если оба соответствующих бита равны `1`.
    - В противном случае — `0`.

- Пример:
  ```
  a: 0101
  b: 0011
  --------
  & : 0001
  ```
- В десятичном виде: `0001` = `1`.

**Результат:** `5 & 3 = 1`.

#### 2. **Логическое "ИЛИ" (`|`)** {id="2_1"}
```c#
WriteLine($"{a} | {b} = {a | b}");
```
- Операция `|` берет каждый бит двух чисел и выполняет логическое "ИЛИ":
    - Результат будет `1`, если хотя бы один из соответствующих битов равен `1`.

- Пример:
  ```
  a: 0101
  b: 0011
  --------
  | : 0111
  ```
- В десятичном виде: `0111` = `7`.

**Результат:** `5 | 3 = 7`.

#### 3. **Логическое "Исключающее ИЛИ" (`^`)** {id="3_2"}
```c#
WriteLine($"{a} ^ {b} = {a ^ b}");
```
- Операция `^` (исключающее ИЛИ) берет каждый бит двух чисел и выполняет сравнение:
    - Результат будет `1`, только если биты различны (один равен `1`, другой — `0`).
    - Если оба бита одинаковы (оба `1` или оба `0`), результат будет `0`.

- Пример:
  ```
  a: 0101
  b: 0011
  --------
  ^ : 0110
  ```
- В десятичном виде: `0110` = `6`.

**Результат:** `5 ^ 3 = 6`.

#### 4. **Побитовая инверсия (`~`)** {id="4_1"}
```c#
WriteLine($"~{a} = {~a}");
```
- Операция `~` инвертирует все биты числа:
    - `0` становится `1`, а `1` становится `0`.

Для понимания результата нужно учитывать, что числа в компьютере хранятся в виде **дополнительного кода**. 
В 32-битной системе, инверсия числа `a` работает так:

- Число `5` в двоичном виде (32 бита):
  ```
  00000000 00000000 00000000 00000101
  ```
- Инверсия:
  ```
  11111111 11111111 11111111 11111010
  ```
- Это представление отрицательного числа, равного `-6` в десятичной системе.

**Результат:** `~5 = -6`.

#### 5. **Сдвиг влево (`<<`)** {id="5_1"}
```c#
WriteLine($"{a} << 1 = {a << 1}");
```
- Операция `<<` сдвигает все биты числа влево на указанное количество позиций.
    - Освободившиеся справа биты заполняются нулями.

- Пример (сдвиг на 1 позицию):
  ```
  a: 0101 (5)
  << : 1010 (10)
  ```
- В десятичном виде: `1010` = `10`.

**Результат:** `5 << 1 = 10`.

#### 6. **Сдвиг вправо (`>>`)** {id="6_1"}
```c#
WriteLine($"{a} >> 1 = {a >> 1}");
```
- Операция `>>` сдвигает все биты числа вправо на указанное количество позиций.
    - Освободившиеся слева биты заполняются нулями (для положительных чисел).

- Пример (сдвиг на 1 позицию):
  ```
  a: 0101 (5)
  >> : 0010 (2)
  ```
- В десятичном виде: `0010` = `2`.

**Результат:** `5 >> 1 = 2`.

### **Результаты в консоли:**
```
Побитовые операции в десятичном представлении:
Значения в начале демонстрации a = 5,   b = 3
5 & 3 = 1
5 | 3 = 7
5 ^ 3 = 6
~5 = -6
5 << 1 = 10
5 >> 1 = 2
Значения в конце демонстрации a = 5,   b = 3
```

### **Ключевые моменты для понимания:**
1. **Побитовые операции работают на уровне битов чисел.**  
   Они выполняют операции над каждым битом отдельно.

2. **Числа хранятся в двоичном виде.**  
   Поэтому для понимания операций удобно переводить числа в двоичное представление.

3. **Сдвиговые операции меняют расположение битов.**
    - Сдвиг влево увеличивает число вдвое за каждую позицию.
    - Сдвиг вправо уменьшает число вдвое за каждую позицию.

4. **Инверсия использует дополнительный код для отрицательных чисел.**  
   Поэтому результат инверсии положительного числа становится отрицательным.

5. **Операции не изменяют исходные переменные.**  
   В конце демонстрации `a` и `b` остаются равны своим начальным значениям (`5` и `3`).


Теперь рассмотрим блок с логическими операциями.

![Операции над целочисленными типами в C#](int_vars09.png){ border-effect="line"  thumbnail="true" width="700" }

Давайте разберем построчно, что делает этот код. Я объясню все операции максимально просто, чтобы было понятно даже школьнику.

### 1. **`WriteLine("\nЛогические операции:");`**
Эта строка выводит заголовок "Логические операции" и переносит строку перед ним (символ `\n` означает новую строку). 
Это сделано для того, чтобы было видно, что начинается новая часть программы.

### 2. **`a = 15;`**
Здесь переменной `a` присваивается значение `15`. Переменная — это как коробка, в которую кладут число. 
Теперь в коробке `a` лежит число `15`.

### 3. **`b = 5;`**
Точно так же переменной `b` присваивается значение `5`. Теперь в коробке `b` лежит число `5`.

### 4. **`WriteLine($"Значения в начале демонстрации a = {a},   b = {b}");`**
Эта строка выводит текущие значения переменных `a` и `b`.  
Шаблон `{$a}` означает, что вместо `{a}` подставляется текущее значение переменной `a`.  
Результат будет:
```
Значения в начале демонстрации a = 15,   b = 5
```

### 5. **`WriteLine($"{a} == {b}: {a == b}");`**
- Операция `==` сравнивает два числа и проверяет, равны ли они.
- Если `a` равно `b`, результат будет `True` (истина).  
  Если не равно — `False` (ложь).
- В данном случае `15 == 5` — это **ложь**, поэтому вывод будет:
```
15 == 5: False
```

### 6. **`WriteLine($"{a} != {b}: {a != b}");`**
- Операция `!=` проверяет, НЕ равны ли два числа.
- Если числа разные, результат будет `True`. Если одинаковые — `False`.
- Здесь `15 != 5` — это **истина**, поэтому вывод будет:
```
15 != 5: True
```

### 7. **`WriteLine($"{a} > {b}: {a > b}");`**
- Операция `>` проверяет, больше ли `a`, чем `b`.
- Здесь `15 > 5` — это **истина**, поэтому вывод будет:
```
15 > 5: True
```

### 8. **`WriteLine($"{a} < {b}: {a < b}");`**
- Операция `<` проверяет, меньше ли `a`, чем `b`.
- Здесь `15 < 5` — это **ложь**, поэтому вывод будет:
```
15 < 5: False
```

### 9. **`WriteLine($"{a} >= {b}: {a >= b}");`**
- Операция `>=` проверяет, больше ли `a` или равно `b`.
- Здесь `15 >= 5` — это **истина**, потому что `15` больше `5`. Вывод:
```
15 >= 5: True
```

### 10. **`WriteLine($"{a} <= {b}: {a <= b}");`**
- Операция `<=` проверяет, меньше ли `a` или равно `b`.
- Здесь `15 <= 5` — это **ложь**, потому что `15` не меньше и не равно `5`. Вывод:
```
15 <= 5: False
```

### 11. **`WriteLine($"Значения в конце демонстрации a = {a},   b = {b}");`**
Эта строка снова выводит значения переменных `a` и `b`.  
Важно отметить, что логические операции **не меняют значения переменных**, они только проверяют их.  
Результат:
```
Значения в конце демонстрации a = 15,   b = 5
```

Теперь так же подробно рассмотрим блок с операциями присваивания.

![Операции над целочисленными типами в C#](int_vars10.png){ border-effect="line"  thumbnail="true" width="700" }

Обратите внимание, что в данном блоке кода на одной строке располагается сразу две инструкции разделенные знаком окончания
инструкции `;`. Так тоже можно записывать код, если это делает его удобочитаемым. Ну и теперь пройдемся по каждой строке.

### 1. **`WriteLine("\nОперации присваивания:");`** {id="1-writeline-n_1"}
- Эта строка выводит заголовок "Операции присваивания" и переносит строку перед ним (символ `\n` означает новую строку). Это нужно, чтобы читателю программы было видно, что начинается новый блок операций.

### 2. **`int d = 10;`**
- Создаем переменную `d` и кладем в нее число `10`.  
  Это как коробка с именем `d`, в которую мы положили число `10`.

### 3. **`WriteLine($"Значение в начале демонстрации d = {d}");`**
- Выводим текущее значение переменной `d`.  
  Результат будет:
  ```
  Значение в начале демонстрации d = 10
  ```

### 4. **`d += 5; WriteLine($"{d} += 5 -> {d}");`**
- Операция `+=` добавляет к переменной `d` число `5` и сохраняет результат в `d`.  
  То есть, `d = d + 5`.  
  Было `10`, добавили `5`, стало `15`.  
  Вывод:
  ```
  15 += 5 -> 15
  ```

### 5. **`d -= 3; WriteLine($"{d} -= 3 -> {d}");`**
- Операция `-=` уменьшает переменную `d` на `3`.  
  То есть, `d = d - 3`.  
  Было `15`, вычли `3`, стало `12`.  
  Вывод:
  ```
  12 -= 3 -> 12
  ```

### 6. **`d *= 2; WriteLine($"{d} *= 2 -> {d}");`**
- Операция `*=` умножает `d` на `2`.  
  То есть, `d = d * 2`.  
  Было `12`, умножили на `2`, стало `24`.  
  Вывод:
  ```
  24 *= 2 -> 24
  ```

### 7. **`d /= 4; WriteLine($"{d} /= 4 -> {d}");`**
- Операция `/=` делит `d` на `4`.  
  То есть, `d = d / 4`.  
  Было `24`, разделили на `4`, стало `6`.  
  Вывод:
  ```
  6 /= 4 -> 6
  ```

### 8. **`d %= 3; WriteLine($"{d} %= 3 -> {d}");`**
- Операция `%=` находит остаток от деления `d` на `3`.  
  То есть, `d = d % 3`.  
  Остаток от деления `6` на `3` равен `0`.  
  Вывод:
  ```
  0 %= 3 -> 0
  ```

### 9. **`d &= 2; WriteLine($"{d} &= 2 -> {d}");`**
- Операция `&=` выполняет побитовое И с числом `2`.  
  В двоичном виде: `d = d & 2`.  
  Было `0` (двоично `0000`) и `2` (двоично `0010`). Побитовое И оставляет только те биты, которые равны `1` в обоих числах.  
  Результат: `0000` (десятично `0`).  
  Вывод:
  ```
  0 &= 2 -> 0
  ```

### 10. **`d |= 1; WriteLine($"{d} |= 1 -> {d}");`**
- Операция `|=` выполняет побитовое ИЛИ с числом `1`.  
  В двоичном виде: `d = d | 1`.  
  Было `0` (двоично `0000`) и `1` (двоично `0001`). Побитовое ИЛИ устанавливает бит в `1`, если хотя бы один бит равен `1`.  
  Результат: `0001` (десятично `1`).  
  Вывод:
  ```
  1 |= 1 -> 1
  ```

### 11. **`d ^= 3; WriteLine($"{d} ^= 3 -> {d}");`**
- Операция `^=` выполняет побитовое исключающее ИЛИ (XOR) с числом `3`.  
  В двоичном виде: `d = d ^ 3`.  
  Было `1` (двоично `0001`) и `3` (двоично `0011`). Исключающее ИЛИ оставляет `1`, если биты разные.  
  Результат: `0010` (десятично `2`).  
  Вывод:
  ```
  2 ^= 3 -> 2
  ```

### 12. **`d <<= 2; WriteLine($"{d} <<= 2 -> {d}");`**
- Операция `<<=` сдвигает биты в числе `d` влево на `2` позиции.  
  В двоичном виде: `d = d << 2`.  
  Было `2` (двоично `0010`). Сдвигаем влево на 2 бита: `1000`.  
  Результат: `8` (десятично).  
  Вывод:
  ```
  8 <<= 2 -> 8
  ```

### 13. **`d >>= 1; WriteLine($"{d} >>= 1 -> {d}");`**
- Операция `>>=` сдвигает биты в числе `d` вправо на `1` позицию.  
  В двоичном виде: `d = d >> 1`.  
  Было `8` (двоично `1000`). Сдвигаем вправо на 1 бит: `0100`.  
  Результат: `4` (десятично).  
  Вывод:
  ```
  4 >>= 1 -> 4
  ```

### 14. **`WriteLine($"Значение в конце демонстрации d = {d}");`**
- Выводим финальное значение переменной `d`.  
  Результат:
  ```
  Значение в конце демонстрации d = 4
  ```

Теперь переходим к унарной операции смены знака.

![Операции над целочисленными типами в C#](int_vars11.png){ border-effect="line"  thumbnail="true" width="700" }

Давай разберём код построчно, чтобы всё стало понятно даже самому начинающему падвану:

```c#
// Унарная операция смены знака
WriteLine("\nУнарная операция смены знака:");
```
- **`//`**: Это комментарий. Он объясняет, что будет делаться дальше, но не выполняется компьютером. Здесь говорится, что дальше используется "унарная операция смены знака".
- **`WriteLine("\nУнарная операция смены знака:");`**: Эта команда выводит на экран текст "Унарная операция смены знака:" и добавляет пустую строку перед ним (`\n` делает переход на новую строку).

```c#
int originalNumber = 42; // Исходное число
```
- **`int`**: Это тип данных, который означает целое число.
- **`originalNumber`**: Это имя переменной, в которую мы сохраняем значение.
- **`42`**: Это значение, которое мы сохраняем в переменной `originalNumber`.
- **`// Исходное число`**: Комментарий, поясняющий, что это число будет нашим "исходным".

```c#
int negativeNumber = -originalNumber; // Меняем знак на отрицательный
```
- **`negativeNumber`**: Это новая переменная для хранения числа с отрицательным знаком.
- **`-originalNumber`**: Мы берём переменную `originalNumber` (в которой 42) и добавляем перед ней знак "минус", чтобы сделать её отрицательной. Теперь в `negativeNumber` хранится значение `-42`.

```c#
int positiveNumber = -negativeNumber; // Меняем знак обратно на положительный
```
- **`positiveNumber`**: Ещё одна новая переменная.
- **`-negativeNumber`**: Мы берём переменную `negativeNumber` (в которой `-42`) и снова добавляем перед ней знак "минус". Два минуса подряд дают положительное число, поэтому результат будет `42`.

```c#
WriteLine($"Исходное число: {originalNumber}");
```
- Эта строка выводит на экран текст "Исходное число: " и добавляет значение переменной `originalNumber` (то есть `42`).

```c#
WriteLine($"Число с отрицательным знаком: {negativeNumber}");
```
- Эта строка выводит текст "Число с отрицательным знаком: " и значение переменной `negativeNumber` (то есть `-42`).

```c#
WriteLine($"Число с положительным знаком: {positiveNumber}");
```
- Эта строка выводит текст "Число с положительным знаком: " и значение переменной `positiveNumber` (то есть `42`).

### Результат программы:
На экране будет напечатано:
```
Унарная операция смены знака:
Исходное число: 42
Число с отрицательным знаком: -42
Число с положительным знаком: 42
```

Рассмотрим блок приведения типов.

![Операции над целочисленными типами в C#](int_vars12.png){ border-effect="line"  thumbnail="true" width="700" }

### Что такое приведение типов?

**Приведение типов** — это преобразование значения из одного типа данных в другой. Тип данных определяет, какую информацию может хранить переменная (например, целые числа, дробные числа или текст). Иногда при программировании возникает необходимость изменить тип данных, чтобы выполнять операции между разными типами или использовать значения в нужном контексте.

---

### Для чего нужно приведение типов?

1. **Сложение разных типов данных.** Например, складывать целые числа (`int`) и дробные числа (`float`).
2. **Экономия памяти.** Например, преобразование большого типа (`long`) в меньший (`int`), если точность данных позволяет это.
3. **Совместимость.** Некоторые функции или структуры данных могут принимать только определённые типы, поэтому данные приходится преобразовывать.

---

### Разница между явным и неявным приведением типов

1. **Неявное приведение (implicit casting):**
    - Происходит **автоматически**.
    - Используется, когда преобразование безопасно, и данных не теряется.
    - Например, преобразование `int` в `long` (целое число меньшего типа в больший).

   ```c#
   int smallNumber = 42;
   long bigNumber = smallNumber; // Неявное приведение
   ```

2. **Явное приведение (explicit casting):**
    - Должно быть указано **явно** программистом.
    - Используется, когда возможна **потеря данных** или это небезопасное преобразование.
    - Например, преобразование `double` в `int` (дробные данные отбрасываются).

   ```c#
   double pi = 3.14;
   int wholePart = (int)pi; // Явное приведение
   ```

### Когда происходит автоматическое приведение типов?

1. **Меньший тип в больший:**
    - Например, `int` → `long`, `float` → `double`.
2. **При математических операциях с разными типами:**
    - Например, `int` + `double` → результат будет `double`.

### Разбор кода

Теперь давай разберём предоставленный код построчно.

```c#
// Приведение типов
WriteLine("\nПриведение типов:");
```
- **`// Приведение типов`**: Это комментарий, который объясняет, что данный блок кода демонстрирует примеры приведения типов.
- **`WriteLine("\nПриведение типов:");`**: Эта строка выводит текст "Приведение типов:" с переходом на новую строку перед ним (`\n`).

```c#
long bigValue = 1000L;
```
- **`long`**: Это тип данных для больших целых чисел.
- **`bigValue`**: Имя переменной.
- **`1000L`**: Значение 1000, буква `L` указывает, что это значение типа `long`.

```c#
int smallValue = (int)bigValue; // Явное приведение
```
- **`int smallValue`**: Создаём переменную `smallValue` типа `int`, которая хранит меньшие целые числа.
- **`(int)bigValue`**: Приводим значение из типа `long` в тип `int`. Здесь нужно явное приведение, так как `long` может хранить больше данных, чем `int`, и часть информации может потеряться (например, если значение больше, чем может вместить `int`).

```c#
WriteLine($"Явное приведение: long -> int: {smallValue}");
```
- **`WriteLine`**: Эта строка выводит текст "Явное приведение: long -> int: " и значение переменной `smallValue` (в данном случае `1000`).

```c#
int value = 100;
```
- **`int value`**: Создаём переменную `value` типа `int` и присваиваем ей значение `100`.

```c#
long largeValue = value; // Неявное приведение
```
- **`long largeValue`**: Создаём переменную `largeValue` типа `long`.
- **`value`**: Переменная `value` автоматически преобразуется из типа `int` в тип `long`, так как `long` больше `int`, и такое преобразование безопасно (не теряется информация).

```c#
WriteLine($"Неявное приведение: int -> long: {largeValue}");
```
- Эта строка выводит текст "Неявное приведение: int -> long: " и значение переменной `largeValue` (в данном случае `100`).

### Итоговый результат программы:
На экране будет напечатано:
```
Приведение типов:
Явное приведение: long -> int: 1000
Неявное приведение: int -> long: 100
```

### Дополнительный пример с потерей данных

```c#
double largeNumber = 123.456;
int smallNumber = (int)largeNumber; // Дробная часть потеряется
Console.WriteLine(smallNumber); // Выведет 123
```

Здесь дробная часть (`.456`) теряется, потому что тип `int` хранит только целые числа. Это пример, где при явном приведении 
происходит потеря данных.

Осталось рассмотреть последний блок операций проверки переполнения типа.

![Операции над целочисленными типами в C#](int_vars13.png){ border-effect="line"  thumbnail="true" width="700" }

### Что такое переполнение типа?

**Переполнение типа** происходит, когда значение выходит за пределы диапазона, который может хранить переменная данного 
типа. Например, тип `sbyte` может хранить числа от **-128** до **127**. Если попытаться присвоить значение, превышающее 
этот диапазон, происходит переполнение.

#### Пример переполнения:
```c#
sbyte a = 127; // Максимальное значение для sbyte
a = (sbyte)(a + 1); // Переполнение: значение становится -128
Console.WriteLine(a); // Вывод: -128
```

При переполнении:
1. **В режиме `unchecked` (по умолчанию):** значение "оборачивается", как если бы числа шли по кругу.
2. **В режиме `checked`:** выбрасывается исключение `OverflowException`, указывающее на ошибку.

### Что такое исключения и как происходит их обработка?

**Исключение** — это ошибка, которая возникает при выполнении программы. Например, попытка деления на ноль или переполнение типа может привести к исключению. В C# такие ситуации можно **обрабатывать**, чтобы программа не завершалась аварийно.

#### Обработка исключений:
- Для обработки используется блоки **`try`** и **`catch`**:
    - **`try`**: в этом блоке размещается код, где может возникнуть ошибка.
    - **`catch`**: в этом блоке описывается, что делать, если ошибка произошла.

#### Пример:
```c#
try
{
    int result = 10 / 0; // Деление на ноль вызовет исключение
}
catch (DivideByZeroException ex)
{
    Console.WriteLine($"Ошибка: {ex.Message}");
}
```

### Разбор кода построчно

```c#
// Операции проверки переполнения
WriteLine("\nПроверка переполнения:");
```
- **`//`**: Комментарий, поясняющий, что этот блок кода демонстрирует работу с переполнением типов.
- **`WriteLine`**: Печатает текст "Проверка переполнения:" с переходом на новую строку.

```c#
sbyte x = unchecked((sbyte)196); // 196 выходит за пределы диапазона sbyte
```
- **`sbyte`**: Тип данных для хранения целых чисел от -128 до 127.
- **`unchecked`**: Указывает, что переполнение разрешено, и никаких ошибок не будет.
- **`(sbyte)196`**: Преобразуем число 196 в тип `sbyte`. Это значение превышает максимальный диапазон, поэтому происходит **оборачивание**. Результат: 196 - 256 = -60.

```c#
WriteLine($"С разрешенным переполнением unchecked: x = {x}"); // Ожидается результат: -60
```
- Выводит текст "С разрешенным переполнением unchecked: x = -60".

```c#
WriteLine($"\nС запрещенным переполнением checked:");
```
- Выводит текст "С запрещенным переполнением checked:".

#### Первый блок try: {id="try_1"}

```c#
try
{
    int z = 196;
    WriteLine($"\nz = {z}");
    sbyte y = checked((sbyte)z);
    WriteLine($"Checked: y = {y}");
}
catch (OverflowException ex)
{
    WriteLine($"Checked: Переполнение типа: {ex.Message}");
}
```

1. **`try`**: Начало блока, в котором код проверяется на переполнение.
2. **`int z = 196;`**: Создаётся переменная `z` типа `int` со значением 196.
3. **`WriteLine($"\nz = {z}");`**: Печатает значение переменной `z`.
4. **`checked((sbyte)z)`**: Преобразует `z` в тип `sbyte` с проверкой на переполнение. Поскольку 196 выходит за диапазон `sbyte`, выбрасывается исключение `OverflowException`.
5. **`catch (OverflowException ex)`**: Перехватывает исключение и выводит сообщение об ошибке.

#### Второй блок `try`:

```c#
try
{
    int z = -128;
    WriteLine($"\nz = {z}");
    sbyte y = checked((sbyte)z);
    WriteLine($"Checked: y = {y}");
}
catch (OverflowException ex)
{
    WriteLine($"Checked: Переполнение типа: {ex.Message}");
}
```

1. **`int z = -128;`**: Присваиваем значение `-128`, которое находится в допустимом диапазоне `sbyte`.
2. **`checked((sbyte)z)`**: Преобразуем значение в `sbyte`. Здесь переполнения **не происходит**, так как значение в диапазоне.
3. **Результат: успешно преобразуется и выводится значение -128.**

### Итоговый результат выполнения кода:

1. Для `unchecked`:
   ```
   С разрешенным переполнением unchecked: x = -60
   ```

2. Для первого блока `try`:
   ```
   С запрещенным переполнением checked:
   z = 196
   Checked: Переполнение типа: Значение было недопустимо для sbyte.
   ```

3. Для второго блока `try`:
   ```
   z = -128
   Checked: y = -128
   ```

### Итог:
- **`unchecked`** используется, если переполнение допустимо и нужно оборачивание значений.
- **`checked`** используется для проверки ошибок переполнения, чтобы избежать неожиданного поведения.

## Зоны видимости переменных

**Зона видимости** переменной определяет, где в коде можно использовать эту переменную. В C# зоны видимости зависят от того, 
где и как объявлена переменная. Основные зоны видимости:

1. **Переменные уровня метода** (локальные переменные):
    - Объявляются внутри метода (например, внутри `Main`).
    - Доступны только внутри того блока `{ }`, где они объявлены.
    - Когда блок заканчивается, переменная уничтожается, и её имя можно использовать снова.

2. **Переменные уровня класса** (поля класса):
    - Объявляются в теле класса, но вне методов.
    - Доступны из всех методов данного класса (если позволяет модификатор доступа).

3. **Переменные уровня блока**:
    - Объявляются внутри любого блока кода `{ }`.
    - Их зона видимости ограничена этим блоком.

### Почему переменная `z` была объявлена два раза?

В коде есть два блока `try`, каждый из которых имеет свои `{ }`. Переменная `z` объявлена внутри каждого блока:

1. **В первом блоке `try`:**
   ```c#
   try
   {
       int z = 196; // Объявление переменной z
   }
   ```

2. **Во втором блоке `try`:**
   ```c#
   try
   {
       int z = -128; // Объявление переменной z
   }
   ```

Эти два блока независимы друг от друга, и у каждой переменной `z` своя **зона видимости**. Переменная из одного блока 
недоступна в другом. Именно поэтому оба раза можно использовать одно и то же имя переменной `z`, и это не вызывает конфликта.

### Пример для понимания зон видимости

Рассмотрим простой пример:

```c#
{
    int a = 10; // Переменная a доступна только внутри этих { }
    {
        int a = 20; // Ошибка! Переменная a уже существует в родительском блоке
    }
    int b = 30; // b существует только в этом блоке
}
{
    int a = 40; // Это разрешено, так как новый блок не знает о переменной a из предыдущего
}
```

Здесь:
- Вложенные блоки не могут объявить переменную с тем же именем, что и во внешнем блоке.
- После завершения блока его переменные уничтожаются, и их имена можно использовать снова.

### Заключение по коду

Переменная `z` объявлена дважды, потому что:
1. Первая `z` находится в зоне видимости первого блока `try`.
2. Вторая `z` находится в зоне видимости второго блока `try`.
3. Эти зоны видимости независимы, поэтому ошибки нет.

### Дополнительное объяснение с использованием примера:

Представьте, что вы работаете на двух разных рабочих столах. На каждом столе лежат отдельные ящики с названием "z".
Вы можете использовать ящик с этим названием на любом из столов, потому что они существуют в разных местах и не пересекаются. 
Так же работают зоны видимости в программировании: каждая переменная ограничена своим "столом" (блоком `{ }`).

## Арность операторов

**Арность** (или **операндность**) — это количество **операндов**, которые принимает оператор. 
В C# операторы классифицируются по числу операндов:

1. **Унарные операторы** (1 операнд)
2. **Бинарные операторы** (2 операнда)
3. **Тернарные операторы** (3 операнда)

### 1. **Унарные операторы** (1 операнд)

Унарные операторы работают только с одним операндом.  
Примеры в C#:
- **Смена знака:** `-`
- **Инкремент и декремент:** `++` и `--`
- **Логическое отрицание:** `!`
- **Побитовое отрицание:** `~`

**Пример:**
```c#
int a = 5;
int b = -a; // Унарный оператор смены знака
a++;        // Унарный оператор инкремента
bool isTrue = false;
bool isFalse = !isTrue; // Унарное логическое отрицание
```

**Объяснение:**
- `-a` меняет знак числа `a` на противоположный.
- `a++` увеличивает значение `a` на 1.
- `!isTrue` меняет значение `false` на `true`.

### 2. **Бинарные операторы** (2 операнда)

Бинарные операторы работают с двумя операндами.  
Примеры в C#:
- **Арифметические:** `+`, `-`, `*`, `/`, `%`
- **Сравнения:** `==`, `!=`, `<`, `>`, `<=`, `>=`
- **Логические:** `&&`, `||`
- **Побитовые:** `&`, `|`, `^`, `<<`, `>>`
- **Присваивание:** `=`, `+=`, `-=`, `*=`, `/=`

**Пример:**
```c#
int x = 10, y = 20;
int sum = x + y;        // Сложение (арифметический оператор)
bool isEqual = x == y;  // Сравнение (оператор равенства)
x += 5;                 // Присваивание с добавлением
```

**Объяснение:**
- `x + y` вычисляет сумму чисел.
- `x == y` проверяет, равны ли значения `x` и `y`.
- `x += 5` увеличивает значение `x` на 5.

### 3. **Тернарные операторы** (3 операнда)

В C# есть единственный тернарный оператор: **условный оператор** `?:`.  
Он используется для сокращённой записи условных выражений.  
Синтаксис:  
`condition ? value_if_true : value_if_false`

**Пример:**
```c#
int a = 10, b = 20;
int max = (a > b) ? a : b; // Если a > b, то max = a; иначе max = b
```

**Объяснение:**
- Проверяется условие `(a > b)`. Если оно истинно, результат `a`, иначе — `b`.
- В данном случае `max` будет равно `20`, так как `b > a`.

### Сводная таблица:

| **Тип оператора** | **Количество операндов** | **Примеры**               | **Описание**                         |
|--------------------|---------------------------|---------------------------|---------------------------------------|
| **Унарный**       | 1                         | `-a`, `++a`, `!a`         | Работает с одним операндом           |
| **Бинарный**      | 2                         | `a + b`, `a && b`         | Работает с двумя операндами          |
| **Тернарный**     | 3                         | `condition ? a : b`       | Работает с тремя операндами          |

### Итог:

**Арность** — это характеристика оператора, которая показывает, сколько операндов он принимает.  
Примеры:
1. Унарный: `-a`
2. Бинарный: `a + b`
3. Тернарный: `a > b ? a : b`

Тернарный оператор мы изучим когда будем проходить управление потоком исполнения программы.

## Вещественные переменные

Вещественные типы в C# используются для хранения чисел с плавающей точкой (дробных чисел). Они предназначены для работы 
с числовыми значениями, которые содержат дробную часть, и делятся на два типа: **float** и **double**, 
а также специальный тип **decimal**, предназначенный для финансовых вычислений с высокой точностью.

### Таблица вещественных типов

| Тип      | Размер (бит) | Минимальное значение                | Максимальное значение                  | Значение по умолчанию |
|----------|--------------|--------------------------------------|----------------------------------------|------------------------|
| `float`  | 32           | -3.40282347E+38                    | 3.40282347E+38                         | `0.0f`                |
| `double` | 64           | -1.7976931348623157E+308           | 1.7976931348623157E+308                | `0.0d`                |
| `decimal`| 128          | -79,228,162,514,264,337,593,543,950,335 | 79,228,162,514,264,337,593,543,950,335 | `0.0m`                |


И сразу же попрактикуемся. Создай консольное приложение `ex0019_real_vars` при помощи шаблона `tinyconsole` в папке 
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.
Приведите `Program.cs` к следующему виду:

```c#
class Program
{
    // Значения по умолчанию для вещественных типов
    private static float defaultFloat;
    private static double defaultDouble;
    private static decimal defaultDecimal;

    static void Main(string[] args)
    {
        // Минимальные и максимальные значения для вещественных типов
        float minFloat = float.MinValue;
        float maxFloat = float.MaxValue;

        double minDouble = double.MinValue;
        double maxDouble = double.MaxValue;

        decimal minDecimal = decimal.MinValue;
        decimal maxDecimal = decimal.MaxValue;

        // Вывод значений
        WriteLine("Тип: float");
        WriteLine($"Значение по умолчанию: {defaultFloat}");
        WriteLine($"Минимальное значение: {minFloat}");
        WriteLine($"Максимальное значение: {maxFloat}");
        WriteLine();

        WriteLine("Тип: double");
        WriteLine($"Значение по умолчанию: {defaultDouble}");
        WriteLine($"Минимальное значение: {minDouble}");
        WriteLine($"Максимальное значение: {maxDouble}");
        WriteLine();

        WriteLine("Тип: decimal");
        WriteLine($"Значение по умолчанию: {defaultDecimal}");
        WriteLine($"Минимальное значение: {minDecimal}");
        WriteLine($"Максимальное значение: {maxDecimal}");
    }
}
```

Эта программа демонстрирует использование всех вещественных типов, их минимальных и максимальных значений, 
а также их значения по умолчанию.

При запуске программы вывод будет примерно следующим:

```
Тип: float
Значение по умолчанию: 0
Минимальное значение: -3.4028235E+38
Максимальное значение: 3.4028235E+38

Тип: double
Значение по умолчанию: 0
Минимальное значение: -1.7976931348623157E+308
Максимальное значение: 1.7976931348623157E+308

Тип: decimal
Значение по умолчанию: 0
Минимальное значение: -79228162514264337593543950335
Максимальное значение: 79228162514264337593543950335
```

Если вы смотрели таблицу внимательно, то могли заметить что тип double может представить куда большие значения хотя использует
для хранения значения вдвое меньше памяти чем decimal.

**Почему `double` может хранить большее значение, чем `decimal`, при использовании меньшего объема памяти?** 

1. **Представление данных:**
    - **`double`**: Использует 64 бита для хранения чисел с плавающей запятой в формате IEEE 754. Из них:
        - 1 бит — знак,
        - 11 бит — экспонента,
        - 52 бита — мантисса.
          Благодаря экспоненте, `double` может представлять очень большие и очень маленькие числа (в научной нотации).
    - **`decimal`**: Использует 128 бит и предназначен для высокоточной арифметики. Из них:
        - 1 бит — знак,
        - 96 бит — мантисса (целая часть числа),
        - 32 бита — для масштабирования (сколько знаков после запятой хранить).
          `decimal` не оптимизирован для хранения очень больших диапазонов, так как фокусируется на точности.

2. **Точность и диапазон:**
    - `double` жертвует точностью ради широкого диапазона значений, так как большая часть битов выделена для экспоненты.
    - `decimal` фокусируется на точности, поэтому диапазон значений меньше.

### Почему `double` не обеспечивает точность? {id="double_1"}

`double` использует двоичное представление чисел, а многие дробные значения (например, 0.1) невозможно точно представить в двоичной системе. Это приводит к накоплению ошибок из-за округлений.

### Как `double` и `decimal` хранят число 0.1?

- **`double`:**  
  В двоичной системе 0.1 не имеет точного представления. Его значение будет приблизительно равно `0.10000000000000000555...`. Это накопление погрешности связано с ограниченной длиной мантиссы (52 бита).

- **`decimal`:**  
  Использует десятичную систему счисления для мантиссы, что позволяет хранить числа, такие как 0.1, с точностью до 28 знаков. Число 0.1 будет храниться как есть, без погрешности.

### Почему нельзя сравнивать `double` с помощью оператора `==`?

1. **Погрешность округления:**  
   Малые ошибки в представлении чисел с плавающей запятой могут привести к неожиданным результатам при сравнении.

2. **Реальный пример (Война в Персидском заливе):**  
   Программный комплекс Patriot использовал числа двойной точности для расчетов времени. Ошибка в точности накопилась за несколько часов, что привело к неправильному расчету траектории ракеты. Подробнее описано на [сайте IMA](https://www.ima.umn.edu/~arnold/disasters/patriot.html).

 А теперь давайте на практике посмотрим эту разницу. 

Создай консольное приложение `ex0020_double_decimal` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.
Приведите `Program.cs` к следующему виду:

### Код, демонстрирующий разницу между `double` и `decimal`

```c#
using System;

class Program
{
    static void Main()
    {
        WriteLine("Используем double:");
        double aDouble = 0.1;
        double bDouble = 0.2;

        WriteLine($"Обычное представление aDouble: {aDouble}");
        WriteLine($"Обычное представление bDouble: {bDouble}");

        // Вывод фактических значений с максимально точным представлением до 20 знаков после запятой
        WriteLine($"Точное представление aDouble (до 20 знаков): {aDouble:F20}");
        WriteLine($"Точное представление bDouble (до 20 знаков): {bDouble:F20}");

        if (aDouble + bDouble == 0.3)
        {
            WriteLine($"{aDouble} + {bDouble} равно {0.3}");
        }
        else
        {
            WriteLine($"{aDouble} + {bDouble} НЕ равно {0.3}");
            WriteLine($"Фактический результат: {aDouble + bDouble}");
        }

        WriteLine();

        WriteLine("Используем decimal:");
        decimal aDecimal = 0.1m;
        decimal bDecimal = 0.2m;

        if (aDecimal + bDecimal == 0.3m)
        {
            WriteLine($"{aDecimal} + {bDecimal} равно {0.3m}");
        }
        else
        {
            WriteLine($"{aDecimal} + {bDecimal} НЕ равно {0.3m}");
            WriteLine($"Фактический результат: {aDecimal + bDecimal}");
        }

        WriteLine();

        WriteLine("Сравнение double с использованием epsilon:");
        double epsilon = 1e-15; // Очень маленькое число определяющее допустимую погрешность
        if (Math.Abs(aDouble + bDouble - 0.3) < epsilon)
        {
            WriteLine($"{aDouble} + {bDouble} примерно равно {0.3} (с учетом epsilon)");
        }
        else
        {
            WriteLine($"{aDouble} + {bDouble} НЕ равно {0.3} даже с учетом epsilon");
        }
    }
}
```

Результат выполнения программы:

```
Используем double:
Обычное представление aDouble: 0,1
Обычное представление bDouble: 0,2
Точное представление aDouble (до 20 знаков): 0,10000000000000000555
Точное представление bDouble (до 20 знаков): 0,20000000000000001110
0,1 + 0,2 НЕ равно 0,3
Фактический результат: 0,30000000000000004

Используем decimal:
0,1 + 0,2 равно 0,3

Сравнение double с использованием epsilon:
0,1 + 0,2 примерно равно 0,3 (с учетом epsilon)
```

### Почему точное представление `aDouble` и `bDouble` отличается от обычного вывода {id="adouble-bdouble_1"}

В типе данных `double` числа представляются в виде **плавающей точки** (согласно стандарту IEEE 754). 
Это означает, что не все десятичные дроби могут быть точно представлены в двоичном формате, так как в двоичной системе 
дробные числа часто становятся бесконечными периодическими, аналогично тому, как $1/3$ в десятичной системе записывается 
как $0.333...$

#### Обычное представление (`aDouble` и `bDouble`):
Когда вы просто выводите `double` (например, с использованием `Console.WriteLine`), форматер округляет число до меньшего 
количества значащих цифр, чтобы результат выглядел удобным для чтения. Таким образом, `0.1` и `0.2` выглядят "правильно".

#### Точное представление (`F20`):
Используется формат "F20", чтобы вывести числа с точностью до 20 знаков после запятой, показывая их реальные значения в памяти:

- `0.1` в типе `double` фактически сохраняется как $0.10000000000000000555$.
- `0.2` сохраняется как $0.20000000000000001110$.

#### Причина разницы:
Разница возникает из-за **округления при отображении**. Числа `0.1` и `0.2` кажутся "точными" в обычном выводе, 
но их двоичное представление показывает, что это не так. Поэтому арифметические операции (например, `0.1 + 0.2`) 
дают результат, который немного отличается от ожидаемого.

### Что такое epsilon и зачем он нужен {id="epsilon_1"}

#### Определение epsilon {id="epsilon_2"}
`Epsilon` — это **погрешность**, которая используется для сравнения чисел с плавающей точкой. В программировании 
мы часто сталкиваемся с ситуацией, когда числа с плавающей точкой нельзя сравнить напрямую с использованием 
оператора `==`, из-за накопления ошибок округления. Например:

```c#
double a = 0.1;
double b = 0.2;
Console.WriteLine(a + b == 0.3); // False
```

Чтобы решить эту проблему, мы вводим epsilon — очень маленькое число, которое задает максимально допустимую разницу 
между числами, чтобы считать их "равными".

#### Пример использования:
Вместо прямого сравнения:

```c#
if (a + b == 0.3) { ... }
```

Используем:

```c#
double epsilon = 1e-15;
if (Math.Abs(a + b - 0.3) < epsilon) { ... }
```

Здесь:
- `Math.Abs(a + b - 0.3)` вычисляет разницу между ожидаемым результатом (`0.3`) приводя её к абсолютному значению.
- Если разница меньше `epsilon`, числа считаются равными.


### Зачем нужен epsilon
1. **Устранение ошибок округления:**
   При арифметических операциях с числами `double` или `float` небольшие ошибки округления неизбежны из-за ограничений двоичной арифметики. Epsilon помогает компенсировать такие ошибки.

2. **Улучшение надежности:**
   Сравнение чисел с использованием epsilon делает программы более устойчивыми к погрешностям округления, что особенно важно при работе с научными вычислениями или компьютерной графикой.

3. **Практичность:**
   Сравнение с использованием epsilon учитывает, что абсолютная точность при работе с числами с плавающей точкой невозможна, но можно задавать допустимые пределы отклонений.

### Итог по epsilon {id="epsilon_3"}

Различие в представлении `double` связано с особенностями хранения чисел в двоичном формате. 
Использование epsilon необходимо для корректного сравнения чисел с плавающей точкой, когда прямое 
сравнение через `==` не работает.

### Почему `decimal` точнее чем double и float и как он работает?

Чтобы понять, почему `decimal` точнее, представь, что он хранит числа не в привычной нам десятичной системе (1, 2, 3...), 
но с учетом специального "трюка". Этот трюк помогает компьютеру запоминать числа, как будто они написаны на бумаге, 
не теряя ни одной важной цифры.

### Как работает `decimal`? {id="decimal_1"}

1. **Представление числа**  
   Тип `decimal` хранит число как большое **целое число** (без дробной части) и помнит, куда нужно поставить десятичную точку.

   Например:
    - Если у тебя число `12.34`, оно запоминается как **1234** (без точки) и добавляется информация: "Поставь точку на 2 знака слева".
    - Если число `0.00123`, оно будет сохранено как **123** и сказано: "Сдвинь точку на 5 знаков влево".

2. **Почему это удобно?**  
   Компьютер не делает сложные пересчеты в двоичной системе, как это бывает с типами `float` и `double`. Он просто хранит все цифры точно так, как они выглядят.

### Почему `float` и `double` менее точные?

`float` и `double` хранят числа по-другому. Они используют двоичную систему (0 и 1), где числа вроде `0.1` и `0.2` не могут быть записаны точно. Это как если ты пытаешься поделить один пирог на три человека и ждешь точного ответа: никогда не выйдет **точно 0.333**.

### Пример: `0.1` в `float` и `decimal`

- Для `float` или `double`:  
  Число `0.1` превращается в двоичное представление и выходит что-то вроде **0.0001100110011...** (оно бесконечно повторяется). Из-за этого возникают небольшие ошибки, которые накапливаются.

- Для `decimal`:  
  Число `0.1` запоминается как **1** с информацией "Поставь точку на один знак слева". Всё точно, без потерь!

### Подведем итог по decimal:

Тип `decimal` точнее, потому что он "рисует" числа так, как они выглядят на бумаге, и запоминает их такими же, с учетом точного сдвига точки. А вот `float` и `double` превращают числа в длинные двоичные дроби, что похоже на то, как дробь `1/3` превращается в бесконечное число 0.333... — там всегда есть немного погрешности.

## Вещественные литералы

В C# вещественные литералы представляют числа с плавающей точкой и могут быть записаны в нескольких формах. 
Их основное назначение — представление дробных или очень больших/маленьких чисел.

#### Типы вещественных литералов:
1. **`float`**
    - Литералы с суффиксом `f` или `F` (например, `1.5f`).
    - Представляют числа одинарной точности (32-битные).
    - Диапазон значений: ~±1.5 × 10⁻⁴⁵ до ±3.4 × 10³⁸.
    - Пример: `3.14f`, `-0.1f`.

2. **`double`**
    - Литералы без суффикса по умолчанию имеют тип `double`.
    - Представляют числа двойной точности (64-битные).
    - Диапазон значений: ~±5.0 × 10⁻³²⁴ до ±1.7 × 10³⁰⁸.
    - Пример: `3.14`, `-0.1`, `1.5e10`.

3. **`decimal`**
    - Литералы с суффиксом `m` или `M` (например, `1.5m`).
    - Представляют числа с высокой точностью (128-битные).
    - Диапазон значений: ±1.0 × 10⁻²⁸ до ±7.9 × 10²⁸.
    - Пример: `3.14m`, `-0.1m`.

#### Особенности записи:
- **Десятичная форма:**  
  Числа записываются с использованием десятичной точки (например, `3.14`).

- **Экспоненциальная форма:**  
  Для представления чисел в научной нотации используется буква `e` или `E` (например, `1.23e4` для `12300`).

- **Знаки:**  
  Литералы могут быть положительными или отрицательными.

И снова практика, падаван!

Создай консольное приложение `ex0021_real_literals` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

```c#
class Program
{
    static void Main()
    {
        WriteLine("Демонстрация вещественных литералов:");

        // float литералы
        float floatLiteral1 = 3.14f;
        float floatLiteral2 = -0.1f;
        float floatLiteral3 = 1.5e2f; // Экспоненциальная форма

        WriteLine($"floatLiteral1: {floatLiteral1}");
        WriteLine($"floatLiteral2: {floatLiteral2}");
        WriteLine($"floatLiteral3: {floatLiteral3}");

        // double литералы (по умолчанию)
        double doubleLiteral1 = 3.14;
        double doubleLiteral2 = -0.1;
        double doubleLiteral3 = 1.5e10; // Экспоненциальная форма

        WriteLine($"\ndoubleLiteral1: {doubleLiteral1}");
        WriteLine($"doubleLiteral2: {doubleLiteral2}");
        WriteLine($"doubleLiteral3: {doubleLiteral3}");

        // decimal литералы
        decimal decimalLiteral1 = 3.14m;
        decimal decimalLiteral2 = -0.1m;
        decimal decimalLiteral3 = 1.5e2m; // Экспоненциальная форма запрещена

        WriteLine($"\ndecimalLiteral1: {decimalLiteral1}");
        WriteLine($"decimalLiteral2: {decimalLiteral2}");
        WriteLine($"decimalLiteral3: {decimalLiteral3}");

        // Сравнение float и double
        float floatComparison = 0.1f + 0.2f;
        double doubleComparison = 0.1 + 0.2;

        WriteLine($"\nСравнение float и double:");
        WriteLine($"float (0.1f + 0.2f): {floatComparison:F20}");
        WriteLine($"double (0.1 + 0.2): {doubleComparison:F20}");
    }
}
```

### Результат выполнения программы:

```
Демонстрация вещественных литералов:
floatLiteral1: 3,14
floatLiteral2: -0,1
floatLiteral3: 150

doubleLiteral1: 3,14
doubleLiteral2: -0,1
doubleLiteral3: 15000000000

decimalLiteral1: 3,14      
decimalLiteral2: -0,1      
decimalLiteral3: 150       

Сравнение float и double:
float (0.1f + 0.2f): 0,30000001192092895508
double (0.1 + 0.2): 0,30000000000000004441
```

### Пояснение:
1. **`float`**:
    - Литералы с суффиксом `f`. Используются для экономии памяти. Обратите внимание на потерю точности при вычислениях.

2. **`double`**:
    - Литералы без суффикса. Обладают большей точностью по сравнению с `float`.

3. **`decimal`**:
    - Литералы с суффиксом `m`. Используются в финансовых расчетах, где требуется высокая точность.

4. **Сравнение `float` и `double`**:
    - `float` и `double` представляют числа с плавающей точкой, но из-за разной точности они могут давать разные результаты при вычислениях.

5. **Ограничения `decimal`**:
    - `decimal` не поддерживает экспоненциальную форму. Нужно использовать обычную десятичную запись.

Эта программа демонстрирует, как использовать вещественные литералы и какие различия существуют между типами данных.

## Специальные значения для вещественных типов

Вещественные типы данных `float` и `double` в C# имеют специальные значения, которые полезны в различных математических 
и вычислительных задачах:

1. **`NaN` (Not-a-Number)**  
   Представляет результат, который не является числом, например, деление `0.0 / 0.0`.

2. **`Epsilon`**  
   Минимальное положительное число, которое может быть представлено в `float` или `double`.

3. **`PositiveInfinity` и `NegativeInfinity`**  
   Представляют бесконечно большие положительные и отрицательные значения, например, результат деления на ноль (`3.0 / 0.0` или `-3.0 / 0.0`).

4. **Методы проверки**  
   Методы `IsNaN` и `IsInfinity` позволяют проверять, является ли значение специальным.

Время практики, пдаван! 

Создай консольное приложение `ex0022_real_spec_val` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

```c#
using System.Globalization;

class SpecialRealNumberValuesDemo
{
    static void Main()
    {
        CultureInfo.DefaultThreadCurrentCulture = CultureInfo.InvariantCulture;

        const int col1 = 37; // Ширина первой колонки.
        const int col2 = 6;  // Ширина второй колонки.
        string line = new string('-', col1 + col2 + 6);

        WriteLine("Специальные значения для double:");
        WriteLine($"double.Epsilon: {double.Epsilon}");
        WriteLine($"double.Epsilon до 324 знаков после запятой: {double.Epsilon:N324}");
        WriteLine(line);
        WriteLine($"{"Выражение",-col1} | {"Значение",col2}");
        WriteLine(line);
        WriteLine($"{"double.NaN",-col1} | {double.NaN,col2}");
        WriteLine($"{"double.PositiveInfinity",-col1} | {double.PositiveInfinity,col2}");
        WriteLine($"{"double.NegativeInfinity",-col1} | {double.NegativeInfinity,col2}");
        WriteLine(line);
        WriteLine($"{" 0.0 / 0.0",-col1} | {0.0 / 0.0,col2}");
        WriteLine($"{" 3.0 / 0.0",-col1} | {3.0 / 0.0,col2}");
        WriteLine($"{"-3.0 / 0.0",-col1} | {-3.0 / 0.0,col2}");
        WriteLine(line);

        WriteLine("\nСпециальные значения для float:");
        WriteLine($"float.Epsilon: {float.Epsilon}");
        WriteLine($"float.Epsilon до 50 знаков после запятой: {float.Epsilon:N50}");
        WriteLine(line);
        WriteLine($"{"Выражение",-col1} | {"Значение",col2}");
        WriteLine(line);
        WriteLine($"{"float.NaN",-col1} | {float.NaN,col2}");
        WriteLine($"{"float.PositiveInfinity",-col1} | {float.PositiveInfinity,col2}");
        WriteLine($"{"float.NegativeInfinity",-col1} | {float.NegativeInfinity,col2}");
        WriteLine(line);
        WriteLine($"{" 0f / 0f",-col1} | {0f / 0f,col2}");
        WriteLine($"{" 3f / 0f",-col1} | {3f / 0f,col2}");
        WriteLine($"{"-3f / 0f",-col1} | {-3f / 0f,col2}");
        WriteLine(line);

        // Проверка на Infinity и NaN
        WriteLine("\nПроверки специальных значений:");
        WriteLine($"{"float.IsNaN(0f / 0f)",-col1} | {float.IsNaN(0f / 0f),col2}");
        WriteLine($"{"float.IsInfinity(3f / 0f)",-col1} | {float.IsInfinity(3f / 0f),col2}");
        WriteLine($"{"double.IsNaN(0.0 / 0.0)",-col1} | {double.IsNaN(0.0 / 0.0),col2}");
        WriteLine($"{"double.IsInfinity(3.0 / 0.0)",-col1} | {double.IsInfinity(3.0 / 0.0),col2}");
        WriteLine(line);
    }
}
```

Вывод у программы будет такой:

```
Специальные значения для double:
double.Epsilon: 5E-324
double.Epsilon до 324 знаков после запятой: 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005
-------------------------------------------------
Выражение                             | Значение
-------------------------------------------------
double.NaN                            |    NaN
double.PositiveInfinity               | Infinity
double.NegativeInfinity               | -Infinity
-------------------------------------------------
 0.0 / 0.0                            |    NaN
 3.0 / 0.0                            | Infinity
-3.0 / 0.0                            | -Infinity
-------------------------------------------------

Специальные значения для float:
float.Epsilon: 1E-45
float.Epsilon до 50 знаков после запятой: 0.00000000000000000000000000000000000000000000140130
-------------------------------------------------
Выражение                             | Значение
-------------------------------------------------
float.NaN                             |    NaN
float.PositiveInfinity                | Infinity
float.NegativeInfinity                | -Infinity
-------------------------------------------------
 0f / 0f                              |    NaN
 3f / 0f                              | Infinity
-3f / 0f                              | -Infinity
-------------------------------------------------

Проверки специальных значений:
float.IsNaN(0f / 0f)                  |   True
float.IsInfinity(3f / 0f)             |   True
double.IsNaN(0.0 / 0.0)               |   True
double.IsInfinity(3.0 / 0.0)          |   True
-------------------------------------------------
```

Вот пояснение к коду, разделённое на ключевые части:

### 1. **Установка культуры** {id="setcult"}
```c#
CultureInfo.DefaultThreadCurrentCulture = CultureInfo.InvariantCulture;
```
Устанавливается культура `InvariantCulture`. Это гарантирует, что вывод чисел будет в одном и том же формате независимо от системных настроек локали (например, десятичный разделитель будет `.` вместо `,`). Это особенно важно для точности вывода значений, таких как `Epsilon` или `NaN`.

### 2. **Оформление таблицы** {id="settable"}
```c#
const int col1 = 37; // Ширина первой колонки.
const int col2 = 6;  // Ширина второй колонки.
string line = new string('-', col1 + col2 + 6);
```
Определяются размеры колонок для форматированного вывода. Это делает таблицу удобочитаемой. `line` используется для 
рисования горизонтальных разделителей между строками.

### 3. **Вывод специальных значений для `double`**
```c#
WriteLine($"double.Epsilon: {double.Epsilon}");
WriteLine($"double.Epsilon до 324 знаков после запятой: {double.Epsilon:N324}");
```
- `double.Epsilon` — минимальное положительное значение, которое может быть добавлено к `1.0` и даст отличное от `1.0` значение. Используется для представления разницы между соседними числами в формате `double`.
- `N324` указывает, что число будет выведено с 324 знаками после запятой. Это демонстрирует предельную точность представления значения.

### 4. **Выражения для специальных значений** {id="specexp"}

```c#
WriteLine($"{" 3.0 / 0.0",-col1} | {3.0 / 0.0,col2}");
WriteLine($"{" 0.0 / 0.0",-col1} | {0.0 / 0.0,col2}");
```
- **`3.0 / 0.0`** — это деление числа на 0, результатом будет `PositiveInfinity`.
- **`0.0 / 0.0`** — неопределённая операция, результатом будет `NaN` (Not-a-Number).

Аналогичные вычисления сделаны для `float` (например, `3f / 0f`), чтобы показать, что обе системы (32-битная и 64-битная точность) 
поддерживают эти значения.

### 5. **Проверки специальных значений** {id="5_2"}
#### Проверка `NaN`:
```c#
float.IsNaN(0f / 0f)
```
Метод `IsNaN` проверяет, является ли число `NaN`. Например:
- `0f / 0f` — это неопределённая операция, поэтому `float.IsNaN(0f / 0f)` вернёт `true`.

#### Проверка бесконечности:
```c#
float.IsInfinity(3f / 0f)
```
Метод `IsInfinity` проверяет, является ли число бесконечностью (положительной или отрицательной). Например:
- `3f / 0f` — это положительная бесконечность, поэтому метод вернёт `true`.

#### Пример проверки для `double`: {id="double_2"}
```c#
double.IsInfinity(3.0 / 0.0)
```
Аналогично `float`, но работает с `double`.

### **Итог** {id="7_1"}
Этот код наглядно показывает:
- Что такое специальные значения (`NaN`, бесконечность, `Epsilon`) для типов `double` и `float`.
- Как они вычисляются в результатах операций.
- Как их можно проверить с помощью методов `IsNaN` и `IsInfinity`.

## Операции над вещественными типами

В C# вещественные типы данных включают `float`, `double` и `decimal`. Они представляют числа с плавающей запятой и 
используются для хранения дробных значений. Операции, доступные для этих типов, включают стандартные арифметические операции, 
а также операции, специфичные для работы с числами с плавающей запятой.

#### Вещественные типы:
- **`float`** — 32-битное число с плавающей запятой, точность примерно 7 значащих цифр.
- **`double`** — 64-битное число с плавающей запятой, точность примерно 15-16 значащих цифр.
- **`decimal`** — 128-битное число с плавающей запятой, точность примерно 28-29 значащих цифр. Этот тип используется для точных вычислений с денежными суммами.

### Операции над вещественными типами

1. **Арифметические операции**:
    - **Сложение** (`+`)
    - **Вычитание** (`-`)
    - **Умножение** (`*`)
    - **Деление** (`/`)
    - **Остаток от деления** (`%`) — применимо только для `float` и `double`. Для типа `decimal` остаток от деления не поддерживается.

2. **Сравнение**:
    - **Равенство** (`==`)
    - **Неравенство** (`!=`)
    - **Меньше, чем** (`<`)
    - **Больше, чем** (`>`)
    - **Меньше или равно** (`<=`)
    - **Больше или равно** (`>=`)

3. **Дополнительные математические операции**:
    - **Инкремент** (`++`) — не поддерживается для вещественных типов, это операция, специфичная для целочисленных типов.
    - **Декремент** (`--`) — аналогично, не поддерживается для вещественных типов.
    - **Возведение в степень** — с помощью `Math.Pow()`:
      ```c#
      double result = Math.Pow(2.0, 3.0);  // 2^3 = 8.0
      ```

4. **Математические функции**:
    - **Абсолютное значение** — с помощью `Math.Abs()`
    - **Квадратный корень** — с помощью `Math.Sqrt()`
    - **Округление** — с помощью `Math.Round()`
    - **Округление вверх** — с помощью `Math.Ceiling()`
    - **Округление вниз** — с помощью `Math.Floor()`

5. **Конвертация типов**:
    - Преобразование между типами: например, из `float` в `double` или наоборот, или из `decimal` в `double` и наоборот. Для этого можно использовать явное или неявное преобразование типов.

#### Операции, которые не применимы к вещественным типам:
- **Инкремент и декремент** (`++` и `--`) — эти операции применимы только к целочисленным типам, но не к типам с плавающей запятой.
- **Побитовые операции** — такие как AND (`&`), OR (`|`), XOR (`^`), сдвиг влево (`<<`) и вправо (`>>`) не поддерживаются для вещественных типов. Побитовые операции могут быть применимы только к целочисленным типам.

Попрактикуемся. 

Создай консольное приложение `ex0023_real_operations` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

```c#
using System;

class Program
{
    static void Main()
    {
        // Создание переменных для вещественных типов
        float floatVal1 = 5.5f;
        float floatVal2 = 2.5f;
        
        double doubleVal1 = 3.14;
        double doubleVal2 = 1.57;
        
        decimal decimalVal1 = 10.1234m;
        decimal decimalVal2 = 5.5m;

        // Арифметические операции с выводом на экран
        WriteLine($"float: {floatVal1} + {floatVal2} = {floatVal1 + floatVal2}");
        WriteLine($"float: {floatVal1} - {floatVal2} = {floatVal1 - floatVal2}");
        WriteLine($"float: {floatVal1} * {floatVal2} = {floatVal1 * floatVal2}");
        WriteLine($"float: {floatVal1} / {floatVal2} = {floatVal1 / floatVal2}");
        WriteLine($"float: {floatVal1} % {floatVal2} = {floatVal1 % floatVal2}");
        
        WriteLine($"double: {doubleVal1} + {doubleVal2} = {doubleVal1 + doubleVal2}");
        WriteLine($"double: {doubleVal1} - {doubleVal2} = {doubleVal1 - doubleVal2}");
        WriteLine($"double: {doubleVal1} * {doubleVal2} = {doubleVal1 * doubleVal2}");
        WriteLine($"double: {doubleVal1} / {doubleVal2} = {doubleVal1 / doubleVal2}");
        
        WriteLine($"decimal: {decimalVal1} + {decimalVal2} = {decimalVal1 + decimalVal2}");
        WriteLine($"decimal: {decimalVal1} - {decimalVal2} = {decimalVal1 - decimalVal2}");
        WriteLine($"decimal: {decimalVal1} * {decimalVal2} = {decimalVal1 * decimalVal2}");
        // Для decimal остаток от деления не поддерживается
        // WriteLine($"decimal: {decimalVal1} % {decimalVal2} = {decimalVal1 % decimalVal2}");

        // Математические операции
        double squareRoot = Math.Sqrt(doubleVal1);
        double power = Math.Pow(2.0, 3.0);
        decimal absoluteValue = Math.Abs(decimalVal1);

        WriteLine($"Квадратный корень из {doubleVal1}: {squareRoot}");
        WriteLine($"Возведение 2 в степень 3: {power}");
        WriteLine($"Абсолютное значение {decimalVal1}: {absoluteValue}");

        // Округления
        double roundedValue = Math.Round(3.14159);
        double ceilValue = Math.Ceiling(3.14);
        double floorValue = Math.Floor(3.14);

        WriteLine($"Округление (Round): {roundedValue}");
        WriteLine($"Округление вверх (Ceiling): {ceilValue}");
        WriteLine($"Округление вниз (Floor): {floorValue}");

        // Преобразования типов
        double doubleFromFloat = (double)floatVal1;
        decimal decimalFromDouble = (decimal)doubleVal1;

        WriteLine($"Преобразование float в double: {doubleFromFloat}");
        WriteLine($"Преобразование double в decimal: {decimalFromDouble}");
    }
}
```

Вывод у программы такой:

```
float: 5,5 + 2,5 = 8
float: 5,5 - 2,5 = 3
float: 5,5 * 2,5 = 13,75
float: 5,5 / 2,5 = 2,2
float: 5,5 % 2,5 = 0,5
double: 3,14 + 1,57 = 4,71
double: 3,14 - 1,57 = 1,57
double: 3,14 * 1,57 = 4,9298
double: 3,14 / 1,57 = 2
decimal: 10,1234 + 5,5 = 15,6234
decimal: 10,1234 - 5,5 = 4,6234
decimal: 10,1234 * 5,5 = 55,67870
Квадратный корень из 3,14: 1,772004514666935
Возведение 2 в степень 3: 8
Абсолютное значение 10,1234: 10,1234
Округление (Round): 3
Округление вверх (Ceiling): 4
Округление вниз (Floor): 3
Преобразование float в double: 5,5
Преобразование double в decimal: 3,14
```

### Пояснения по коду:

1. **Арифметические операции**:
    - Для каждого типа (`float`, `double`, `decimal`) выполняются основные операции: сложение, вычитание, умножение, деление и остаток от деления (где это применимо).
    - Результаты выводятся на экран с пояснением, что именно происходит в каждой операции.

2. **Остаток от деления**:
    - Операция остатка от деления (`%`) поддерживается только для типов `float` и `double`. Для `decimal` эта операция не поддерживается в языке C# (поэтому я закомментировал её для `decimal`).

3. **Математические функции**:
    - Пример использования `Math.Sqrt()` для вычисления квадратного корня, `Math.Pow()` для возведения в степень и `Math.Abs()` для вычисления абсолютного значения.

4. **Округление**:
    - Применяются стандартные методы округления: `Math.Round()`, `Math.Ceiling()` и `Math.Floor()`.

5. **Конвертация типов**:
    - Примеры преобразования из одного типа в другой: `float` в `double`, `double` в `decimal`.

### Заключение

- Вещественные типы данных в C# поддерживают все основные арифметические операции, а также методы для работы с математическими функциями и округлениями.
- Однако, операции, такие как инкремент/декремент или побитовые операции, не применимы к этим типам данных.

## Дополнительные типы данных для целых и вещественных чисел

В .NET 5 и .NET 7 были добавлены новые типы данных, которые расширяют возможности работы с числами и позволяют 
эффективнее использовать память.

Вот эти типы:

1. **`Half` (полупрецизионное число)** — был введен в .NET 5.
    - Это тип данных с плавающей точкой, который использует 2 байта памяти.
    - Диапазон значений: от `Half.MinValue` до `Half.MaxValue`.

2. **`Int128` и `UInt128`** — были введены в .NET 7.
    - **`Int128`** — 128-битный целочисленный тип данных со знаком, который использует 16 байт памяти.
    - **`UInt128`** — 128-битный целочисленный тип данных без знака, который также использует 16 байт памяти.
    - Диапазоны значений:
        - `Int128.MinValue` до `Int128.MaxValue` для целых чисел со знаком.
        - `UInt128.MinValue` до `UInt128.MaxValue` для беззнаковых целых чисел.


Для того чтобы узнать размер этих типов в памяти, можно использовать небезопасный код с оператором `sizeof`. 
Для этого необходимо включить поддержку небезопасного кода в проекте.

Создай консольное приложение `ex0024_additional_types` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

```c#
using System;

class Program
{
    unsafe static void Main()
    {
        // Создание переменных новых типов данных
        Half halfNumber = (Half)1.23f; // Тип Half, явное приведение

        // Для Int128 и UInt128 используем разделение на старшую и младшую часть
        ulong lowerInt128 = 12345678901234567890UL; // Младшая часть
        ulong upperInt128 = 12345678901234567890UL; // Старшая часть
        Int128 int128Number = new Int128(lowerInt128, upperInt128); // Тип Int128, создаем из двух частей

        ulong lowerUInt128 = 12345678901234567890UL; // Младшая часть
        ulong upperUInt128 = 12345678901234567890UL; // Старшая часть
        UInt128 uint128Number = new UInt128(lowerUInt128, upperUInt128); // Тип UInt128, создаем из двух частей

        // Вывод значений переменных
        WriteLine($"Значение типа Half: {halfNumber}");
        WriteLine($"Значение типа Int128: {int128Number}");
        WriteLine($"Значение типа UInt128: {uint128Number}");

        // Размеры типов данных в памяти
        WriteLine($"Размер типа Half: {sizeof(Half)} байт");
        WriteLine($"Размер типа Int128: {sizeof(Int128)} байт");
        WriteLine($"Размер типа UInt128: {sizeof(UInt128)} байт");

        // Диапазоны значений
        WriteLine($"Диапазон значений Half: {Half.MinValue} до {Half.MaxValue}");
        WriteLine($"Диапазон значений Int128: {Int128.MinValue} до {Int128.MaxValue}");
        WriteLine($"Диапазон значений UInt128: {UInt128.MinValue} до {UInt128.MaxValue}");
    }
}
```

Файл проекта `ex0024_additional_types.csproj` надо привести к следующему виду:

```XML
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>disable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
  </PropertyGroup>

  <ItemGroup>
    <Using Include="System.Console" Static="true" />
  </ItemGroup>

</Project>
```

Вывод программы:

```
Значение типа Half: 1,23
Значение типа Int128: -112544787813668649428467220519122433326
Значение типа UInt128: 227737579107269814034907386912645778130
Размер типа Half: 2 байт
Размер типа Int128: 16 байт
Размер типа UInt128: 16 байт
Диапазон значений Half: -65500 до 65500
Диапазон значений Int128: -170141183460469231731687303715884105728 до 170141183460469231731687303715884105727
Диапазон значений UInt128: 0 до 340282366920938463463374607431768211455
```

### Объяснение кода

1. **Подключение пространства имен:**
   ```c#
   using System;
   ```
   Пространство имен `System` включает стандартные библиотеки C# для работы с вводом/выводом, базовыми типами данных и другими функциями.

2. **Метод `Main` с ключевым словом `unsafe`:**
   ```c#
   unsafe static void Main()
   ```
   Ключевое слово `unsafe` используется для разрешения работы с небезопасным кодом, что необходимо для использования оператора `sizeof` с нестандартными типами, такими как `Half`, `Int128` и `UInt128`. Для встроенных типов (`int`, `byte`, `double`, и т.д.) оператор `sizeof` может быть использован без `unsafe`.

   **Примечание:** Чтобы программа компилировалась, нужно включить поддержку `unsafe` в проекте. Для этого добавьте в файл `.csproj` следующую строку:
   ```xml
   <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
   ```

3. **Создание переменной типа `Half`:**
   ```c#
   Half halfNumber = (Half)1.23f; // Тип Half, явное приведение
   ```
   Здесь создается переменная типа `Half`, и значение `1.23f` явно приводится из `float` в `Half`. `Half` — это 16-битное число с плавающей запятой, введённое в .NET 5. Оно используется для экономии памяти по сравнению с `float` (32 бита).

4. **Создание переменных для типов `Int128` и `UInt128`:**
   ```c#
   ulong lowerInt128 = 12345678901234567890UL; // Младшая часть
   ulong upperInt128 = 12345678901234567890UL; // Старшая часть
   Int128 int128Number = new Int128(lowerInt128, upperInt128); // Тип Int128, создаем из двух частей
   ```
   Типы `Int128` и `UInt128` представляют 128-битные числа. Они создаются с использованием двух 64-битных значений (`ulong`): одна часть хранит младшие 64 бита, другая — старшие. Эти типы не являются встроенными в C#, но их можно определить в пользовательских библиотеках.

5. **Вывод значений переменных:**
   ```c#
   Console.WriteLine($"Значение типа Half: {halfNumber}");
   Console.WriteLine($"Значение типа Int128: {int128Number}");
   Console.WriteLine($"Значение типа UInt128: {uint128Number}");
   ```
   Метод `Console.WriteLine` используется для вывода значений переменных. Значения интерполируются в строки через фигурные скобки `{}`.

6. **Размеры типов данных:**
   ```c#
   Console.WriteLine($"Размер типа Half: {sizeof(Half)} байт");
   Console.WriteLine($"Размер типа Int128: {sizeof(Int128)} байт");
   Console.WriteLine($"Размер типа UInt128: {sizeof(UInt128)} байт");
   ```
   Оператор `sizeof` используется для определения размера типов данных в памяти:
    - Для `Half` — 2 байта (16 бит).
    - Для `Int128` и `UInt128` — 16 байт (128 бит), если считать две 64-битные части.

   **Важно:** Для нестандартных типов, таких как `Half`, `Int128`, и `UInt128`, оператор `sizeof` требует использования `unsafe`. Для встроенных типов (`int`, `byte`, `float` и других) это ограничение не применяется.

7. **Диапазоны значений:**
   ```c#
   Console.WriteLine($"Диапазон значений Half: {Half.MinValue} до {Half.MaxValue}");
   Console.WriteLine($"Диапазон значений Int128: {Int128.MinValue} до {Int128.MaxValue}");
   Console.WriteLine($"Диапазон значений UInt128: {UInt128.MinValue} до {UInt128.MaxValue}");
   ```
   Здесь выводятся минимальные и максимальные значения типов данных. Эти значения определяются в типах `Half`, `Int128`, и `UInt128` как статические свойства (`MinValue` и `MaxValue`).

### Важные моменты:
1. **`sizeof` и `unsafe`:**
    - Оператор `sizeof` может быть использован без `unsafe` для стандартных встроенных типов (`int`, `byte`, `float`, и т.д.).
    - Для нестандартных типов (`Half`, `Int128`, `UInt128`) требуется `unsafe`.

2. **Настройка проекта для `unsafe`:**
   Чтобы использовать небезопасный код, в `.csproj` нужно добавить директиву:
   ```xml
   <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
   ```

## Unsafe Code {id="unsafe-code_1"}

Падаван, в предыдущем примере мы коснулись тёмной стороны силы .NET и языка C#. Все объяснения ниже, скорее всего, тебе
будут не очень понятны. Просто прочитай их дабы было представление об этом. С этим могут работать только настоящие джедаи.
Если ты дойдешь до конца, то сможешь обуздать и темную силу.

**`unsafe code` (небезопасный код)** в C# — это специальный режим работы программы, позволяющий выполнять операции, которые не проверяются средой выполнения .NET (CLR) на безопасность, например, прямую работу с указателями.

### **Особенности `unsafe code`** {id="unsafe-code_2"}
1. **Прямая работа с памятью**:
    - В небезопасном коде можно использовать указатели (`pointers`) для работы с памятью.
    - Это позволяет вручную управлять объектами в памяти, обходя встроенные механизмы управления памятью, такие как сборщик мусора (Garbage Collector).

2. **Использование низкоуровневых операций**:
    - Например, получение размера типа данных с помощью оператора `sizeof`, что невозможно в обычном безопасном коде (кроме примитивных типов).

3. **Повышенный риск ошибок**:
    - Ошибки в небезопасном коде, например, неверное обращение к памяти, могут привести к сбоям программы или нарушению безопасности.

4. **Требования к проекту**:
    - Включить параметр `<AllowUnsafeBlocks>` в конфигурации проекта (например, в файле `.csproj`).
    - Пометить код, где используется `unsafe`, с помощью ключевого слова `unsafe`.

### **Когда использовать `unsafe code`?** {id="unsafe-code_3"}
- Для выполнения задач, которые требуют высокой производительности или доступа к низкоуровневым функциям (например, взаимодействие с оборудованием или оптимизация критически важных операций).
- В редких случаях, когда требуется интеграция с нативным кодом (например, через P/Invoke).

Давай попрактикуемся с тёмной силой.

Создай консольное приложение `ex0025_unsafe_code` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведите файл Program.cs к следующему виду:

```c#
class Program
{
    unsafe static void Main()
    {
        int number = 42;

        // Получение указателя на переменную
        int* pointer = &number;

        WriteLine($"Значение переменной: {number}");
        WriteLine($"Адрес в памяти: {(long)pointer}");
        WriteLine($"Значение через указатель: {*pointer}");

        // Изменение значения через указатель
        *pointer = 100;
        WriteLine($"Новое значение переменной: {number}");
    }
}
```

В файл проекта добавьте директиву `<AllowUnsafeBlocks>True</AllowUnsafeBlocks>`, как мы это делали в предыдущем упражнении.

**Вывод программы:**
```
Значение переменной: 42  
Адрес в памяти: 140732799925944  
Значение через указатель: 42  
Новое значение переменной: 100
```

### **Особенности реализации `unsafe code`** {id="unsafe-code_4"}
1. **Ключевое слово `unsafe`**:
    - Оно используется для обозначения методов, типов или блоков кода, где применяется небезопасный код.

2. **Требование компиляции**:
    - Компилятор C# должен быть настроен на поддержку небезопасного кода:
        - В Visual Studio: Включить параметр `Allow unsafe code` в настройках проекта.
        - В файле `.csproj`: добавить `<AllowUnsafeBlocks>True</AllowUnsafeBlocks>`.

3. **Ограничения**:
    - `unsafe` не отменяет всех проверок; он позволяет выполнять низкоуровневые операции, но не освобождает от ответственности за корректность работы.

### **Преимущества и недостатки**
| **Преимущества**                         | **Недостатки**                              |
|------------------------------------------|---------------------------------------------|
| Прямая работа с памятью и указателями.    | Сложность в отладке и высок риск ошибок.    |
| Высокая производительность в критичных задачах. | Нарушение безопасности программы.          |
| Возможность интеграции с нативным кодом. | Усложнение сопровождения кода.             |

### **Заключение**
`unsafe code` — это мощный инструмент для выполнения низкоуровневых задач, который следует использовать с осторожностью. 
В большинстве случаев достаточно возможностей стандартного безопасного C#, но для задач с повышенными требованиями 
к производительности или взаимодействию с аппаратным обеспечением `unsafe` становится незаменимым.

## Переменные булевого типа
Булев тип в C# представлен ключевым словом `bool`. Это встроенный тип данных, который может принимать одно из двух значений:
- `true` (истина)
- `false` (ложь)

Булев тип широко используется для работы с условиями, циклами и логическими операциями.

### Размер булевого типа
Размер типа `bool` в C# составляет **1 байт (8 бит)**. Хотя для представления значений `true` и `false` достаточно 1 бита, 
минимальный размер переменной в памяти обычно равен 1 байту.

Ну и конечно же практика, падван!

Создай консольное приложение `ex0026_bool_var` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи `Program.cs` к следующему виду:

```c#
class Program
{
    static void Main()
    {
        // Объявление переменных типа bool
        bool isTrue = true;  // Переменная со значением true
        bool isFalse = false; // Переменная со значением false

        // Логические операции
        bool andResult = isTrue && isFalse; // Логическое И
        bool orResult = isTrue || isFalse;  // Логическое ИЛИ
        bool notResult = !isTrue;           // Логическое НЕ

        // Вывод значений
        WriteLine($"isTrue: {isTrue}");
        WriteLine($"isFalse: {isFalse}");
        WriteLine($"isTrue AND isFalse: {andResult}");
        WriteLine($"isTrue OR isFalse: {orResult}");
        WriteLine($"NOT isTrue: {notResult}");

        // Использование в условии
        if (isTrue)
        {
            WriteLine("isTrue равно true.");
        }

        if (!isFalse)
        {
            WriteLine("isFalse равно false.");
        }
    }
}
```

Вывод программы следующий:

```
isTrue: True
isFalse: False
isTrue AND isFalse: False
isTrue OR isFalse: True  
NOT isTrue: False        
isTrue равно true.       
isFalse равно false.
```

### Объяснение программы
1. **Объявление переменных**:
    - Создаются переменные `isTrue` и `isFalse` со значениями `true` и `false` соответственно.

2. **Логические операции**:
    - `&&` (логическое И): Результат `true`, только если оба операнда равны `true`.
    - `||` (логическое ИЛИ): Результат `true`, если хотя бы один из операндов равен `true`.
    - `!` (логическое НЕ): Инвертирует значение (`true` становится `false` и наоборот).

3. **Условные конструкции**:
    - Булевы значения используются в условных операторах `if`, чтобы выполнять код только при выполнении определённых условий.

4. **Вывод результатов**:
    - Программа выводит на экран результаты операций и проверок.
 
Булев тип в C# является основой для работы с логикой программы и управления её потоком.

## Булевы литералы
Булевы литералы в C# представляют собой фиксированные значения двух состояний: **`true`** (истина) и **`false`** (ложь). 
Эти литералы являются встроенными в язык и используются для задания значений переменных типа `bool`.

Переписываю описание операций над булевым типом в стиле, который тебе больше подходит:

---

## Операции над булевым типом

Тип `bool` представляет логические значения `true` и `false`. Основные операции, которые можно выполнять с этим типом, 
делятся на три группы.

#### 1. Логические операции {id="1_4"}

Логические операции выполняются над значениями типа `bool` и возвращают результат типа `bool`.

- **Логическое НЕ (`!`)**  
  Инвертирует значение: `true` становится `false`, и наоборот.  
  **Пример**: `!true` → `false`.

- **Логическое И (`&&`)**  
  Возвращает `true`, если оба операнда равны `true`.  
  **Пример**: `true && false` → `false`.

- **Логическое ИЛИ (`||`)**  
  Возвращает `true`, если хотя бы один из операндов равен `true`.  
  **Пример**: `true || false` → `true`.

- **Исключающее ИЛИ (`^`)**  
  Возвращает `true`, если значения операндов различны.  
  **Пример**: `true ^ false` → `true`.

#### 2. Операции сравнения {id="2_4"}

Эти операции позволяют сравнить два значения типа `bool` и возвращают результат типа `bool`.

- **Равенство (`==`)**  
  Возвращает `true`, если оба значения равны.  
  **Пример**: `true == false` → `false`.

- **Неравенство (`!=`)**  
  Возвращает `true`, если значения различны.  
  **Пример**: `true != false` → `true`.

#### 3. Операции присваивания {id="3_4"}

- **Присваивание (`=`)**  
  Используется для задания значения переменной.  
  **Пример**: `bool a = true`.

Время практики, падаван!

Создай консольное приложение `ex0027_bool_operations` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи `Program.cs` к следующему виду:

```c#
class Program
{
    static void Main()
    {
        // Исходные значения
        bool a = true;
        bool b = false;

        // Логические операции
        WriteLine("Логические операции:");
        WriteLine($"!a = {!a}");                      // Логическое НЕ
        WriteLine($"a && b = {a && b}");              // Логическое И
        WriteLine($"a || b = {a || b}");              // Логическое ИЛИ
        WriteLine($"a ^ b = {a ^ b}");                // Исключающее ИЛИ

        // Операции сравнения
        WriteLine("\nОперации сравнения:");
        WriteLine($"a == b = {a == b}");              // Проверка на равенство
        WriteLine($"a != b = {a != b}");              // Проверка на неравенство

        // Присваивание
        WriteLine("\nОперации присваивания:");
        bool c = a;                                           // Присваивание
        WriteLine($"c = {c}");

        // Комбинация операций
        WriteLine("\nКомбинированные выражения:");
        bool result = (a || b) && !b;                        // Смешанные операции
        WriteLine($"(a || b) && !b = {result}");
    }
}
```

Вывод программы:

```
Логические операции:
!a = False    
a && b = False
a || b = True 
a ^ b = True

Операции сравнения:       
a == b = False
a != b = True

Операции присваивания:    
c = True

Комбинированные выражения:
(a || b) && !b = True
```

### Примечания:
1. Операторы `&&` и `||` используют **короткое замыкание**:
    - В выражении `a && b`, если `a == false`, то `b` не будет вычисляться.
    - В выражении `a || b`, если `a == true`, то `b` также не будет вычисляться.

2. Булевые операции часто используются в условных конструкциях, таких как `if`, `while`, и `for`.

Условные операторы и операторы циклов мы будем изучать чуть позже.

## Символьные переменные

В C# переменные символьного типа имеют тип `char` и предназначены для хранения одного Unicode символа. Тип `char` используется, 
когда требуется оперировать одиночными символами, такими как буквы, цифры, знаки препинания или любыми другими символами, 
поддерживаемыми стандартом Unicode.

### Основные свойства типа `char` {id="char_1"}

1. **Размер**:  
   Переменная типа `char` занимает **16 бит (2 байта)** в памяти.  
   Это позволяет хранить значения в диапазоне от `'\u0000'` (минимальное значение) до `'\uFFFF'` (максимальное значение), что соответствует всем возможным значениям Unicode.

2. **Представление**:  
   Символ в `char` хранится как числовой код Unicode. Например:
    - `'A'` соответствует Unicode-коду `65`.
    - `'😊'` соответствует Unicode-коду `128522`.

3. **Значение по умолчанию**:  
   Значение по умолчанию для `char` — это `'\0'` (нулевой символ).

4. **Литералы**:  
   Символьные значения записываются в одиночных кавычках, например:  
   `'A'`, `'1'`, `'\n'`.

5. **Применение**:  
   Символы используются для:
    - обработки текста,
    - анализа строк,
    - работы с данными в бинарном формате,
    - вывода определённых символов на экран.

### Таблица значений и свойств типа `char`: {id="char_2"}

| **Свойство**                | **Описание**                               |
|-----------------------------|-------------------------------------------|
| **Размер в памяти**         | 16 бит (2 байта)                          |
| **Минимальное значение**    | `'\u0000'` (нулевой символ)               |
| **Максимальное значение**   | `'\uFFFF'` (последний символ Unicode)     |
| **Значение по умолчанию**   | `'\0'` (нулевой символ)                   |
| **Пример значений**         | `'A'`, `'😊'`, `'1'`, `'#'`, `'\n'`       |
| **Представление в памяти**  | Числовой код Unicode                      |

Попрактикуемся.

Создай консольное приложение `ex0028_cahr_vars` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи `Program.cs` к следующему виду:

```c#
class Program
{
    static char defaultChar; // Значение по умолчанию для char

    static void Main()
    {
        // Создание переменных типа char
        char letter = 'A';         // Символ 'A'
        char digit = '1';          // Символ '1'
        char symbol = '#';         // Символ '#'
        char newline = '\n';       // Символ новой строки
        char unicodeChar = '\u2764'; // Символ Unicode (❤)

        // Вывод значений переменных
        WriteLine($"Символ: {letter}, Unicode-код: {(int)letter}");
        WriteLine($"Символ: {digit}, Unicode-код: {(int)digit}");
        WriteLine($"Символ: {symbol}, Unicode-код: {(int)symbol}");
        WriteLine($"Символ новой строки: {newline}(переход на новую строку)");
        WriteLine($"Символ Unicode: {unicodeChar}, Unicode-код: {(int)unicodeChar}");

        // Операции с char
        char nextLetter = (char)(letter + 1); // Следующий символ в алфавите
        WriteLine($"Следующий символ после {letter}: {nextLetter}");

        // Проверка типов символов
        WriteLine($"'{letter}' - это буква: {char.IsLetter(letter)}");
        WriteLine($"'{digit}' - это цифра: {char.IsDigit(digit)}");
        WriteLine($"'{symbol}' - это буква или цифра: {char.IsLetterOrDigit(symbol)}");

        // Значение по умолчанию для char
        WriteLine($"\nЗначение по умолчанию типа char: '{defaultChar}'");
        WriteLine($"Код значения по умолчанию: {(int)defaultChar}");
        WriteLine($"Является ли значение по умолчанию нулевым символом ('\\0'): {defaultChar == '\0'}");

        // Диапазон значений char
        WriteLine($"\nМинимальное значение: '\\u{(int)char.MinValue:X4}'");
        WriteLine($"Максимальное значение: '\\u{(int)char.MaxValue:X4}'");
    }
}
```

Вывод программы:

```
Символ: A, Unicode-код: 65
Символ: 1, Unicode-код: 49
Символ: #, Unicode-код: 35
Символ новой строки:
(переход на новую строку)
Символ Unicode: ❤, Unicode-код: 10084
Следующий символ после A: B
'A' - это буква: True
'1' - это цифра: True
'#' - это буква или цифра: False

Значение по умолчанию типа char: ''
Код значения по умолчанию: 0
Является ли значение по умолчанию нулевым символом ('\0'): True

Минимальное значение: '\u0000'
Максимальное значение: '\uFFFF'
```

![Символьные переменные в C#](car_vars01.png){ border-effect="line"  thumbnail="true" width="700" }

>Внимение! Для вывода символов ваш терминал должен поддерживать работу в кодировке Unicode. Windows Terminal имеет 
> такую поддержку, а стандартная Windows Console, как правило, нет.
>{style="warning"}

### Итоги:
- Тип `char` представляет одиночный символ в кодировке Unicode.
- Занимает **2 байта** (16 бит) в памяти.
- Значение по умолчанию — `'\0'` (нулевой символ).
- Поддерживает множество операций, таких как проверка на букву, цифру и преобразование.

## Символьные литералы

В C# литералы типа `char` — это одиночные символы, записанные в одиночных кавычках `'`. Литералы могут быть:

1. **Обычные символы**:  
   Символы, такие как буквы, цифры и знаки препинания.  
   Пример: `'A'`, `'1'`, `'#'`.

2. **Экранированные последовательности**:  
   Используются для представления специальных символов.  
   Пример:
    - `'\n'` — новая строка.
    - `'\t'` — табуляция.
    - `'\''` — одиночная кавычка.
    - `'\0'` — нулевой символ.

3. **Unicode-последовательности**:  
   Символы Unicode записываются в формате `'\uXXXX'`, где `XXXX` — 16-битный код символа.  
   Пример:
    - `'\u2764'` — символ сердечка (❤).
    - `'\u0950'` — символ Ом (ॐ).

Теперь практика!

Создай консольное приложение `ex0029_cahr_literals` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи `Program.cs` к следующему виду:

```c#
using System;

class Program
{
    static void Main()
    {
        // Литералы типа char
        char letter = 'A';                  // Обычный символ
        char digit = '5';                   // Цифра
        char symbol = '#';                  // Специальный символ
        char newline = '\n';                // Символ новой строки
        char tab = '\t';                    // Табуляция
        char singleQuote = '\'';            // Одиночная кавычка
        char unicodeHeart = '\u2764';       // Красное сердце
        char unicodeOm = '\u0950';          // Символ Ом ॐ
        char unicodeSmiley = '\u263A';      // Улыбающийся смайлик

        // Вывод значений литералов
        WriteLine($"Обычный символ: {letter}");
        WriteLine($"Цифра: {digit}");
        WriteLine($"Специальный символ: {symbol}");
        WriteLine($"Табуляция: {tab}(после табуляции)");
        WriteLine($"Одиночная кавычка: {singleQuote}");
        WriteLine($"Символ новой строки:{newline}Новая строка начинается здесь");

        // Цветной вывод
        ForegroundColor = ConsoleColor.Red;
        WriteLine($"Красное сердце: {unicodeHeart}");

        ForegroundColor = ConsoleColor.DarkYellow;
        WriteLine($"Улыбающийся смайлик: {unicodeSmiley}");

        ForegroundColor = ConsoleColor.DarkMagenta;
        WriteLine($"Символ Омкары: {unicodeOm}");

        // Сброс цвета консоли
        ResetColor();
    }
}
```

Если ваш терминал поддерживает Unicode, то вы должны увидеть такой вывод:

![Символьные переменные в C#](car_vars02.png){ border-effect="line"  thumbnail="true" width="700" }

### Описание программы:

1. **Литералы**:
    - Программа показывает примеры работы с обычными символами, экранированными последовательностями и Unicode-символами.
2. **Цветной вывод**:
    - Используются команды `Console.ForegroundColor` для изменения цвета текста в консоли:
        - Красное сердце: `ConsoleColor.Red`.
        - Желтый смайлик: `ConsoleColor.DarkYellow`.
        - Оранжевая Омкара: `ConsoleColor.DarkMagenta`.
3. **Символы Unicode**:
    - Символ Омкары: `'\u0950'` — символ из санскрита.
    - Сердечко: `'\u2764'` — классический символ сердечка.
    - Улыбающийся смайлик: `'\u263A'`.


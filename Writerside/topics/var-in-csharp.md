# Переменные в C#

Переменная — это именованная область памяти, используемая для хранения данных, которые могут изменяться во время 
выполнения программы. Она имеет тип, который определяет, какие данные можно хранить в переменной, и как они будут обрабатываться.

Переменные программы хранятся в оперативной памяти компьютера, которая выделяется программе операционной системой.

Как уже было сказано в определение переменные на то и переменные, что их значение может меняться во время выполнения программы
или они даже могут быть удалены из памяти, например сборщиком мусора, если они уже не нужны для выполнения программы.

Естественно, что по завершении работы программы все переменные которые она использовала так же удаляются из памяти.

Переменные могут получать свои значения не посредственно в ходе выполнения программы из пользовательского ввода, читаться из
файлов или баз данных, а так же быть на прямую заданы в коде программы.

Значения переменных так же могут выводиться на экран, принтер, файл, базу данных, отправляться по сети и т.п.

Каждая переменная имеет **тип**, **имя** и **значение (данные)**.

Например:
```C#
int price = 100;
```
В данном случае `int` - это тип переменной, `price` - это имя переменной, а `100` - это значение переменной. 

Рассматривайте переменную как ящик куда можно что-то поместить, вынуть и поместить что-то другое. Но поскольку C# строго
типизированный язык в определенные ящики, можно помещать только определенные типы данных.

Разные типы данных имеют разные размеры поэтому для них выделяются разные по размеру ящики. То есть для хранения переменных
разных типов в памяти компьютера выделяется различное количество бит.

В приведенном выше примере для переменной типа `int` в памяти выделяется 32 бита, что равно 4 байтам. Переменные типа `int` могут
содержать значения от -2,147,483,648 до 2,147,483,647.

А вот пример переменой типа `byte`:
```C#
byte ascii_symbol = 108;
```
Для переменной типа `byte` выделяется 8 бит, что рано 1 байту. Переменные типа `byte` могут содержать значения от 0 до 255.

## Представление информации в памяти компьютера
Память измеряется в байтах. Один байт содержит 8 бит. 

**Что такое бит и байт?**
- **Бит** — это минимальная единица информации в компьютере, которая может принимать два значения: **0** или **1**.
- **Байт** — это последовательность из 8 бит. Он является стандартной минимальной единицей хранения данных в памяти компьютера.

**Как представляется информация в памяти компьютера?**

Компьютерная память устроена как огромный набор ячеек, каждая из которых может содержать 1 байт. В каждом байте 
хранятся 8 бит, которые могут быть **0** или **1**. Эти комбинации кодируют числа, символы, инструкции и другие данные 
с помощью кодировок (например, ASCII или Unicode для текста).

**Почему 1 байт может представлять 256 значений?**

Каждый бит в байте может быть либо **0**, либо **1**. Количество возможных комбинаций из 8 бит вычисляется как:  

$2^8 = 256$  

Таким образом, байт может представлять числа от **0 до 255** (если без знака) или от **-128 до 127** (если используется знак).  
Пример:
- `00000000` (все биты = 0) — это 0.
- `11111111` (все биты = 1) — это 255.

**Перевод из двоичной в десятичную**

Возьмем число **1011** (двоичное).  
Каждая цифра двоичного числа, в зависимости от своего положения (начиная справа), имеет вес, равный степени двойки, начиная с нуля:

| Вес цифры  | Цифра | Степень двойки | Значение |
|------------|-------|----------------|----------|
| 3 (слева)  | 1     | $2^3 = 8$      | 8        |
| 2          | 0     | $2^2 = 4$      | 0 (потому что 0 × 4 = 0) |
| 1          | 1     | $2^1 = 2$      | 2        |
| 0 (справа) | 1     | $2^0 = 1$      | 1        |

Теперь складываем только значения, которые **не равны 0**:  
$8 + 0 + 2 + 1 = 11$

**Результат:** $1011_2 = 11_{10}$

**Почему пропадает "4" в примере?**

В двоичной системе каждая **0** означает, что значение этой степени двойки не используется.  
В примере $1011_2$, цифра **0** на позиции $2^2$ даёт $0 * 4 = 0$, поэтому $4$ не добавляется в сумму.

**Перевод из десятичной в двоичную**

Возьмем число **13** (десятичное) и разделим целочисленным делением на 2, чтобы получить остатки:

1. **$13 \div 2 = 6$**, остаток **$1$**.
2. **$6 \div 2 = 3$**, остаток **$0$**.
3. **$3 \div 2 = 1$**, остаток **$1$**.
4. **$1 \div 2 = 0$**, остаток **$1$**.

Теперь записываем остатки **снизу вверх**:  
$1\ 1\ 0\ 1$

**Результат:** $13_{10} = 1101_2$


**Что такое целочисленное деление с остатком?**

В **целочисленном делении** результатом является только **целая часть** от деления, а остаток — это то, что "остается", 
если делимое не делится нацело.

Формула:  
```tex
Делимое = (Делитель \times ЦелаяЧасть) + Остаток
```
При этом:
- Остаток всегда меньше делителя.

Разберем $ 1 ÷ 2$ в контексте целочисленного деления с остатком:
1. Сколько раз $2$ помещается в $1$ без превышения? Ответ: $0$ раз (**целая часть = 0**).
2. Что осталось после этого? Осталось всё исходное число $1$, потому что $2$ в $1$ "не помещается".

Результат:  

$1 ÷  2 = 0 \, (\text{целая часть}) \, \text{и остаток 1}$.

**Объяснение целочисленного деления через раздачу пирогов:**

1. У тебя есть **13 пирогов**, ты раздаёшь их **группами по 2 пирога**. Раздавать можно только **целые** пироги. Резать пироги нельзя.
2. На каждом шаге:
    - Считаем, сколько раз можно раздать **по 2 целых пирога** (**целая часть деления**).
    - Считаем, сколько пирогов осталось (**остаток**).

**Шаги деления $13 \div 2$:**
1. **Первый шаг:**
    - У тебя есть $13$ пирогов. Сколько раз можно раздать по $2$ пирога?  
      $13 \div 2 = 6$ (**целая часть = 6**).
    - После раздачи $6 \times 2 = 12$ пирогов у тебя остался **1 пирог** (**остаток = 1**).

2. **Второй шаг:**
    - Теперь $6$ пирогов сколько раз можно раздать по $2$ пирога?  
      $6 \div 2 = 3$ (**целая часть = 3**).
    - После раздачи $3 \times 2 = 6$ пирогов осталось **0 пирогов** (**остаток = 0**).

3. **Третий шаг:**
    - Теперь  $3$ пирога сколько раз можно раздать по $2$?  
      $3 \div 2 = 1$ (**целая часть = 1**).
    - После раздачи $1 \times 2 = 2$ пирогов остался **1 пирог** (**остаток = 1**).

4. **Четвёртый шаг:**
    - И так остался $1$ пирог. Сколько раз можно раздать по $2$?  
      $1 \div 2 = 0$ (**целая часть = 0**). $0$ пирогов вы можете раздать. Поэтому у вас остается **1 пирог** (**остаток = 1**).
    - После раздачи $0 \times 2 = 0$ пирогов остался **1 пирог** (**остаток = 1**).

**Как собрать двоичное число:**
Остатки, которые мы получили (1, 0, 1, 1), записываем **снизу вверх**:  

$13_{10} = 1101_2$

**Кратко что мы проделали:**
1. На каждом шаге ты раздаёшь пироги **по 2 штуки за раз**.
2. Что остаётся после раздачи — это **остаток**, который записывается как разряд двоичного числа.
3. Процесс продолжается, пока у тебя не закончатся пироги (целая часть не станет 0).

### Представление отрицательных целых чисел в двоичной системе

Если двоичное число интерпретируется как знаковое, то старший бит (самый левый) указывает 
на знак числа:
- `0` — положительное число.
- `1` — отрицательное число.

**Общие шаги перевода отрицательного числа в двоичную систему**

1. **Найти двоичное представление положительного аналога числа.**
   - Например, для `-60` сначала возьмем `60`.

2. **Дополнить двоичное представление до разрядности типа.**
   - Например, если используем 8 бит, то записываем число в формате `0011_1100`.

3. **Инвертировать биты (заменить 1 на 0 и 0 на 1).**

4. **Добавить 1 к результату.**

### Пример: перевод числа `-60` в двоичную систему для 8-битного представления

1. **Положительный аналог числа:**
   - Число `60` в двоичной системе:
     ```
     60 (десятичное) = 0011_1100 (двоичное).
     ```

2. **Инверсия всех битов:**
   - Инвертируем (заменяем 1 на 0 и 0 на 1):
     ```
     0011_1100 → 1100_0011.
     ```

3. **Добавление 1:**
   - Прибавляем 1 к результату:
     ```
     1100_0011 + 1 = 1100_0100.
     ```

4. **Результат:**
   - Число `-60` в дополнительном коде для 8 бит:
     ```
     -60 = 1100_0100.
     ```

### Пример: перевод из двоичной системы обратно в десятичную: пример с `1100_0100`

1. **Проверить знак числа:**
   - Если старший бит равен 1 (в данном случае `1`), то число отрицательное.

2. **Инвертировать все биты:**
   - Инвертируем:
     ```
     1100_0100 → 0011_1011.
     ```

3. **Вычесть 1:**
   - Вычитаем 1:
     ```
     0011_1011 - 1 = 0011_1100.
     ```

4. **Перевести в десятичное:**
   - Число `0011_1100` в десятичной системе:
     ```
     0011_1100 = 60.
     ```

5. **Добавить знак:**
   - Так как старший бит изначально был 1, результат:
     ```
     -60.
     ```

Когда самый старший бит числа интерпретируется как знак числа, такое представление называют **дополнительным кодом** или
**Two's Complement**.

Это было совсем не много математики необходимой для понимания двоичной системы счисления.

А теперь возвращаемся к теме переменных.

## Основные правила именования переменных в C#
1. **Определение переменной:**
   - Перед использованием переменную необходимо определить.
   - Синтаксис определения переменной:
     ```c#
     тип имя_переменной;
     ```
2. **Требования к имени переменной:**
   - Имя может содержать **буквы, цифры и символ подчеркивания** (`_`).
   - **Первый символ** имени должен быть **буквой или символом подчеркивания**.
   - **Запрещено** использовать пробелы, знаки пунктуации или специальные символы.
   - Имя **не может быть ключевым словом** языка C# (например, `int`, `class` и т.д.).
   - **Чувствительность к регистру**: `age` и `Age` считаются разными именами.

3. **Стиль именования:**
   - Используйте **camelCase** для локальных переменных и полей с модификатором `private`.
   - Используйте **PascalCase** для открытых (`public`) полей, свойств, методов и имен типов.

4. **Семантическая ясность:**
   - Имя должно быть **осмысленным** и отражать суть переменной. Например, вместо `x` лучше использовать `age`, `totalAmount`, и т.д.
   - Избегайте слишком длинных или слишком коротких имен, если это не оправдано.

5. **Особые правила:**
   - Для полей класса рекомендуется использовать префикс `_` (например, `_totalAmount`) в закрытых (`private`) переменных.
   - Константы (`const`) и статические переменные (`static readonly`) именуются **заглавными буквами** с подчеркиванием (`UPPER_CASE_WITH_UNDERSCORES`).

### Таблица стилей именования и использования
| **Стиль**             | **Примеры**                  | **Использование**                                                                 |
|------------------------|------------------------------|-----------------------------------------------------------------------------------|
| **Верблюжий регистр (camelCase)** | `totalAmount`, `orderDetail` | Локальные переменные, закрытые (`private`) поля.                                 |
| **Прописной стиль (PascalCase)** | `Name`, `TotalAmount`, `Run` | Имена типов, открытых (`public`) полей, свойств, методов, классов.               |
| **Заглавные буквы (UPPER_CASE)** | `MAX_VALUE`, `DEFAULT_PORT`  | Константы и статические поля (`const`, `static readonly`).                        |

### Примеры использования:
- Локальная переменная:
  ```c#
  int totalAmount = 100;
  ```
- Закрытое поле класса:
  ```c#
  private int _totalAmount;
  ```
- Открытое свойство:
  ```c#
  public int TotalAmount { get; set; }
  ```
- Константа:
  ```c#
  private const int MAX_USERS = 1000;
  ```

Перед типами переменных, в примерах выше стоят инструкции модификаторов доступа. Всё это было кратко описано в главе 
["Элементы языка C#"](GrammarAndTerminologyCSharp.md).

Тут мы так же немного затронули константы. Про них будет в следующей теме.

## Целочисленные переменные

>Этот раздел по целочисленным переменным достаточно объемный, так как на примере целочисленных переменных будут объяснены
> и общие принципы для всех типов переменных.
{style="note"}

В C# есть несколько встроенных типов для целых чисел, которые различаются по размеру, диапазону и знаковости. 
Вот их подробное описание:

| **Тип**       | **Размер (в байтах)** | **Диапазон значений**                  | **Значение по умолчанию** |
|----------------|-----------------------|-----------------------------------------|---------------------------|
| **sbyte**     | 1                     | -128 до 127                            | 0                         |
| **byte**      | 1                     | 0 до 255                               | 0                         |
| **short**     | 2                     | -32,768 до 32,767                      | 0                         |
| **ushort**    | 2                     | 0 до 65,535                            | 0                         |
| **int**       | 4                     | -2,147,483,648 до 2,147,483,647        | 0                         |
| **uint**      | 4                     | 0 до 4,294,967,295                     | 0                         |
| **long**      | 8                     | -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807 | 0 |
| **ulong**     | 8                     | 0 до 18,446,744,073,709,551,615        | 0                         |
| **nint** *(с версии C# 9.0)*  | Зависит от платформы | -2³¹ до 2³¹-1 (32-битная платформа) или -2⁶³ до 2⁶³-1 (64-битная платформа) | 0 |
| **nuint** *(с версии C# 9.0)* | Зависит от платформы | 0 до 2³²-1 (32-битная платформа) или 0 до 2⁶⁴-1 (64-битная платформа) | 0 |


**Ключевые особенности**
1. **`sbyte`** и **`short`**: знаковые типы для небольших чисел.
2. **`byte`** и **`ushort`**: беззнаковые версии для тех же диапазонов.
3. **`int`** и **`uint`**: основные типы для работы с числами среднего размера.
4. **`long`** и **`ulong`**: предназначены для больших чисел.
5. **`nint`** и **`nuint`**: зависят от платформы и используются для работы с указателями или низкоуровневым кодом.

Исходя из ваших нужд вы можете использовать тот или иной тип переменных.

Переменные на уровне класса можно просто объявить, или же сразу при объявлении присвоить значение. Если переменной 
на уровне класса при объявлении не присваивается значение явно, то ей присваивается значение по умолчанию.

> Переменные внутри методов класса должны обязательно инициализироваться каким-либо значением.
> {style="warning"}

Значение переменной присваивается при помощи оператора `=` (присваивания).

Давай уже, падаван, попрактикуемся. Создай консольное приложение `ex0015_integer_vars` при помощи шаблона `tinyconsole`
в папке episode02 и добавь его в файл решения episode02.sln. Это можно сделать как в командной строке так и в любой IDE.

Приведи файл Program.cs к следующему виду:

```C#
namespace ex0015_integer_vars;

class Program
{
    static sbyte sbyteDefault;
    static sbyte byteDefault;
    static short shortDefault;
    static ushort ushortDefault;
    static int intDefault;
    static uint uintDefault;
    static long longDefault;
    static ulong ulongDefault;
    static nint nintDefault;
    static nuint nuintDefault;

    static void Main()
    {
        WriteLine("Типы целочисленных переменных в C#");
        WriteLine(new string('-', 34));

        // sbyte
        sbyte sbyteMin = sbyte.MinValue;
        sbyte sbyteMax = sbyte.MaxValue;
        
        WriteLine($"Тип: sbyte");
        WriteLine($"Минимум: {sbyteMin}");
        WriteLine($"Максимум: {sbyteMax}");
        WriteLine($"Значение по умолчанию: {sbyteDefault}");
        WriteLine();

        // byte
        byte byteMin = byte.MinValue;
        byte byteMax = byte.MaxValue;
        WriteLine($"Тип: byte");
        WriteLine($"Минимум: {byteMin}");
        WriteLine($"Максимум: {byteMax}");
        WriteLine($"Значение по умолчанию: {byteDefault}");
        WriteLine();

        // short
        short shortMin = short.MinValue;
        short shortMax = short.MaxValue;
        WriteLine($"Тип: short");
        WriteLine($"Минимум: {shortMin}");
        WriteLine($"Максимум: {shortMax}");
        WriteLine($"Значение по умолчанию: {shortDefault}");
        WriteLine();

        // ushort
        ushort ushortMin = ushort.MinValue;
        ushort ushortMax = ushort.MaxValue;
        WriteLine($"Тип: ushort");
        WriteLine($"Минимум: {ushortMin}");
        WriteLine($"Максимум: {ushortMax}");
        WriteLine($"Значение по умолчанию: {ushortDefault}");
        WriteLine();

        // int
        int intMin = int.MinValue;
        int intMax = int.MaxValue;
        WriteLine($"Тип: int");
        WriteLine($"Минимум: {intMin}");
        WriteLine($"Максимум: {intMax}");
        WriteLine($"Значение по умолчанию: {intDefault}");
        WriteLine();

        // uint
        uint uintMin = uint.MinValue;
        uint uintMax = uint.MaxValue;
        WriteLine($"Тип: uint");
        WriteLine($"Минимум: {uintMin}");
        WriteLine($"Максимум: {uintMax}");
        WriteLine($"Значение по умолчанию: {uintDefault}");
        WriteLine();

        // long
        long longMin = long.MinValue;
        long longMax = long.MaxValue;
        WriteLine($"Тип: long");
        WriteLine($"Минимум: {longMin}");
        WriteLine($"Максимум: {longMax}");
        WriteLine($"Значение по умолчанию: {longDefault}");
        WriteLine();

        // ulong
        ulong ulongMin = ulong.MinValue;
        ulong ulongMax = ulong.MaxValue;
        WriteLine($"Тип: ulong");
        WriteLine($"Минимум: {ulongMin}");
        WriteLine($"Максимум: {ulongMax}");
        WriteLine($"Значение по умолчанию: {ulongDefault}");
        WriteLine();

        // nint (платформо-зависимый тип)
        nint nintMin = nint.MinValue;
        nint nintMax = nint.MaxValue;
        WriteLine($"Тип: nint");
        WriteLine($"Минимум: {nintMin}");
        WriteLine($"Максимум: {nintMax}");
        WriteLine($"Значение по умолчанию: {nintDefault}");
        WriteLine();

        // nuint (платформо-зависимый тип)
        nuint nuintMin = nuint.MinValue;
        nuint nuintMax = nuint.MaxValue;
        
        WriteLine($"Тип: nuint");
        WriteLine($"Минимум: {nuintMin}");
        WriteLine($"Максимум: {nuintMax}");
        WriteLine($"Значение по умолчанию: {nuintDefault}");
        WriteLine();
    }
}
```

**Первый** запуск программы даст следующий вывод (показана часть вывода):

![Целочисленные переменные в C#](int_vars01.png){ border-effect="line"  thumbnail="true" width="700" }

Как видите компилятор вывел предупреждение, что поскольку некоторые переменные не были инициализированы значениями, то
им было присвоено значение по умолчанию.

При втором запуске таких предупреждений уже не будет.

![Целочисленные переменные в C#](int_vars02.png){ border-effect="line"  thumbnail="true" width="700" }

Если вы хотите увидеть эти предупреждения снова, дайте команду `dotnet clean` в папке проекта.

В этой программе следует обратить внимание на блок объявления десяти переменных в самом начале программы. То есть в классе
Program. И попытаться понять почему другие переменные были объявлены и инициализированы значениями внутри метода Main().

**Переменные за пределами метода `Main`**

Переменные вроде `sbyteDefault`, `byteDefault` и другие определены как **поля класса** (на уровне класса), 
а не как локальные переменные внутри метода. Причины этого:

- **Доступ к значению по умолчанию без явного инициализатора**: Поля класса автоматически инициализируются значением по умолчанию, если не задать его явно. Это позволяет продемонстрировать значения по умолчанию, такие как `0` для целочисленных типов, без необходимости явно присваивать их внутри метода.
- **Локальные переменные требуют явной инициализации**: Если бы мы определили эти переменные внутри метода `Main`, компилятор потребовал бы явного присваивания значения, так как локальные переменные в C# не получают значение по умолчанию автоматически.
- **Повторное использование**: Поля класса могут быть доступны из разных методов, если потребуется. Это делает их более гибкими, чем локальные переменные, которые доступны только внутри метода, где они объявлены.

**Почему использовано ключевое слово `static`**

Все поля, такие как `sbyteDefault`, объявлены с модификатором `static`. Это связано с тем, что метод `Main()` тоже 
объявлен как `static`. В C# метод `Main` — это точка входа для программы, и компилятор требует, чтобы он был статическим.

Поле или метод, помеченные ключевым словом `static`, принадлежат самому классу, а не конкретному экземпляру этого класса. 
В данном случае:
- Метод `Main` принадлежит классу `Program`, а не объекту класса `Program`.
- Поля, к которым обращается метод `Main`, также должны быть статическими, иначе метод `Main` не сможет к ним обратиться.

Если бы поля `sbyteDefault`, `byteDefault` и т.д. не были статическими, то для доступа к ним внутри `Main()` потребовалось 
бы создавать экземпляр класса `Program`. Например:
```c#
Program program = new Program();
Console.WriteLine(program.sbyteDefault); // доступ через объект
```
Это избыточно и не имеет смысла в данном случае.

**Подведем итоги**
- Поля класса, объявленные как `static`, используются для демонстрации значений по умолчанию, так как они автоматически инициализируются компилятором.
- Метод `Main()` также статический, чтобы быть точкой входа программы.
- Статические поля и метод могут обращаться друг к другу без создания экземпляра класса.

**Пример для иллюстрации разницы**

Вот как программа могла бы выглядеть без использования `static` для полей:

```c#
namespace ex0015_integer_vars;

class Program
{
    sbyte sbyteDefault; // Поле экземпляра класса

    static void Main()
    {
        Program program = new Program(); // Создаем объект класса
        Console.WriteLine(program.sbyteDefault); // Теперь доступ через объект
    }
}
```

В этом примере для доступа к полю `sbyteDefault` требуется создать объект класса, потому что поле не является статическим. 
Это лишний шаг в нашем случае, так как переменные используются только в статическом контексте.

Скорее всего вам было не всё понятно в этих объяснениях, так как мы ещё не проходили что такое класс и экземпляр класса.
Вы всё это скоро узнаете. Пока намотайте на ус 😊.

Хотя давайте это же самое ещё раз проговорим чуток другими словами, возможно будет понятнее.

В C# при объявлении переменной, если ей не присваивается значение явно, то для нее автоматически задается **значение по умолчанию**. 
Однако есть нюансы:

1. **Локальные переменные** (объявленные внутри методов) **не инициализируются автоматически**, и попытка их использования до явного присваивания значения приведет к ошибке компиляции. Например:
   ```c#
   void PrintField() // это метод, не путайте с классом
   {
       int field; // Ошибка: локальная переменная не инициализирована
       Console.WriteLine(field); // Ошибка компиляции
   }
   ```

2. **Поля классов** и **переменные уровня класса/структуры** автоматически получают **значение по умолчанию**. Например:
   ```c#
   class Example
   {
       int field; // Поле получает значение по умолчанию: 0

       void PrintField()
       {
           Console.WriteLine(field); // Вывод: 0
       }
   }
   ```
Переменные, объявленные в методе (**локальные переменные**), не инициализируются автоматически значениями по умолчанию. 
Это сделано для повышения **производительности** и **безопасности*** кода.

**Производительность кода**

Локальные переменные существуют только во время выполнения метода (в пределах его **стека**). Если бы компилятор 
автоматически присваивал значения по умолчанию каждой локальной переменной, это добавляло бы лишние операции и замедляло 
выполнение программы, особенно в методах, которые часто вызываются. Вместо этого ответственность за инициализацию ложится 
на программиста.

**Безопасность кода**

Если бы локальные переменные автоматически инициализировались значениями по умолчанию, это могло бы скрыть ошибки, 
возникающие из-за пропущенной инициализации. Например, разработчик может забыть присвоить нужное значение переменной, 
но компилятор этого не заметит, так как значение по умолчанию уже будет установлено. Принудительная инициализация 
заставляет программиста явно задавать значения, что делает код более предсказуемым и понятным.

Пример ошибки:
```c#
int result; // Нет ошибки, если бы значение по умолчанию было присвоено
Console.WriteLine(result); // Вывод "0" мог бы ввести в заблуждение, т.к. 0 может не быть ожидаемым результатом.
```

Локальные переменные чаще используются для временных вычислений, и их значения обычно устанавливаются сразу после объявления. 
Поэтому разработчики C# решили не нагружать систему автоматической инициализацией локальных переменных, 
так как это редко бывает необходимо.

Пример правильного подхода:
```c#
int sum = 0; // Явная инициализация
for (int i = 0; i < 10; i++)
{
    sum += i;
}
```

**Итог. Почему поля инициализируются автоматически, а локальные переменные — нет?**
- **Поля (переменные класса)** связаны с объектом, и их жизненный цикл равен жизненному циклу объекта. Они хранятся в куче, инициализация значениями по умолчанию помогает избежать случайных ошибок.
- **Локальные переменные** короткоживущие, хранятся в стеке, и их основной задачей является хранение временных данных. Явная инициализация повышает контроль над их использованием.

К сожалению без оперирования понятиями классов, методов и объектов, объяснить все эти моменты было бы не возможно. И хотя мы ещё не
изучали что такое класс и метод класса, вы уже соприкоснулись с этими понятиями и нейронные связи в вашем мозгу уже прямо
сейчас начали расти. Чувствуете как мозги закипают? 😊 Это нейроночки у вас в мозгу растут. Вы становитесь умнее и умнее.
Хотя, возможно, пока вы это и не замечаете 😊. Да пребудет с тобой сила, падван.

>Все эти вещи, которые мы тут разжевывали касательно места, где объявляется переменная, общие для всех переменных, 
>не зависимо от их типа.

И ещё один момент. Как вы помните в главе ["Структура проекта C#"](Csharp-project-structure.md) 
мы подробно разбирали операторы верхнего уровня. Одной из причин почему их ввели, было упрощение изучения C# и снижение
порога вхождения. Хотя на самом деле, ни класс Program, ни статический метод Main, ни куда не девались. Их
просто скрыли чтобы не пугать начинающих. Но в любом случае они есть и от того что их скрыли легче не становится 😊.
Не находите? И на мой взгляд с этими вещами начинать работать и разбираться нужно в самом начале.

## Целочисленные литералы
В C# целочисленные литералы — это фиксированные значения, которые используются для представления целых чисел в коде. 
Они могут быть записаны в различных форматах: десятичном, шестнадцатеричном, двоичном и с использованием суффиксов, 
чтобы указать конкретный тип числа.

**Типы целочисленных литералов:**
1. **Десятичные (Decimal)**  
   Значение записывается как обычное целое число без какого-либо префикса. Всегда интерпретируется компилятором как число типа `int`.
   Пример: `42`, `-1000`.

2. **Шестнадцатеричные (Hexadecimal)**  
   Используется префикс `0x` или `0X`. Число записывается с использованием цифр `0–9` и букв `A–F` (или `a–f`). Всегда интерпретируется компилятором как положительное число типа `int`.  
   Пример: `0x2A`, `0xFF`.

3. **Двоичные (Binary)**  
   Используется префикс `0b` или `0B`. Число записывается с использованием цифр `0` и `1`. Всегда интерпретируется компилятором как положительное число типа `int`.
   Пример: `0b101010`.

4. **Суффиксы для указания типа литерала**:
   - `L` или `l` — для типа `long`.  
     Пример: `42L`.
   - `U` или `u` — для типа `uint`.  
     Пример: `42U`.
   - `UL`, `ul`, `LU`, `lu` — для типа `ulong`.  
     Пример: `42UL`.
   - Без суффиксов литералы по умолчанию имеют тип `int`.

5. **Разделители цифр (Digit Separators)**  
   Символ `_` используется для разделения цифр для улучшения читаемости, но не влияет на значение.  
   Пример: `1_000_000`, `0b1101_0101`.

Давайте немного попрактикуемся. Создайте проект `ex0016_int_literals` при помощи шаблона `tinyconsole`. Добавьте его в решение
`episode02.sln`.

```c#
namespace IntegerLiteralsExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // Десятичный литерал
            int decimalLiteral = 42;
            WriteLine($"Десятичный: {decimalLiteral}");

            // Шестнадцатеричный литерал
            int hexLiteral = 0x2A;
            WriteLine($"Шестнадцатеричный: {hexLiteral}");

            // Двоичный литерал
            int binaryLiteral = 0b101010;
            WriteLine($"Двоичный: {binaryLiteral}");

            // Литералы с суффиксами
            long longLiteral = 42L;
            uint uintLiteral = 42U;
            ulong ulongLiteral = 42UL;

            WriteLine($"Суффиксы:");
            WriteLine($"  long: {longLiteral}");
            WriteLine($"  uint: {uintLiteral}");
            WriteLine($"  ulong: {ulongLiteral}");

            // Литералы с разделителями цифр
            int largeNumber = 1_000_000;
            int binaryWithSeparators = 0b1010_1010_1111_0000;

            WriteLine($"С разделителями цифр:");
            WriteLine($"  Большое число: {largeNumber}");
            WriteLine($"  Двоичный: {binaryWithSeparators}");
        }
    }
}
```
Выполните программу.

Вывод программы будет такой:
```
Десятичный: 42
Шестнадцатеричный: 42
Двоичный: 42
Суффиксы:
  long: 42
  uint: 42
  ulong: 42
С разделителями цифр:
  Большое число: 1000000
  Двоичный: 43760
```
Как видите сами литералы не влияют на то как реально хранятся данные и их вывод на экран. Это просто синтаксический сахар
добавленный в язык для удобства написания и чтения.

Так же обратите внимание на название пространства имен. Как я говорил название для пространства имен вы можете выбирать любое.

>В C# типы литералов и операций зависят от их записи и контекста. Тип `int` используется по умолчанию для большинства 
>целочисленных литералов и операций, но это не единственный вариант.
{style="warning"}

Давайте разберемся что это значит на практике. Создайте проект `ex0017_int_leterals_default_type` при помощи шаблона `tinyconsole`. 
Добавьте его в решение `episode02.sln`. И затем приведите код в `Program.cs` К следующему виду:

![Целочисленные литералы в C#](int_vars03.png){ border-effect="line"  thumbnail="true" width="700" }

В этом варианте кода 5 ошибок. Но эти ошибки относятся к двум видам: [CS0031](https://learn.microsoft.com/ru-ru/dotnet/csharp/misc/cs0031?f1url=%3FappId%3Droslyn%26k%3Dk(CS0031)) и [CS0266](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/compiler-messages/cs0266?f1url=%3FappId%3Droslyn%26k%3Dk(CS0266)).
О чём нам и сообщает VSCode.

**Наша задача чтобы в переменных a0b, a0x, b, c оказалось значение -60. А в переменной d значение 60.**

В 10 строке в двоичном представлении с помощью двоичного литерала записано десятичное число 196. Но если это число интерпретировать
как знаковое, то есть первая слева единица означает отрицательное число, то это будет число -60.

То же самое относится к 11 строке. Только там число 196 записано в шестнадцатеричном формате.

Как уже говорилось двоичные и шестнадцатеричные литералы интерпретируются компилятором как числа типа `int` без знака.

Что мы имеем по этому поводу. Во-первых, тип `int` шире чем тип `byte`. То есть мы пытаемся запихнуть значение типа `int`
в переменную типа `byte`, то есть запихнуть большой ящик в маленький. Посмотрите сколько бит занимают типы `byte` и `int`.
Во вторых посмотрите диапазон чисел которые может представлять тип `sbyte` (от -128 до 127). Число 196 в него явно не
помещается. А вот число -60 помещается. То есть нам надо сделать чтобы число 196 стало интерпретироваться как знаковое.
Этого можно добиться разрешив операцию переполнения типа.

**Переполнение типов** в C# происходит, когда значение выходит за пределы допустимого диапазона для конкретного типа данных. 
В таком случае, в зависимости от режима выполнения (`checked` или `unchecked`), либо генерируется исключение 
`OverflowException`, либо результат "заворачивается" по кругу.

### Что происходит при переполнении?
1. **В режиме `unchecked`**:
   - Число "заворачивается" в пределах допустимого диапазона.
   - Для `sbyte` значение `196` преобразуется в `-60`:
      - 196 в двоичной системе: `1100_0100`.
      - Для типа `sbyte`, старший бит интерпретируется как знак, поэтому это отрицательное число.
      - Чтобы узнать значение: инвертируем (`0011_1011`), добавляем 1 (`0011_1100` = 60), и ставим знак `-`.

2. **В режиме `checked`**:
   - Попытка выполнить переполнение приводит к выбросу исключения `OverflowException`.

С исключениями в C# мы познакомимся попозже.

Компилятор C# выполняет проверки переполнения для некоторых случаев например, литералы, которые явно не помещаются в целевой тип.
Это как раз наш случай. Давайте попробуем сделать явное приведение литерала к типу `sbyte`. То есть как бы обрезать большой ящик
и запихнуть его в маленький 😊. Приведите программу к следующему виду:

![Целочисленные литералы в C#](int_vars04.png){ border-effect="line"  thumbnail="true" width="700" }

Мы использовали операцию приведения к типу. Для типа `sbyte` она выглядит так `(sbyte)` перед значением которое приводится
к этому типу.

Видите что в 13 строке теперь нет ошибки? А в 12 строке ошибка сохранилась. Но она уже стала другой [CS0221](https://learn.microsoft.com/ru-ru/dotnet/csharp/misc/cs0221?f1url=%3FappId%3Droslyn%26k%3Dk(CS0221)).
Так же этот тип ошибки поменялся и для строк 10 и 11. Ошибка для строки 14 осталась без изменений.

Давайте пока сосредоточим внимание на строках 12 и 13. Ведь там по существу происходит одно и тоже. Присвоение числа 196
переменной типа `sbyte` причем с приведением значения к этому типу. Почему же в одном случае есть ошибка в другом нет?
А так же рассмотрим 14 строку, так как она тоже интересна. Там ведь у нас тоже есть приведение к типу `sbyte` и кроме того

Разница между строками `c = (sbyte)intN;` и `b = (sbyte)196;` заключается в **разной обработке компилятором литералов и переменных** 
при явном приведении типов. Давайте разберём это шаг за шагом:

### 1. Проблема с литералом `196` в строке `b = (sbyte)196;`
- **Литералы в C# анализируются на этапе компиляции.**
    - Литерал `196` — это значение типа `int`.
    - Компилятор видит, что значение `196` выходит за пределы диапазона типа `sbyte` (-128...127).
    - **Ошибка компиляции** возникает сразу, так как компилятор пытается предотвратить переполнение ещё до выполнения программы.

Даже с явным приведением, как `(sbyte)196`, компилятор **не разрешает такую запись**, так как переполнение уже очевидно на этапе компиляции.

### 2. Почему строка `c = (sbyte)intN;` работает?
- **Переменная `intN` — это значение типа `int`, известное только во время выполнения программы.**
    - Компилятор не знает, чему будет равно `intN` (даже если оно объявлено как `196`).
    - Компилятор допускает явное приведение `(sbyte)intN`, полагая, что разработчик осознаёт риск переполнения.
    - Во время выполнения программы значение `196` будет преобразовано в `sbyte` с **переполнением**, результатом будет `-60`.
 
### 3. Почему компилятор ведёт себя по-разному? {id="3_1"}
Компилятор C# различает **литералы** и **переменные** для обработки явных приведений:
- Для **литералов**:
    - Если переполнение очевидно на этапе компиляции (например, `196` для типа `sbyte`), компилятор генерирует **ошибку компиляции**.
- Для **переменных**:
    - Приведение типов всегда разрешено, даже если во время выполнения это вызовет переполнение.

### 4. Почему строка `d = (sbyte)intN - 136;` выдаёт ошибку?
Эта строка более сложная:
- Оператор `-` имеет более высокий приоритет, чем приведение типа `(sbyte)`.
- Выражение `intN - 136` сначала вычисляется как **значение типа `int`**, а результатом будет `60` (тип `int`).
- Затем компилятор пытается присвоить значение `60` переменной типа `sbyte`, что вызывает ошибку, так как для приведения к `sbyte` требуется явное приведение всего выражения:
  ```c#
  d = (sbyte)(intN - 136);
  ```

### Резюме по переполнению типов
1. **Литералы** анализируются на этапе компиляции. Если значение выходит за пределы допустимого диапазона, компилятор выдаёт ошибку, даже при явном приведении.
2. **Переменные** проверяются только на этапе выполнения. Компилятор допускает приведение, даже если оно приведёт к переполнению.
3. Для сложных выражений результат промежуточных операций всегда имеет тип `int` (или более широкий тип), и приведение необходимо делать для всего выражения.

Теперь нам осталось разрешить явно переполнение в строках с 10 по 13. А 14 поправить как писалось чуть выше. Приводим программу к следующему виду:

```C#
namespace IntLiteralsDefaultVal;

class Program
{
    static sbyte a0b, a0x, b, c, d;
    static int intN = 196;

    static void Main()
    {
        a0b = unchecked((sbyte)0b1100_0100); // 196 без знаковое, -60 знаковое
        a0x = unchecked((sbyte)0xC4); // 196 без знаковое, -60 знаковое
        b = unchecked((sbyte)196);
        c = (sbyte)intN;
        d = (sbyte)(intN - 136);

        WriteLine($"{a0b} {a0x} {b} {c} {d} {intN}");
    }
}
```
Запускаем и получаем результат: `-60 -60 -60 -60 60 196`

### **Подведем итоги по целочисленным литералам:**
1. **Десятичный** литерал — это обычное число, которое мы видим в повседневной жизни.
2. **Шестнадцатеричный** и **двоичный** литералы удобны для работы с низкоуровневыми данными, такими как цвета или побитовые операции.
3. **Шестнадцатеричный** и **двоичный** литералы всегда интерпретируются компилятором как положительные числа.
4. **Разделители цифр** делают код более читаемым, особенно для больших чисел или сложных двоичных представлений.
5. **Целочисленные литералы** имеют тип **`int`** по умолчанию.
6. **Суффиксы** могут определить другие типы для литералов: `long`, `ulong` или `uint`.
7. Для литералов надо явно указывать операцию разрешения переполнения `unchecked` если это необходимо.

В этом упражнении мы затронули операцию приведения типов и явного разрешения переполнения. Узнали что такое переполнение 
и как ведет себя компилятор со всем этим добром. Могу предположить, что если вы только начинаете изучать C# это всё может
выглядеть не понятным. Просто продолжай, падаван, и свет истины откроется тебе!

## Операции над целочисленными типами
В C# над целочисленными типами возможны следующие операции:

### 1. **Арифметические операции**
- `+` (Сложение)
- `-` (Вычитание)
- `*` (Умножение)
- `/` (Деление)
- `%` (Остаток от деления)

### 2. **Инкремент и декремент**
- `++` (Инкремент — увеличение на 1, префиксный и постфиксный)
- `--` (Декремент — уменьшение на 1, префиксный и постфиксный)

### 3. **Побитовые операции**
- `&` (Побитовая И)
- `|` (Побитовая ИЛИ)
- `^` (Побитовая исключающая ИЛИ)
- `~` (Побитовое НЕ)
- `<<` (Сдвиг влево)
- `>>` (Сдвиг вправо)

### 4. **Логические операции**
Результатом логических операций над любыми типами всегда является логическое значение: `true` или `false`. 
- `==` (Равно)
- `!=` (Не равно)
- `<` (Меньше)
- `>` (Больше)
- `<=` (Меньше или равно)
- `>=` (Больше или равно)

### 5. **Операции присваивания**
- `=` (Присваивание)
- `+=` (Сложение с присваиванием)
- `-=` (Вычитание с присваиванием)
- `*=` (Умножение с присваиванием)
- `/=` (Деление с присваиванием)
- `%=` (Остаток с присваиванием)
- `&=` (Побитовая И с присваиванием)
- `|=` (Побитовая ИЛИ с присваиванием)
- `^=` (Побитовая исключающая ИЛИ с присваиванием)
- `<<=` (Сдвиг влево с присваиванием)
- `>>=` (Сдвиг вправо с присваиванием)

### 6. **Унарные операции:**
- (смена знака числа)
+ (явное указание положительного числа, редко используется)

### 7. **Приведение типов**
- Неявное приведение выполняется автоматически (меньший тип → больший):  
  Например, `int` → `long`.
- `(<type>)`Явное приведение (больший тип → меньший):  
  Например, `long` → `int`.

### 8. **Операции проверки переполнения:**
- В режиме checked генерируется исключение при переполнении.
- В режиме unchecked переполнение игнорируется.

Теперь практика по всем операциям над целочисленными типами. Создайте проект `ex0018_int_operations` при помощи 
шаблона `tinyconsole`. Добавьте его в решение `episode02.sln`. Файл `Program.cs` приведите к следующему виду:

```c#
using System;

namespace IntegerOperations;

class Program
{
    static void Main(string[] args)
    {
        // Арифметические операции
        int a = 10; // объявление переменной a и инициализация её значением 10
        int b; // объявление переменной b
        b = 3; //  присвоение переменной b значения 3
        WriteLine("Арифметические операции:");
        WriteLine($"Значения в начале демонстрации a = {a},   b = {b}");
        WriteLine($"{a} + {b} = {a + b}");
        WriteLine($"{a} - {b} = {a - b}");
        WriteLine($"{a} * {b} = {a * b}");
        WriteLine($"{a} / {b} = {a / b}");
        WriteLine($"{a} % {b} = {a % b}");
        WriteLine($"Значения в конце демонстрации a = {a},   b = {b}");

        // Инкремент и декремент
        WriteLine("\nИнкремент и декремент:");
        int c = 5;
        WriteLine($"Значение в начале демонстрации c = {c}");
        WriteLine($"Префиксный инкремент ++c: {c} -> {++c}"); // сначала применяется операция ++ потом выводится значение
        WriteLine($"Постфиксный инкремент c++: {c++} -> {c}"); // сперва выводится значение потом применяется операция ++
        WriteLine($"Префиксный декремент --c: {c} -> {--c}"); // сначала применяется операция -- потом выводится значение
        WriteLine($"Постфиксный декремент c--: {c--} -> {c}"); // сперва выводится значение потом применяется операция --
        ++c; // увеличили значение переменной c на 1
        WriteLine($"Значение в конце демонстрации c = {c}");

        // Побитовые операции
        WriteLine("\nПобитовые операции в десятичном представлении:");
        a = 5; // присвоили переменной a значение 5 в двоичном виде это 0101
        b = 3; // присвоили переменной b значение 3 в двоичном виде это 0011
        WriteLine($"Значения в начале демонстрации a = {a},   b = {b}");
        WriteLine($"{a} & {b} = {a & b}"); // 0001
        WriteLine($"{a} | {b} = {a | b}"); // 0111
        WriteLine($"{a} ^ {b} = {a ^ b}"); // 0110
        WriteLine($"~{a} = {~a}");       // ...1010 (дополнение до отрицательного числа)
        WriteLine($"{a} << 1 = {a << 1}"); // 1010
        WriteLine($"{a} >> 1 = {a >> 1}"); // 0010
        WriteLine($"Значения в конце демонстрации a = {a},   b = {b}\n");

        BitwiseOperatins.ShowInBinary(); // вызов статического метода ShowInBinary() статического класса BitwiseOperatins

        // Логические операции
        WriteLine("\nЛогические операции:");
        a = 15; // присвоили переменной a значение 15
        b = 5; // присовили переменной b значение 5
        WriteLine($"Значения в начале демонстрации a = {a},   b = {b}");
        WriteLine($"{a} == {b}: {a == b}");
        WriteLine($"{a} != {b}: {a != b}");
        WriteLine($"{a} > {b}: {a > b}");
        WriteLine($"{a} < {b}: {a < b}");
        WriteLine($"{a} >= {b}: {a >= b}");
        WriteLine($"{a} <= {b}: {a <= b}");
        WriteLine($"Значения в конце демонстрации a = {a},   b = {b}");

        // Операции присваивания
        WriteLine("\nОперации присваивания:");
        int d = 10;
        WriteLine($"Значение в начале демонстрации d = {d}");
        d += 5; WriteLine($"{d} += 5 -> {d}");
        d -= 3; WriteLine($"{d} -= 3 -> {d}");
        d *= 2; WriteLine($"{d} *= 2 -> {d}");
        d /= 4; WriteLine($"{d} /= 4 -> {d}");
        d %= 3; WriteLine($"{d} %= 3 -> {d}");
        d &= 2; WriteLine($"{d} &= 2 -> {d}");
        d |= 1; WriteLine($"{d} |= 1 -> {d}");
        d ^= 3; WriteLine($"{d} ^= 3 -> {d}");
        d <<= 2; WriteLine($"{d} <<= 2 -> {d}");
        d >>= 1; WriteLine($"{d} >>= 1 -> {d}");
        WriteLine($"Значение в конце демонстрации d = {d}");

        // Унарная операция смены знака
        WriteLine("\nУнарная операция смены знака:");
        int originalNumber = 42; // Исходное число
        int negativeNumber = -originalNumber; // Меняем знак на отрицательный        
        int positiveNumber = -negativeNumber; // Меняем знак обратно на положительный
        WriteLine($"Исходное число: {originalNumber}");
        WriteLine($"Число с отрицательным знаком: {negativeNumber}");
        WriteLine($"Число с положительным знаком: {positiveNumber}");

        // Приведение типов
        WriteLine("\nПриведение типов:");
        long bigValue = 1000L;
        int smallValue = (int)bigValue; // Явное приведение
        WriteLine($"Явное приведение: long -> int: {smallValue}");
        int value = 100;
        long largeValue = value; // Неявное приведение
        WriteLine($"Неявное приведение: int -> long: {largeValue}");

        // Операции проверки переполнения
        WriteLine("\nПроверка переполнения:");
        sbyte x = unchecked((sbyte)196); // 196 выходит за пределы диапазона sbyte
        WriteLine($"С разрешенным переполнением unchecked: x = {x}"); // Ожидается результат: -60

        // Пример с checked: будет выброшено исключение OverflowException
        WriteLine($"\nС запрещенным переполнением checked:");
        try
        {
            int z = 196;
            WriteLine($"\nz = {z}");
            sbyte y = checked((sbyte)z);
            WriteLine($"Checked: y = {y}");
        }
        catch (OverflowException ex)
        {
            WriteLine($"Checked: Переполнение типа: {ex.Message}");
        }

        try
        {
            int z = -128;
            WriteLine($"\nz = {z}");
            sbyte y = checked((sbyte)z);
            WriteLine($"Checked: y = {y}");
        }
        catch (OverflowException ex)
        {
            WriteLine($"Checked: Переполнение типа: {ex.Message}");
        }
    }
}
```

Затем в каталоге проекта `ex0018_int_operations` создайте файл `BitwiseOperations.cs` со следующим содержимым:

```C#
using System;

namespace IntegerOperations;

public static class BitwiseOperatins
{
    public static void ShowInBinary()
    {
        // Положительные переменные
        byte a = 0b0011_1100; // 60 в десятичной системе
        byte b = 0b0000_1101; // 13 в десятичной системе
        WriteLine($"a: {a} (десятичные), {Convert.ToString(a, 2).PadLeft(8, '0')} (двоичные)");
        WriteLine($"b: {b} (десятичные), {Convert.ToString(b, 2).PadLeft(8, '0')} (двоичные)");

        // Отрицательная переменная (двоичный литерал для -60)
        sbyte negA = unchecked((sbyte)0b1100_0100); // Двоичный литерал для -60
        WriteLine($"negA: {negA} (десятичные), {Convert.ToString((byte)negA, 2).PadLeft(8, '0')} (двоичные)");

        WriteLine("\n=== Побитовые операции для byte и sbyte в двоичном и десятичном представлении ===");

        // Побитовая И (AND)
        byte andResult = (byte)(a & b);
        WriteLine($"a & b: {Convert.ToString(a, 2).PadLeft(8, '0')} & {Convert.ToString(b, 2).PadLeft(8, '0')} = {Convert.ToString(andResult, 2).PadLeft(8, '0')} (двоичные), {a} & {b} = {andResult} (десятичные)");

        // Побитовая ИЛИ (OR)
        byte orResult = (byte)(a | b);
        WriteLine($"a | b: {Convert.ToString(a, 2).PadLeft(8, '0')} | {Convert.ToString(b, 2).PadLeft(8, '0')} = {Convert.ToString(orResult, 2).PadLeft(8, '0')} (двоичные), {a} | {b} = {orResult} (десятичные)");

        // Побитовая исключающая ИЛИ (XOR)
        byte xorResult = (byte)(a ^ b);
        WriteLine($"a ^ b: {Convert.ToString(a, 2).PadLeft(8, '0')} ^ {Convert.ToString(b, 2).PadLeft(8, '0')} = {Convert.ToString(xorResult, 2).PadLeft(8, '0')} (двоичные), {a} ^ {b} = {xorResult} (десятичные)");

        // Побитовая инверсия (NOT)
        byte notA = (byte)~a;
        sbyte notNegA = (sbyte)~negA;
        WriteLine($"~a: ~{Convert.ToString(a, 2).PadLeft(8, '0')} = {Convert.ToString(notA, 2).PadLeft(8, '0')} (двоичные), ~{a} = {notA} (десятичные)");
        WriteLine($"~negA: ~{Convert.ToString((byte)negA, 2).PadLeft(8, '0')} = {Convert.ToString((byte)notNegA, 2).PadLeft(8, '0')} (двоичные), ~{negA} = {notNegA} (десятичные)");

        WriteLine("\n=== Побитовые сдвиги для byte и sbyte в двоичном и десятичном представлении ===");

        // Сдвиг влево
        byte shiftLeftA = (byte)(a << 2);
        sbyte shiftLeftNegA = (sbyte)(negA << 2);
        WriteLine($"a << 2: {Convert.ToString(a, 2).PadLeft(8, '0')} << 2 = {Convert.ToString(shiftLeftA, 2).PadLeft(8, '0')} (двоичные), {a} << 2 = {shiftLeftA} (десятичные)");
        WriteLine($"negA << 2: {Convert.ToString((byte)negA, 2).PadLeft(8, '0')} << 2 = {Convert.ToString((byte)shiftLeftNegA, 2).PadLeft(8, '0')} (двоичные), {negA} << 2 = {shiftLeftNegA} (десятичные)");

        // Сдвиг вправо
        byte shiftRightA = (byte)(a >> 2);
        sbyte shiftRightNegA = (sbyte)(negA >> 2);
        WriteLine($"a >> 2: {Convert.ToString(a, 2).PadLeft(8, '0')} >> 2 = {Convert.ToString(shiftRightA, 2).PadLeft(8, '0')} (двоичные), {a} >> 2 = {shiftRightA} (десятичные)");
        WriteLine($"negA >> 2: {Convert.ToString((byte)negA, 2).PadLeft(8, '0')} >> 2 = {Convert.ToString((byte)shiftRightNegA, 2).PadLeft(8, '0')} (двоичные), {negA} >> 2 = {shiftRightNegA} (десятичные)");
    }
}
```
Структура проекта у вас должна выглядеть после этого так:

![Операции над целочисленными типами в C#](int_vars05.png){ border-effect="line"  thumbnail="true" width="700" }

Выполните наш проект. Результат должен быть таким:

```
Арифметические операции:
Значения в начале демонстрации a = 10,   b = 3
10 + 3 = 13
10 - 3 = 7
10 * 3 = 30
10 / 3 = 3
10 % 3 = 1
Значения в конце демонстрации a = 10,   b = 3

Инкремент и декремент:
Значение в начале демонстрации c = 5
Префиксный инкремент ++c: 5 -> 6
Постфиксный инкремент c++: 6 -> 7
Префиксный декремент --c: 7 -> 6
Постфиксный декремент c--: 6 -> 5
Значение в конце демонстрации c = 6

Побитовые операции в десятичном представлении:
Значения в начале демонстрации a = 5,   b = 3
5 & 3 = 1
5 | 3 = 7
5 ^ 3 = 6
~5 = -6
5 << 1 = 10
5 >> 1 = 2
Значения в конце демонстрации a = 5,   b = 3

a: 60 (десятичные), 00111100 (двоичные)
b: 13 (десятичные), 00001101 (двоичные)
negA: -60 (десятичные), 11000100 (двоичные)

=== Побитовые операции для byte и sbyte в двоичном и десятичном представлении ===
a & b: 00111100 & 00001101 = 00001100 (двоичные), 60 & 13 = 12 (десятичные)      
a | b: 00111100 | 00001101 = 00111101 (двоичные), 60 | 13 = 61 (десятичные)      
a ^ b: 00111100 ^ 00001101 = 00110001 (двоичные), 60 ^ 13 = 49 (десятичные)      
~a: ~00111100 = 11000011 (двоичные), ~60 = 195 (десятичные)
~negA: ~11000100 = 00111011 (двоичные), ~-60 = 59 (десятичные)

=== Побитовые сдвиги для byte и sbyte в двоичном и десятичном представлении ===  
a << 2: 00111100 << 2 = 11110000 (двоичные), 60 << 2 = 240 (десятичные)
negA << 2: 11000100 << 2 = 00010000 (двоичные), -60 << 2 = 16 (десятичные)       
a >> 2: 00111100 >> 2 = 00001111 (двоичные), 60 >> 2 = 15 (десятичные)
negA >> 2: 11000100 >> 2 = 11110001 (двоичные), -60 >> 2 = -15 (десятичные)      

Логические операции:
Значения в начале демонстрации a = 15,   b = 5
15 == 5: False
15 != 5: True
15 > 5: True
15 < 5: False
15 >= 5: True
15 <= 5: False
Значения в конце демонстрации a = 15,   b = 5

Операции присваивания:
Значение в начале демонстрации d = 10
15 += 5 -> 15
12 -= 3 -> 12
24 *= 2 -> 24
6 /= 4 -> 6
0 %= 3 -> 0
0 &= 2 -> 0
1 |= 1 -> 1
2 ^= 3 -> 2
8 <<= 2 -> 8
4 >>= 1 -> 4
Значение в конце демонстрации d = 4

Унарная операция смены знака:
Исходное число: 42
Число с отрицательным знаком: -42
Число с положительным знаком: 42

Приведение типов:
Явное приведение: long -> int: 1000
Неявное приведение: int -> long: 100

Проверка переполнения:
С разрешенным переполнением unchecked: x = -60

С запрещенным переполнением checked:

z = 196
Checked: Переполнение типа: Arithmetic operation resulted in an overflow.

z = -128
Checked: y = -128
```
Не пугайтесь если вам не всё понятно. Это нормально. Особенно в файле `BitwiseOperations.cs`. Там много магии силы. Хотя
на самом деле там ни чего сложного нет, просто форматирование вывода. Чтобы красиво было. Сейчас постараюсь всё объяснить.

Давайте разберем первый блок где выполняются арифметические операции.

![Операции над целочисленными типами в C#](int_vars06.png){ border-effect="line"  thumbnail="true" width="700" }

Этот код демонстрирует базовые арифметические операции в языке C#. Рассмотрим его работу и особенности.

### **Что делает код:**

1. **Объявление и инициализация переменных:**
    - Переменная `a` объявлена и сразу инициализирована значением `10`:
      ```c#
      int a = 10;
      ```
      Это называется **объявление с инициализацией**.
    - Переменная `b` сначала объявлена:
      ```c#
      int b;
      ```
      А затем ей присвоено значение `3`:
      ```c#
      b = 3;
      ```
      Это называется **объявление без инициализации**.

2. **Вывод исходных значений:**
    - Вывод текста с начальным значением переменных:
      ```c#
      WriteLine($"Значения в начале демонстрации a = {a},   b = {b}");
      ```
      Интерполяция строки (строке предшествует знак `$`) (`$"..."`) используется для динамической вставки значений переменных `a` и `b` в текст.

3. **Арифметические операции:**
    - Выполняются базовые операции: сложение (`+`), вычитание (`-`), умножение (`*`), деление (`/`), и остаток от деления (`%`).
    - Результаты каждой операции выводятся с помощью команды (пример для операции сложения):
      ```c#
      WriteLine($"{a} + {b} = {a + b}");
      ```
      Здесь значения `a` и `b` подставляются в строку, а выражение `a + b` вычисляется и отображается как результат.

4. **Вывод конечных значений переменных:**
    - В конце демонстрации выводятся значения переменных `a` и `b`:
      ```c#
      WriteLine($"Значения в конце демонстрации a = {a},   b = {b}");
      ```
      Они остаются неизменными, так как в процессе выполнения операций их значения не перезаписываются.

### **Почему переменные `a` и `b` не изменились?**
- Все арифметические операции выполняются с использованием значений `a` и `b`, но **результаты этих операций нигде не сохраняются**.
- Например:
  ```c#
  a + b;
  ```
  Этот результат вычисляется и сразу передается в метод `WriteLine` для вывода, но переменные `a` и `b` остаются без изменений.

### **Как происходит вычисление и вывод результата?**

1. **Вычисление:**
    - Например, для строки:
      ```c#
      WriteLine($"{a} + {b} = {a + b}");
      ```
      Сначала выполняются следующие шаги:
        - Берется текущее значение `a` (10) и `b` (3).
        - Производится сложение `10 + 3`, результат — `13`.
    - Затем результат подставляется в строку.

2. **Вывод:**
    - Метод `WriteLine` выводит текст в консоль. Строка, переданная в метод, формируется с использованием интерполяции (`$"..."`), 
    - где значения переменных и результаты операций подставляются в указанные места в строке.

### **Разница между операторами `/` и `%`:**
1. **`/` — деление (division):**
    - Делит одно число на другое и возвращает **целую часть результата** (для целых чисел).
    - Например:
      ```c#
      10 / 3 → 3
      ```
      Дробная часть (остаток) отбрасывается.

2. **`%` — остаток от деления (modulus):**
    - Возвращает **остаток от деления**.
    - Например:
      ```c#
      10 % 3 → 1
      ```
      Это остаток, который остается после выполнения целого деления.

### **Пример вывода в консоли:**
```
Арифметические операции:
Значения в начале демонстрации a = 10,   b = 3
10 + 3 = 13
10 - 3 = 7
10 * 3 = 30
10 / 3 = 3
10 % 3 = 1
Значения в конце демонстрации a = 10,   b = 3
```

### **Резюме:**
1. Переменные `a` и `b` не изменяются, так как операции не изменяют их значения.
2. Арифметические операции выполняются с текущими значениями `a` и `b`, результаты сразу передаются в метод `WriteLine`.
3. Операторы `/` и `%` работают с целочисленным делением: `/` возвращает целую часть, `%` — остаток.

Надеюсь с этим самым простым блоком операций всё понятно, падаван.

Теперь разберем следующий блок с инкрементом и декрементом.

![Операции над целочисленными типами в C#](int_vars07.png){ border-effect="line"  thumbnail="true" width="700" }

Этот код демонстрирует два вида операций инкремента (`++`) и декремента (`--`) в C# и объясняет их различия. Рассмотрим работу кода и разберем особенности.

### **Инкремент и декремент:**
Инкремент (`++`) увеличивает значение переменной на единицу.  
Декремент (`--`) уменьшает значение переменной на единицу.

Обе операции бывают **префиксными** и **постфиксными**, что определяет порядок выполнения операции относительно 
использования значения переменной.

### **Различия между префиксным и постфиксным инкрементом/декрементом:**

1. **Префиксный инкремент/декремент (`++c` или `--c`):**
    - Операция выполняется **до** использования значения переменной.
    - Сначала значение переменной изменяется, а затем используется в выражении.

2. **Постфиксный инкремент/декремент (`c++` или `c--`):**
    - Операция выполняется **после** использования значения переменной.
    - Сначала используется текущее значение переменной в выражении, а затем оно изменяется.

### **Разбор работы кода:**

1. **Начальное значение переменной:**
   ```c#
   int c = 5;
   WriteLine($"Значение в начале демонстрации c = {c}");
   ```
   Переменная `c` инициализирована значением `5`. Это значение выводится в консоль.

2. **Префиксный инкремент:**
   ```c#
   WriteLine($"Префиксный инкремент ++c: {c} -> {++c}");
   ```
    - Сначала переменная `c` увеличивается на 1 (становится `6`).
    - Затем новое значение (`6`) используется для вывода.
    - Результат:
      ```
      Префиксный инкремент ++c: 5 -> 6
      ```

3. **Постфиксный инкремент:**
   ```c#
   WriteLine($"Постфиксный инкремент c++: {c++} -> {c}");
   ```
    - Сначала используется текущее значение переменной `c` (это `6`).
    - Затем `c` увеличивается на 1 (становится `7`).
    - Результат:
      ```
      Постфиксный инкремент c++: 6 -> 7
      ```

4. **Префиксный декремент:**
   ```c#
   WriteLine($"Префиксный декремент --c: {c} -> {--c}");
   ```
    - Сначала `c` уменьшается на 1 (становится `6`).
    - Затем новое значение (`6`) используется для вывода.
    - Результат:
      ```
      Префиксный декремент --c: 7 -> 6
      ```

5. **Постфиксный декремент:**
   ```c#
   WriteLine($"Постфиксный декремент c--: {c--} -> {c}");
   ```
    - Сначала используется текущее значение переменной `c` (это `6`).
    - Затем `c` уменьшается на 1 (становится `5`).
    - Результат:
      ```
      Постфиксный декремент c--: 6 -> 5
      ```

6. **Увеличение переменной вне вывода:**
   ```c#
   ++c;
   ```
    - Префиксный инкремент увеличивает `c` на 1 (становится `6`).

7. **Конечное значение переменной:**
   ```c#
   WriteLine($"Значение в конце демонстрации c = {c}");
   ```
    - Выводится итоговое значение `c`, равное `6`.

### **Почему значение переменной `c` меняется?** {id="c_1"}
Операции `++` и `--` непосредственно изменяют значение переменной `c`.  
Каждый вызов этих операций:
- Увеличивает (`++`) или уменьшает (`--`) значение переменной.
- Это изменение записывается в переменную, поэтому её значение обновляется.

### **Пример вывода в консоли:**
```
Инкремент и декремент:
Значение в начале демонстрации c = 5
Префиксный инкремент ++c: 5 -> 6
Постфиксный инкремент c++: 6 -> 7
Префиксный декремент --c: 7 -> 6
Постфиксный декремент c--: 6 -> 5
Значение в конце демонстрации c = 6
```

### **Резюме:**
1. Префиксный инкремент/декремент изменяет значение **до** использования переменной.
2. Постфиксный инкремент/декремент изменяет значение **после** использования переменной.
3. Изменение переменной сохраняется, поскольку операции `++` и `--` напрямую модифицируют значение переменной в памяти.

Теперь рассмотрим блок с побитовыми операциями.

![Операции над целочисленными типами в C#](int_vars08.png){ border-effect="line"  thumbnail="true" width="700" }

Побитовые операции в программировании позволяют работать с числами на уровне их двоичного представления (нолей и единиц). Давайте разберем приведенный код и подробно объясним, как он работает.

### **Исходные данные:**
1. `a = 5`
    - В двоичном виде: `0101` (четыре бита).
2. `b = 3`
    - В двоичном виде: `0011`.

Эти числа будут использоваться для выполнения различных побитовых операций.

### **Побитовые операции:**

#### 1. **Логическое "И" (`&`)** {id="1_1"}
```c
WriteLine($"{a} & {b} = {a & b}");
```
- Операция `&` берет каждый бит двух чисел и выполняет логическое "И":
    - Результат будет `1`, только если оба соответствующих бита равны `1`.
    - В противном случае — `0`.

- Пример:
  ```
  a: 0101
  b: 0011
  --------
  & : 0001
  ```
- В десятичном виде: `0001` = `1`.

**Результат:** `5 & 3 = 1`.

#### 2. **Логическое "ИЛИ" (`|`)** {id="2_1"}
```c#
WriteLine($"{a} | {b} = {a | b}");
```
- Операция `|` берет каждый бит двух чисел и выполняет логическое "ИЛИ":
    - Результат будет `1`, если хотя бы один из соответствующих битов равен `1`.

- Пример:
  ```
  a: 0101
  b: 0011
  --------
  | : 0111
  ```
- В десятичном виде: `0111` = `7`.

**Результат:** `5 | 3 = 7`.

#### 3. **Логическое "Исключающее ИЛИ" (`^`)** {id="3_2"}
```c#
WriteLine($"{a} ^ {b} = {a ^ b}");
```
- Операция `^` (исключающее ИЛИ) берет каждый бит двух чисел и выполняет сравнение:
    - Результат будет `1`, только если биты различны (один равен `1`, другой — `0`).
    - Если оба бита одинаковы (оба `1` или оба `0`), результат будет `0`.

- Пример:
  ```
  a: 0101
  b: 0011
  --------
  ^ : 0110
  ```
- В десятичном виде: `0110` = `6`.

**Результат:** `5 ^ 3 = 6`.

#### 4. **Побитовая инверсия (`~`)** {id="4_1"}
```c#
WriteLine($"~{a} = {~a}");
```
- Операция `~` инвертирует все биты числа:
    - `0` становится `1`, а `1` становится `0`.

Для понимания результата нужно учитывать, что числа в компьютере хранятся в виде **дополнительного кода**. 
В 32-битной системе, инверсия числа `a` работает так:

- Число `5` в двоичном виде (32 бита):
  ```
  00000000 00000000 00000000 00000101
  ```
- Инверсия:
  ```
  11111111 11111111 11111111 11111010
  ```
- Это представление отрицательного числа, равного `-6` в десятичной системе.

**Результат:** `~5 = -6`.

#### 5. **Сдвиг влево (`<<`)** {id="5_1"}
```c#
WriteLine($"{a} << 1 = {a << 1}");
```
- Операция `<<` сдвигает все биты числа влево на указанное количество позиций.
    - Освободившиеся справа биты заполняются нулями.

- Пример (сдвиг на 1 позицию):
  ```
  a: 0101 (5)
  << : 1010 (10)
  ```
- В десятичном виде: `1010` = `10`.

**Результат:** `5 << 1 = 10`.

#### 6. **Сдвиг вправо (`>>`)** {id="6_1"}
```c#
WriteLine($"{a} >> 1 = {a >> 1}");
```
- Операция `>>` сдвигает все биты числа вправо на указанное количество позиций.
    - Освободившиеся слева биты заполняются нулями (для положительных чисел).

- Пример (сдвиг на 1 позицию):
  ```
  a: 0101 (5)
  >> : 0010 (2)
  ```
- В десятичном виде: `0010` = `2`.

**Результат:** `5 >> 1 = 2`.

### **Результаты в консоли:**
```
Побитовые операции в десятичном представлении:
Значения в начале демонстрации a = 5,   b = 3
5 & 3 = 1
5 | 3 = 7
5 ^ 3 = 6
~5 = -6
5 << 1 = 10
5 >> 1 = 2
Значения в конце демонстрации a = 5,   b = 3
```

### **Ключевые моменты для понимания:**
1. **Побитовые операции работают на уровне битов чисел.**  
   Они выполняют операции над каждым битом отдельно.

2. **Числа хранятся в двоичном виде.**  
   Поэтому для понимания операций удобно переводить числа в двоичное представление.

3. **Сдвиговые операции меняют расположение битов.**
    - Сдвиг влево увеличивает число вдвое за каждую позицию.
    - Сдвиг вправо уменьшает число вдвое за каждую позицию.

4. **Инверсия использует дополнительный код для отрицательных чисел.**  
   Поэтому результат инверсии положительного числа становится отрицательным.

5. **Операции не изменяют исходные переменные.**  
   В конце демонстрации `a` и `b` остаются равны своим начальным значениям (`5` и `3`).


Теперь рассмотрим блок с логическими операциями.

![Операции над целочисленными типами в C#](int_vars09.png){ border-effect="line"  thumbnail="true" width="700" }

Давайте разберем построчно, что делает этот код. Я объясню все операции максимально просто, чтобы было понятно даже школьнику.

### 1. **`WriteLine("\nЛогические операции:");`**
Эта строка выводит заголовок "Логические операции" и переносит строку перед ним (символ `\n` означает новую строку). 
Это сделано для того, чтобы было видно, что начинается новая часть программы.

### 2. **`a = 15;`**
Здесь переменной `a` присваивается значение `15`. Переменная — это как коробка, в которую кладут число. 
Теперь в коробке `a` лежит число `15`.

### 3. **`b = 5;`**
Точно так же переменной `b` присваивается значение `5`. Теперь в коробке `b` лежит число `5`.

### 4. **`WriteLine($"Значения в начале демонстрации a = {a},   b = {b}");`**
Эта строка выводит текущие значения переменных `a` и `b`.  
Шаблон `{$a}` означает, что вместо `{a}` подставляется текущее значение переменной `a`.  
Результат будет:
```
Значения в начале демонстрации a = 15,   b = 5
```

### 5. **`WriteLine($"{a} == {b}: {a == b}");`**
- Операция `==` сравнивает два числа и проверяет, равны ли они.
- Если `a` равно `b`, результат будет `True` (истина).  
  Если не равно — `False` (ложь).
- В данном случае `15 == 5` — это **ложь**, поэтому вывод будет:
```
15 == 5: False
```

### 6. **`WriteLine($"{a} != {b}: {a != b}");`**
- Операция `!=` проверяет, НЕ равны ли два числа.
- Если числа разные, результат будет `True`. Если одинаковые — `False`.
- Здесь `15 != 5` — это **истина**, поэтому вывод будет:
```
15 != 5: True
```

### 7. **`WriteLine($"{a} > {b}: {a > b}");`**
- Операция `>` проверяет, больше ли `a`, чем `b`.
- Здесь `15 > 5` — это **истина**, поэтому вывод будет:
```
15 > 5: True
```

### 8. **`WriteLine($"{a} < {b}: {a < b}");`**
- Операция `<` проверяет, меньше ли `a`, чем `b`.
- Здесь `15 < 5` — это **ложь**, поэтому вывод будет:
```
15 < 5: False
```

### 9. **`WriteLine($"{a} >= {b}: {a >= b}");`**
- Операция `>=` проверяет, больше ли `a` или равно `b`.
- Здесь `15 >= 5` — это **истина**, потому что `15` больше `5`. Вывод:
```
15 >= 5: True
```

### 10. **`WriteLine($"{a} <= {b}: {a <= b}");`**
- Операция `<=` проверяет, меньше ли `a` или равно `b`.
- Здесь `15 <= 5` — это **ложь**, потому что `15` не меньше и не равно `5`. Вывод:
```
15 <= 5: False
```

### 11. **`WriteLine($"Значения в конце демонстрации a = {a},   b = {b}");`**
Эта строка снова выводит значения переменных `a` и `b`.  
Важно отметить, что логические операции **не меняют значения переменных**, они только проверяют их.  
Результат:
```
Значения в конце демонстрации a = 15,   b = 5
```

Теперь так же подробно рассмотрим блок с операциями присваивания.

![Операции над целочисленными типами в C#](int_vars10.png){ border-effect="line"  thumbnail="true" width="700" }

Обратите внимание, что в данном блоке кода на одной строке располагается сразу две инструкции разделенные знаком окончания
инструкции `;`. Так тоже можно записывать код, если это делает его удобочитаемым. Ну и теперь пройдемся по каждой строке.

### 1. **`WriteLine("\nОперации присваивания:");`** {id="1-writeline-n_1"}
- Эта строка выводит заголовок "Операции присваивания" и переносит строку перед ним (символ `\n` означает новую строку). Это нужно, чтобы читателю программы было видно, что начинается новый блок операций.

### 2. **`int d = 10;`**
- Создаем переменную `d` и кладем в нее число `10`.  
  Это как коробка с именем `d`, в которую мы положили число `10`.

### 3. **`WriteLine($"Значение в начале демонстрации d = {d}");`**
- Выводим текущее значение переменной `d`.  
  Результат будет:
  ```
  Значение в начале демонстрации d = 10
  ```

### 4. **`d += 5; WriteLine($"{d} += 5 -> {d}");`**
- Операция `+=` добавляет к переменной `d` число `5` и сохраняет результат в `d`.  
  То есть, `d = d + 5`.  
  Было `10`, добавили `5`, стало `15`.  
  Вывод:
  ```
  15 += 5 -> 15
  ```

### 5. **`d -= 3; WriteLine($"{d} -= 3 -> {d}");`**
- Операция `-=` уменьшает переменную `d` на `3`.  
  То есть, `d = d - 3`.  
  Было `15`, вычли `3`, стало `12`.  
  Вывод:
  ```
  12 -= 3 -> 12
  ```

### 6. **`d *= 2; WriteLine($"{d} *= 2 -> {d}");`**
- Операция `*=` умножает `d` на `2`.  
  То есть, `d = d * 2`.  
  Было `12`, умножили на `2`, стало `24`.  
  Вывод:
  ```
  24 *= 2 -> 24
  ```

### 7. **`d /= 4; WriteLine($"{d} /= 4 -> {d}");`**
- Операция `/=` делит `d` на `4`.  
  То есть, `d = d / 4`.  
  Было `24`, разделили на `4`, стало `6`.  
  Вывод:
  ```
  6 /= 4 -> 6
  ```

### 8. **`d %= 3; WriteLine($"{d} %= 3 -> {d}");`**
- Операция `%=` находит остаток от деления `d` на `3`.  
  То есть, `d = d % 3`.  
  Остаток от деления `6` на `3` равен `0`.  
  Вывод:
  ```
  0 %= 3 -> 0
  ```

### 9. **`d &= 2; WriteLine($"{d} &= 2 -> {d}");`**
- Операция `&=` выполняет побитовое И с числом `2`.  
  В двоичном виде: `d = d & 2`.  
  Было `0` (двоично `0000`) и `2` (двоично `0010`). Побитовое И оставляет только те биты, которые равны `1` в обоих числах.  
  Результат: `0000` (десятично `0`).  
  Вывод:
  ```
  0 &= 2 -> 0
  ```

### 10. **`d |= 1; WriteLine($"{d} |= 1 -> {d}");`**
- Операция `|=` выполняет побитовое ИЛИ с числом `1`.  
  В двоичном виде: `d = d | 1`.  
  Было `0` (двоично `0000`) и `1` (двоично `0001`). Побитовое ИЛИ устанавливает бит в `1`, если хотя бы один бит равен `1`.  
  Результат: `0001` (десятично `1`).  
  Вывод:
  ```
  1 |= 1 -> 1
  ```

### 11. **`d ^= 3; WriteLine($"{d} ^= 3 -> {d}");`**
- Операция `^=` выполняет побитовое исключающее ИЛИ (XOR) с числом `3`.  
  В двоичном виде: `d = d ^ 3`.  
  Было `1` (двоично `0001`) и `3` (двоично `0011`). Исключающее ИЛИ оставляет `1`, если биты разные.  
  Результат: `0010` (десятично `2`).  
  Вывод:
  ```
  2 ^= 3 -> 2
  ```

### 12. **`d <<= 2; WriteLine($"{d} <<= 2 -> {d}");`**
- Операция `<<=` сдвигает биты в числе `d` влево на `2` позиции.  
  В двоичном виде: `d = d << 2`.  
  Было `2` (двоично `0010`). Сдвигаем влево на 2 бита: `1000`.  
  Результат: `8` (десятично).  
  Вывод:
  ```
  8 <<= 2 -> 8
  ```

### 13. **`d >>= 1; WriteLine($"{d} >>= 1 -> {d}");`**
- Операция `>>=` сдвигает биты в числе `d` вправо на `1` позицию.  
  В двоичном виде: `d = d >> 1`.  
  Было `8` (двоично `1000`). Сдвигаем вправо на 1 бит: `0100`.  
  Результат: `4` (десятично).  
  Вывод:
  ```
  4 >>= 1 -> 4
  ```

### 14. **`WriteLine($"Значение в конце демонстрации d = {d}");`**
- Выводим финальное значение переменной `d`.  
  Результат:
  ```
  Значение в конце демонстрации d = 4
  ```

Теперь переходим к унарной операции смены знака.

![Операции над целочисленными типами в C#](int_vars11.png){ border-effect="line"  thumbnail="true" width="700" }

Давай разберём код построчно, чтобы всё стало понятно даже самому начинающему падвану:

```c#
// Унарная операция смены знака
WriteLine("\nУнарная операция смены знака:");
```
- **`//`**: Это комментарий. Он объясняет, что будет делаться дальше, но не выполняется компьютером. Здесь говорится, что дальше используется "унарная операция смены знака".
- **`WriteLine("\nУнарная операция смены знака:");`**: Эта команда выводит на экран текст "Унарная операция смены знака:" и добавляет пустую строку перед ним (`\n` делает переход на новую строку).

```c#
int originalNumber = 42; // Исходное число
```
- **`int`**: Это тип данных, который означает целое число.
- **`originalNumber`**: Это имя переменной, в которую мы сохраняем значение.
- **`42`**: Это значение, которое мы сохраняем в переменной `originalNumber`.
- **`// Исходное число`**: Комментарий, поясняющий, что это число будет нашим "исходным".

```c#
int negativeNumber = -originalNumber; // Меняем знак на отрицательный
```
- **`negativeNumber`**: Это новая переменная для хранения числа с отрицательным знаком.
- **`-originalNumber`**: Мы берём переменную `originalNumber` (в которой 42) и добавляем перед ней знак "минус", чтобы сделать её отрицательной. Теперь в `negativeNumber` хранится значение `-42`.

```c#
int positiveNumber = -negativeNumber; // Меняем знак обратно на положительный
```
- **`positiveNumber`**: Ещё одна новая переменная.
- **`-negativeNumber`**: Мы берём переменную `negativeNumber` (в которой `-42`) и снова добавляем перед ней знак "минус". Два минуса подряд дают положительное число, поэтому результат будет `42`.

```c#
WriteLine($"Исходное число: {originalNumber}");
```
- Эта строка выводит на экран текст "Исходное число: " и добавляет значение переменной `originalNumber` (то есть `42`).

```c#
WriteLine($"Число с отрицательным знаком: {negativeNumber}");
```
- Эта строка выводит текст "Число с отрицательным знаком: " и значение переменной `negativeNumber` (то есть `-42`).

```c#
WriteLine($"Число с положительным знаком: {positiveNumber}");
```
- Эта строка выводит текст "Число с положительным знаком: " и значение переменной `positiveNumber` (то есть `42`).

### Результат программы:
На экране будет напечатано:
```
Унарная операция смены знака:
Исходное число: 42
Число с отрицательным знаком: -42
Число с положительным знаком: 42
```

Рассмотрим блок приведения типов.

![Операции над целочисленными типами в C#](int_vars12.png){ border-effect="line"  thumbnail="true" width="700" }

### Что такое приведение типов?

**Приведение типов** — это преобразование значения из одного типа данных в другой. Тип данных определяет, какую информацию может хранить переменная (например, целые числа, дробные числа или текст). Иногда при программировании возникает необходимость изменить тип данных, чтобы выполнять операции между разными типами или использовать значения в нужном контексте.

---

### Для чего нужно приведение типов?

1. **Сложение разных типов данных.** Например, складывать целые числа (`int`) и дробные числа (`float`).
2. **Экономия памяти.** Например, преобразование большого типа (`long`) в меньший (`int`), если точность данных позволяет это.
3. **Совместимость.** Некоторые функции или структуры данных могут принимать только определённые типы, поэтому данные приходится преобразовывать.

---

### Разница между явным и неявным приведением типов

1. **Неявное приведение (implicit casting):**
    - Происходит **автоматически**.
    - Используется, когда преобразование безопасно, и данных не теряется.
    - Например, преобразование `int` в `long` (целое число меньшего типа в больший).

   ```c#
   int smallNumber = 42;
   long bigNumber = smallNumber; // Неявное приведение
   ```

2. **Явное приведение (explicit casting):**
    - Должно быть указано **явно** программистом.
    - Используется, когда возможна **потеря данных** или это небезопасное преобразование.
    - Например, преобразование `double` в `int` (дробные данные отбрасываются).

   ```c#
   double pi = 3.14;
   int wholePart = (int)pi; // Явное приведение
   ```

### Когда происходит автоматическое приведение типов?

1. **Меньший тип в больший:**
    - Например, `int` → `long`, `float` → `double`.
2. **При математических операциях с разными типами:**
    - Например, `int` + `double` → результат будет `double`.

### Разбор кода

Теперь давай разберём предоставленный код построчно.

```c#
// Приведение типов
WriteLine("\nПриведение типов:");
```
- **`// Приведение типов`**: Это комментарий, который объясняет, что данный блок кода демонстрирует примеры приведения типов.
- **`WriteLine("\nПриведение типов:");`**: Эта строка выводит текст "Приведение типов:" с переходом на новую строку перед ним (`\n`).

```c#
long bigValue = 1000L;
```
- **`long`**: Это тип данных для больших целых чисел.
- **`bigValue`**: Имя переменной.
- **`1000L`**: Значение 1000, буква `L` указывает, что это значение типа `long`.

```c#
int smallValue = (int)bigValue; // Явное приведение
```
- **`int smallValue`**: Создаём переменную `smallValue` типа `int`, которая хранит меньшие целые числа.
- **`(int)bigValue`**: Приводим значение из типа `long` в тип `int`. Здесь нужно явное приведение, так как `long` может хранить больше данных, чем `int`, и часть информации может потеряться (например, если значение больше, чем может вместить `int`).

```c#
WriteLine($"Явное приведение: long -> int: {smallValue}");
```
- **`WriteLine`**: Эта строка выводит текст "Явное приведение: long -> int: " и значение переменной `smallValue` (в данном случае `1000`).

```c#
int value = 100;
```
- **`int value`**: Создаём переменную `value` типа `int` и присваиваем ей значение `100`.

```c#
long largeValue = value; // Неявное приведение
```
- **`long largeValue`**: Создаём переменную `largeValue` типа `long`.
- **`value`**: Переменная `value` автоматически преобразуется из типа `int` в тип `long`, так как `long` больше `int`, и такое преобразование безопасно (не теряется информация).

```c#
WriteLine($"Неявное приведение: int -> long: {largeValue}");
```
- Эта строка выводит текст "Неявное приведение: int -> long: " и значение переменной `largeValue` (в данном случае `100`).

### Итоговый результат программы:
На экране будет напечатано:
```
Приведение типов:
Явное приведение: long -> int: 1000
Неявное приведение: int -> long: 100
```

### Дополнительный пример с потерей данных

```c#
double largeNumber = 123.456;
int smallNumber = (int)largeNumber; // Дробная часть потеряется
Console.WriteLine(smallNumber); // Выведет 123
```

Здесь дробная часть (`.456`) теряется, потому что тип `int` хранит только целые числа. Это пример, где при явном приведении 
происходит потеря данных.

Осталось рассмотреть последний блок операций проверки переполнения типа.

![Операции над целочисленными типами в C#](int_vars13.png){ border-effect="line"  thumbnail="true" width="700" }

### Что такое переполнение типа?

**Переполнение типа** происходит, когда значение выходит за пределы диапазона, который может хранить переменная данного 
типа. Например, тип `sbyte` может хранить числа от **-128** до **127**. Если попытаться присвоить значение, превышающее 
этот диапазон, происходит переполнение.

#### Пример переполнения:
```c#
sbyte a = 127; // Максимальное значение для sbyte
a = (sbyte)(a + 1); // Переполнение: значение становится -128
Console.WriteLine(a); // Вывод: -128
```

При переполнении:
1. **В режиме `unchecked` (по умолчанию):** значение "оборачивается", как если бы числа шли по кругу.
2. **В режиме `checked`:** выбрасывается исключение `OverflowException`, указывающее на ошибку.

### Что такое исключения и как происходит их обработка?

**Исключение** — это ошибка, которая возникает при выполнении программы. Например, попытка деления на ноль или переполнение типа может привести к исключению. В C# такие ситуации можно **обрабатывать**, чтобы программа не завершалась аварийно.

#### Обработка исключений:
- Для обработки используется блоки **`try`** и **`catch`**:
    - **`try`**: в этом блоке размещается код, где может возникнуть ошибка.
    - **`catch`**: в этом блоке описывается, что делать, если ошибка произошла.

#### Пример:
```c#
try
{
    int result = 10 / 0; // Деление на ноль вызовет исключение
}
catch (DivideByZeroException ex)
{
    Console.WriteLine($"Ошибка: {ex.Message}");
}
```

### Разбор кода построчно

```c#
// Операции проверки переполнения
WriteLine("\nПроверка переполнения:");
```
- **`//`**: Комментарий, поясняющий, что этот блок кода демонстрирует работу с переполнением типов.
- **`WriteLine`**: Печатает текст "Проверка переполнения:" с переходом на новую строку.

```c#
sbyte x = unchecked((sbyte)196); // 196 выходит за пределы диапазона sbyte
```
- **`sbyte`**: Тип данных для хранения целых чисел от -128 до 127.
- **`unchecked`**: Указывает, что переполнение разрешено, и никаких ошибок не будет.
- **`(sbyte)196`**: Преобразуем число 196 в тип `sbyte`. Это значение превышает максимальный диапазон, поэтому происходит **оборачивание**. Результат: 196 - 256 = -60.

```c#
WriteLine($"С разрешенным переполнением unchecked: x = {x}"); // Ожидается результат: -60
```
- Выводит текст "С разрешенным переполнением unchecked: x = -60".

```c#
WriteLine($"\nС запрещенным переполнением checked:");
```
- Выводит текст "С запрещенным переполнением checked:".

#### Первый блок try: {id="try_1"}

```c#
try
{
    int z = 196;
    WriteLine($"\nz = {z}");
    sbyte y = checked((sbyte)z);
    WriteLine($"Checked: y = {y}");
}
catch (OverflowException ex)
{
    WriteLine($"Checked: Переполнение типа: {ex.Message}");
}
```

1. **`try`**: Начало блока, в котором код проверяется на переполнение.
2. **`int z = 196;`**: Создаётся переменная `z` типа `int` со значением 196.
3. **`WriteLine($"\nz = {z}");`**: Печатает значение переменной `z`.
4. **`checked((sbyte)z)`**: Преобразует `z` в тип `sbyte` с проверкой на переполнение. Поскольку 196 выходит за диапазон `sbyte`, выбрасывается исключение `OverflowException`.
5. **`catch (OverflowException ex)`**: Перехватывает исключение и выводит сообщение об ошибке.

#### Второй блок `try`:

```c#
try
{
    int z = -128;
    WriteLine($"\nz = {z}");
    sbyte y = checked((sbyte)z);
    WriteLine($"Checked: y = {y}");
}
catch (OverflowException ex)
{
    WriteLine($"Checked: Переполнение типа: {ex.Message}");
}
```

1. **`int z = -128;`**: Присваиваем значение `-128`, которое находится в допустимом диапазоне `sbyte`.
2. **`checked((sbyte)z)`**: Преобразуем значение в `sbyte`. Здесь переполнения **не происходит**, так как значение в диапазоне.
3. **Результат: успешно преобразуется и выводится значение -128.**

### Итоговый результат выполнения кода:

1. Для `unchecked`:
   ```
   С разрешенным переполнением unchecked: x = -60
   ```

2. Для первого блока `try`:
   ```
   С запрещенным переполнением checked:
   z = 196
   Checked: Переполнение типа: Значение было недопустимо для sbyte.
   ```

3. Для второго блока `try`:
   ```
   z = -128
   Checked: y = -128
   ```

### Итог:
- **`unchecked`** используется, если переполнение допустимо и нужно оборачивание значений.
- **`checked`** используется для проверки ошибок переполнения, чтобы избежать неожиданного поведения.

## Зоны видимости переменных

**Зона видимости** переменной определяет, где в коде можно использовать эту переменную. В C# зоны видимости зависят от того, 
где и как объявлена переменная. Основные зоны видимости:

1. **Переменные уровня метода** (локальные переменные):
    - Объявляются внутри метода (например, внутри `Main`).
    - Доступны только внутри того блока `{ }`, где они объявлены.
    - Когда блок заканчивается, переменная уничтожается, и её имя можно использовать снова.

2. **Переменные уровня класса** (поля класса):
    - Объявляются в теле класса, но вне методов.
    - Доступны из всех методов данного класса (если позволяет модификатор доступа).

3. **Переменные уровня блока**:
    - Объявляются внутри любого блока кода `{ }`.
    - Их зона видимости ограничена этим блоком.

### Почему переменная `z` была объявлена два раза?

В коде есть два блока `try`, каждый из которых имеет свои `{ }`. Переменная `z` объявлена внутри каждого блока:

1. **В первом блоке `try`:**
   ```c#
   try
   {
       int z = 196; // Объявление переменной z
   }
   ```

2. **Во втором блоке `try`:**
   ```c#
   try
   {
       int z = -128; // Объявление переменной z
   }
   ```

Эти два блока независимы друг от друга, и у каждой переменной `z` своя **зона видимости**. Переменная из одного блока 
недоступна в другом. Именно поэтому оба раза можно использовать одно и то же имя переменной `z`, и это не вызывает конфликта.

### Пример для понимания зон видимости

Рассмотрим простой пример:

```c#
{
    int a = 10; // Переменная a доступна только внутри этих { }
    {
        int a = 20; // Ошибка! Переменная a уже существует в родительском блоке
    }
    int b = 30; // b существует только в этом блоке
}
{
    int a = 40; // Это разрешено, так как новый блок не знает о переменной a из предыдущего
}
```

Здесь:
- Вложенные блоки не могут объявить переменную с тем же именем, что и во внешнем блоке.
- После завершения блока его переменные уничтожаются, и их имена можно использовать снова.

### Заключение по коду

Переменная `z` объявлена дважды, потому что:
1. Первая `z` находится в зоне видимости первого блока `try`.
2. Вторая `z` находится в зоне видимости второго блока `try`.
3. Эти зоны видимости независимы, поэтому ошибки нет.

### Дополнительное объяснение с использованием примера:

Представьте, что вы работаете на двух разных рабочих столах. На каждом столе лежат отдельные ящики с названием "z".
Вы можете использовать ящик с этим названием на любом из столов, потому что они существуют в разных местах и не пересекаются. 
Так же работают зоны видимости в программировании: каждая переменная ограничена своим "столом" (блоком `{ }`).

## Арность операторов

**Арность** (или **операндность**) — это количество **операндов**, которые принимает оператор. 
В C# операторы классифицируются по числу операндов:

1. **Унарные операторы** (1 операнд)
2. **Бинарные операторы** (2 операнда)
3. **Тернарные операторы** (3 операнда)

### 1. **Унарные операторы** (1 операнд)

Унарные операторы работают только с одним операндом.  
Примеры в C#:
- **Смена знака:** `-`
- **Инкремент и декремент:** `++` и `--`
- **Логическое отрицание:** `!`
- **Побитовое отрицание:** `~`

**Пример:**
```c#
int a = 5;
int b = -a; // Унарный оператор смены знака
a++;        // Унарный оператор инкремента
bool isTrue = false;
bool isFalse = !isTrue; // Унарное логическое отрицание
```

**Объяснение:**
- `-a` меняет знак числа `a` на противоположный.
- `a++` увеличивает значение `a` на 1.
- `!isTrue` меняет значение `false` на `true`.

### 2. **Бинарные операторы** (2 операнда)

Бинарные операторы работают с двумя операндами.  
Примеры в C#:
- **Арифметические:** `+`, `-`, `*`, `/`, `%`
- **Сравнения:** `==`, `!=`, `<`, `>`, `<=`, `>=`
- **Логические:** `&&`, `||`
- **Побитовые:** `&`, `|`, `^`, `<<`, `>>`
- **Присваивание:** `=`, `+=`, `-=`, `*=`, `/=`

**Пример:**
```c#
int x = 10, y = 20;
int sum = x + y;        // Сложение (арифметический оператор)
bool isEqual = x == y;  // Сравнение (оператор равенства)
x += 5;                 // Присваивание с добавлением
```

**Объяснение:**
- `x + y` вычисляет сумму чисел.
- `x == y` проверяет, равны ли значения `x` и `y`.
- `x += 5` увеличивает значение `x` на 5.

### 3. **Тернарные операторы** (3 операнда)

В C# есть единственный тернарный оператор: **условный оператор** `?:`.  
Он используется для сокращённой записи условных выражений.  
Синтаксис:  
`condition ? value_if_true : value_if_false`

**Пример:**
```c#
int a = 10, b = 20;
int max = (a > b) ? a : b; // Если a > b, то max = a; иначе max = b
```

**Объяснение:**
- Проверяется условие `(a > b)`. Если оно истинно, результат `a`, иначе — `b`.
- В данном случае `max` будет равно `20`, так как `b > a`.

### Сводная таблица:

| **Тип оператора** | **Количество операндов** | **Примеры**               | **Описание**                         |
|--------------------|---------------------------|---------------------------|---------------------------------------|
| **Унарный**       | 1                         | `-a`, `++a`, `!a`         | Работает с одним операндом           |
| **Бинарный**      | 2                         | `a + b`, `a && b`         | Работает с двумя операндами          |
| **Тернарный**     | 3                         | `condition ? a : b`       | Работает с тремя операндами          |

### Итог:

**Арность** — это характеристика оператора, которая показывает, сколько операндов он принимает.  
Примеры:
1. Унарный: `-a`
2. Бинарный: `a + b`
3. Тернарный: `a > b ? a : b`

Тернарный оператор мы изучим когда будем проходить управление потоком исполнения программы.
# Переменные в C#

Переменная — это именованная область памяти, используемая для хранения данных, которые могут изменяться во время 
выполнения программы. Она имеет тип, который определяет, какие данные можно хранить в переменной, и как они будут обрабатываться.

Переменные программы хранятся в оперативной памяти компьютера, которая выделяется программе операционной системой.

Как уже было сказано в определение переменные на то и переменные, что их значение может меняться во время выполнения программы
или они даже могут быть удалены из памяти, например сборщиком мусора, если они уже не нужны для выполнения программы.

Естественно, что по завершении работы программы все переменные которые она использовала так же удаляются из памяти.

Переменные могут получать свои значения не посредственно в ходе выполнения программы из пользовательского ввода, читаться из
файлов или баз данных, а так же быть на прямую заданы в коде программы.

Значения переменных так же могут выводиться на экран, принтер, файл, базу данных, отправляться по сети и т.п.

Каждая переменная имеет **тип**, **имя** и **значение (данные)**.

Например:
```C#
int price = 100;
```
В данном случае `int` - это тип переменной, `price` - это имя переменной, а `100` - это значение переменной. 

Рассматривайте переменную как ящик куда можно что-то поместить, вынуть и поместить что-то другое. Но поскольку C# строго
типизированный язык в определенные ящики, можно помещать только определенные типы данных.

Разные типы данных имеют разные размеры поэтому для них выделяются разные по размеру ящики. То есть для хранения переменных
разных типов в памяти компьютера выделяется различное количество бит.

В приведенном выше примере для переменной типа `int` в памяти выделяется 32 бита, что равно 4 байтам. Переменные типа `int` могут
содержать значения от -2,147,483,648 до 2,147,483,647.

А вот пример переменой типа `byte`:
```C#
byte ascii_symbol = 108;
```
Для переменной типа `byte` выделяется 8 бит, что рано 1 байту. Переменные типа `byte` могут содержать значения от 0 до 255.

## Представление информации в памяти компьютера
Память измеряется в байтах. Один байт содержит 8 бит. 

**Что такое бит и байт?**
- **Бит** — это минимальная единица информации в компьютере, которая может принимать два значения: **0** или **1**.
- **Байт** — это последовательность из 8 бит. Он является стандартной минимальной единицей хранения данных в памяти компьютера.

**Как представляется информация в памяти компьютера?**

Компьютерная память устроена как огромный набор ячеек, каждая из которых может содержать 1 байт. В каждом байте 
хранятся 8 бит, которые могут быть **0** или **1**. Эти комбинации кодируют числа, символы, инструкции и другие данные 
с помощью кодировок (например, ASCII или Unicode для текста).

**Почему 1 байт может представлять 256 значений?**

Каждый бит в байте может быть либо **0**, либо **1**. Количество возможных комбинаций из 8 бит вычисляется как:  

$2^8 = 256$  

Таким образом, байт может представлять числа от **0 до 255** (если без знака) или от **-128 до 127** (если используется знак).  
Пример:
- `00000000` (все биты = 0) — это 0.
- `11111111` (все биты = 1) — это 255.

**Перевод из двоичной в десятичную**

Возьмем число **1011** (двоичное).  
Каждая цифра двоичного числа, в зависимости от своего положения (начиная справа), имеет вес, равный степени двойки, начиная с нуля:

| Вес цифры  | Цифра | Степень двойки | Значение |
|------------|-------|----------------|----------|
| 3 (слева)  | 1     | $2^3 = 8$      | 8        |
| 2          | 0     | $2^2 = 4$      | 0 (потому что 0 × 4 = 0) |
| 1          | 1     | $2^1 = 2$      | 2        |
| 0 (справа) | 1     | $2^0 = 1$      | 1        |

Теперь складываем только значения, которые **не равны 0**:  
$8 + 0 + 2 + 1 = 11$

**Результат:** $1011_2 = 11_{10}$

**Почему пропадает "4" в примере?**

В двоичной системе каждая **0** означает, что значение этой степени двойки не используется.  
В примере $1011_2$, цифра **0** на позиции $2^2$ даёт $0 * 4 = 0$, поэтому $4$ не добавляется в сумму.

**Перевод из десятичной в двоичную**

Возьмем число **13** (десятичное) и разделим целочисленным делением на 2, чтобы получить остатки:

1. **$13 \div 2 = 6$**, остаток **$1$**.
2. **$6 \div 2 = 3$**, остаток **$0$**.
3. **$3 \div 2 = 1$**, остаток **$1$**.
4. **$1 \div 2 = 0$**, остаток **$1$**.

Теперь записываем остатки **снизу вверх**:  
$1\ 1\ 0\ 1$

**Результат:** $13_{10} = 1101_2$


**Что такое целочисленное деление с остатком?**

В **целочисленном делении** результатом является только **целая часть** от деления, а остаток — это то, что "остается", 
если делимое не делится нацело.

Формула:  
```tex
Делимое = (Делитель \times ЦелаяЧасть) + Остаток
```
При этом:
- Остаток всегда меньше делителя.

Разберем $ 1 ÷ 2$ в контексте целочисленного деления с остатком:
1. Сколько раз $2$ помещается в $1$ без превышения? Ответ: $0$ раз (**целая часть = 0**).
2. Что осталось после этого? Осталось всё исходное число $1$, потому что $2$ в $1$ "не помещается".

Результат:  

$1 ÷  2 = 0 \, (\text{целая часть}) \, \text{и остаток 1}$.

**Объяснение целочисленного деления через раздачу пирогов:**

1. У тебя есть **13 пирогов**, ты раздаёшь их **группами по 2 пирога**. Раздавать можно только **целые** пироги. Резать пироги нельзя.
2. На каждом шаге:
    - Считаем, сколько раз можно раздать **по 2 целых пирога** (**целая часть деления**).
    - Считаем, сколько пирогов осталось (**остаток**).

**Шаги деления $13 \div 2$:**
1. **Первый шаг:**
    - У тебя есть $13$ пирогов. Сколько раз можно раздать по $2$ пирога?  
      $13 \div 2 = 6$ (**целая часть = 6**).
    - После раздачи $6 \times 2 = 12$ пирогов у тебя остался **1 пирог** (**остаток = 1**).

2. **Второй шаг:**
    - Теперь $6$ пирогов сколько раз можно раздать по $2$ пирога?  
      $6 \div 2 = 3$ (**целая часть = 3**).
    - После раздачи $3 \times 2 = 6$ пирогов осталось **0 пирогов** (**остаток = 0**).

3. **Третий шаг:**
    - Теперь  $3$ пирога сколько раз можно раздать по $2$?  
      $3 \div 2 = 1$ (**целая часть = 1**).
    - После раздачи $1 \times 2 = 2$ пирогов остался **1 пирог** (**остаток = 1**).

4. **Четвёртый шаг:**
    - И так остался $1$ пирог. Сколько раз можно раздать по $2$?  
      $1 \div 2 = 0$ (**целая часть = 0**). $0$ пирогов вы можете раздать. Поэтому у вас остается **1 пирог** (**остаток = 1**).
    - После раздачи $0 \times 2 = 0$ пирогов остался **1 пирог** (**остаток = 1**).

**Как собрать двоичное число:**
Остатки, которые мы получили (1, 0, 1, 1), записываем **снизу вверх**:  

$13_{10} = 1101_2$

**Кратко что мы проделали:**
1. На каждом шаге ты раздаёшь пироги **по 2 штуки за раз**.
2. Что остаётся после раздачи — это **остаток**, который записывается как разряд двоичного числа.
3. Процесс продолжается, пока у тебя не закончатся пироги (целая часть не станет 0).

Это было совсем не много математики необходимой для понимания двоичной системы счисления.

А теперь возвращаемся к теме переменных.

## Основные правила именования переменных в C#
1. **Определение переменной:**
   - Перед использованием переменную необходимо определить.
   - Синтаксис определения переменной:
     ```c#
     тип имя_переменной;
     ```
2. **Требования к имени переменной:**
   - Имя может содержать **буквы, цифры и символ подчеркивания** (`_`).
   - **Первый символ** имени должен быть **буквой или символом подчеркивания**.
   - **Запрещено** использовать пробелы, знаки пунктуации или специальные символы.
   - Имя **не может быть ключевым словом** языка C# (например, `int`, `class` и т.д.).
   - **Чувствительность к регистру**: `age` и `Age` считаются разными именами.

3. **Стиль именования:**
   - Используйте **camelCase** для локальных переменных и полей с модификатором `private`.
   - Используйте **PascalCase** для открытых (`public`) полей, свойств, методов и имен типов.

4. **Семантическая ясность:**
   - Имя должно быть **осмысленным** и отражать суть переменной. Например, вместо `x` лучше использовать `age`, `totalAmount`, и т.д.
   - Избегайте слишком длинных или слишком коротких имен, если это не оправдано.

5. **Особые правила:**
   - Для полей класса рекомендуется использовать префикс `_` (например, `_totalAmount`) в закрытых (`private`) переменных.
   - Константы (`const`) и статические переменные (`static readonly`) именуются **заглавными буквами** с подчеркиванием (`UPPER_CASE_WITH_UNDERSCORES`).

### Таблица стилей именования и использования
| **Стиль**             | **Примеры**                  | **Использование**                                                                 |
|------------------------|------------------------------|-----------------------------------------------------------------------------------|
| **Верблюжий регистр (camelCase)** | `totalAmount`, `orderDetail` | Локальные переменные, закрытые (`private`) поля.                                 |
| **Прописной стиль (PascalCase)** | `Name`, `TotalAmount`, `Run` | Имена типов, открытых (`public`) полей, свойств, методов, классов.               |
| **Заглавные буквы (UPPER_CASE)** | `MAX_VALUE`, `DEFAULT_PORT`  | Константы и статические поля (`const`, `static readonly`).                        |

### Примеры использования:
- Локальная переменная:
  ```c#
  int totalAmount = 100;
  ```
- Закрытое поле класса:
  ```c#
  private int _totalAmount;
  ```
- Открытое свойство:
  ```c#
  public int TotalAmount { get; set; }
  ```
- Константа:
  ```c#
  private const int MAX_USERS = 1000;
  ```

Перед типами переменных, в примерах выше стоят инструкции модификаторов доступа. Всё это было кратко описано в главе 
["Элементы языка C#"](GrammarAndTerminologyCSharp.md).

Тут мы так же немного затронули константы. Про них будет в следующей теме.

## Целочисленные переменные

В C# есть несколько встроенных типов целых чисел, которые различаются по размеру, диапазону и знаковости. Вот их подробное описание:

| **Тип**       | **Размер (в байтах)** | **Диапазон значений**                  | **Значение по умолчанию** |
|----------------|-----------------------|-----------------------------------------|---------------------------|
| **sbyte**     | 1                     | -128 до 127                            | 0                         |
| **byte**      | 1                     | 0 до 255                               | 0                         |
| **short**     | 2                     | -32,768 до 32,767                      | 0                         |
| **ushort**    | 2                     | 0 до 65,535                            | 0                         |
| **int**       | 4                     | -2,147,483,648 до 2,147,483,647        | 0                         |
| **uint**      | 4                     | 0 до 4,294,967,295                     | 0                         |
| **long**      | 8                     | -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807 | 0 |
| **ulong**     | 8                     | 0 до 18,446,744,073,709,551,615        | 0                         |
| **nint** *(с версии C# 9.0)*  | Зависит от платформы | -2³¹ до 2³¹-1 (32-битная платформа) или -2⁶³ до 2⁶³-1 (64-битная платформа) | 0 |
| **nuint** *(с версии C# 9.0)* | Зависит от платформы | 0 до 2³²-1 (32-битная платформа) или 0 до 2⁶⁴-1 (64-битная платформа) | 0 |


### Ключевые особенности
1. **`sbyte`** и **`short`**: знаковые типы для небольших чисел.
2. **`byte`** и **`ushort`**: беззнаковые версии для тех же диапазонов.
3. **`int`** и **`uint`**: основные типы для работы с числами среднего размера.
4. **`long`** и **`ulong`**: предназначены для больших чисел.
5. **`nint`** и **`nuint`**: зависят от платформы и используются для работы с указателями или низкоуровневым кодом.

Исходя из ваших нужд вы можете использовать тот или иной тип переменных.

Переменные можно просто объявить, или же сразу при объявлении присвоить значение. Если переменной при объявлении не присваивается
значение явно, то ей присваивается значение по умолчанию.

Значение переменной присваивается при помощи оператора `=` (присваивания).

Давай уже, падаван, попрактикуемся. Создай консольное приложение `ex0015_integer_vars` при помощи шаблона `tinyconsole`
в папке episode02 и добавь его в файл решения episode02.sln. Это можно сделать как в командной строке так и в любой IDE.

Приведи файл Program.cs к следующему виду:

```C#
namespace ex0015_integer_vars;

class Program
{
    static sbyte sbyteDefault;
    static sbyte byteDefault;
    static short shortDefault;
    static ushort ushortDefault;
    static int intDefault;
    static uint uintDefault;
    static long longDefault;
    static ulong ulongDefault;
    static nint nintDefault;
    static nuint nuintDefault;

    static void Main()
    {
        WriteLine("Типы целочисленных переменных в C#");
        WriteLine(new string('-', 34));

        // sbyte
        sbyte sbyteMin = sbyte.MinValue;
        sbyte sbyteMax = sbyte.MaxValue;
        
        WriteLine($"Тип: sbyte");
        WriteLine($"Минимум: {sbyteMin}");
        WriteLine($"Максимум: {sbyteMax}");
        WriteLine($"Значение по умолчанию: {sbyteDefault}");
        WriteLine();

        // byte
        byte byteMin = byte.MinValue;
        byte byteMax = byte.MaxValue;
        WriteLine($"Тип: byte");
        WriteLine($"Минимум: {byteMin}");
        WriteLine($"Максимум: {byteMax}");
        WriteLine($"Значение по умолчанию: {byteDefault}");
        WriteLine();

        // short
        short shortMin = short.MinValue;
        short shortMax = short.MaxValue;
        WriteLine($"Тип: short");
        WriteLine($"Минимум: {shortMin}");
        WriteLine($"Максимум: {shortMax}");
        WriteLine($"Значение по умолчанию: {shortDefault}");
        WriteLine();

        // ushort
        ushort ushortMin = ushort.MinValue;
        ushort ushortMax = ushort.MaxValue;
        WriteLine($"Тип: ushort");
        WriteLine($"Минимум: {ushortMin}");
        WriteLine($"Максимум: {ushortMax}");
        WriteLine($"Значение по умолчанию: {ushortDefault}");
        WriteLine();

        // int
        int intMin = int.MinValue;
        int intMax = int.MaxValue;
        WriteLine($"Тип: int");
        WriteLine($"Минимум: {intMin}");
        WriteLine($"Максимум: {intMax}");
        WriteLine($"Значение по умолчанию: {intDefault}");
        WriteLine();

        // uint
        uint uintMin = uint.MinValue;
        uint uintMax = uint.MaxValue;
        WriteLine($"Тип: uint");
        WriteLine($"Минимум: {uintMin}");
        WriteLine($"Максимум: {uintMax}");
        WriteLine($"Значение по умолчанию: {uintDefault}");
        WriteLine();

        // long
        long longMin = long.MinValue;
        long longMax = long.MaxValue;
        WriteLine($"Тип: long");
        WriteLine($"Минимум: {longMin}");
        WriteLine($"Максимум: {longMax}");
        WriteLine($"Значение по умолчанию: {longDefault}");
        WriteLine();

        // ulong
        ulong ulongMin = ulong.MinValue;
        ulong ulongMax = ulong.MaxValue;
        WriteLine($"Тип: ulong");
        WriteLine($"Минимум: {ulongMin}");
        WriteLine($"Максимум: {ulongMax}");
        WriteLine($"Значение по умолчанию: {ulongDefault}");
        WriteLine();

        // nint (платформо-зависимый тип)
        nint nintMin = nint.MinValue;
        nint nintMax = nint.MaxValue;
        WriteLine($"Тип: nint");
        WriteLine($"Минимум: {nintMin}");
        WriteLine($"Максимум: {nintMax}");
        WriteLine($"Значение по умолчанию: {nintDefault}");
        WriteLine();

        // nuint (платформо-зависимый тип)
        nuint nuintMin = nuint.MinValue;
        nuint nuintMax = nuint.MaxValue;
        
        WriteLine($"Тип: nuint");
        WriteLine($"Минимум: {nuintMin}");
        WriteLine($"Максимум: {nuintMax}");
        WriteLine($"Значение по умолчанию: {nuintDefault}");
        WriteLine();
    }
}
```

**Первый** запуск программы даст следующий вывод (показана часть вывода):

![Целочисленные переменные в C#](int_vars01.png){ border-effect="line"  thumbnail="true" width="700" }

Как видите компилятор вывел предупреждение, что поскольку некоторые переменные не были инициализированы значениями, то
им было присвоено значение по умолчанию.

При втором запуске таких предупреждений уже не будет.

![Целочисленные переменные в C#](int_vars02.png){ border-effect="line"  thumbnail="true" width="700" }

Если вы хотите увидеть эти предупреждения снова, дайте команду `dotnet clean` в папке проекта.

В этой программе следует обратить внимание на блок объявления десяти переменных в самом начале программы. То есть в классе
Program. И попытаться понять почему другие переменные были объявлены и инициализированы значениями внутри метода Main().

### **Переменные за пределами метода `Main`**
Переменные вроде `sbyteDefault`, `byteDefault` и другие определены как **поля класса** (на уровне класса), 
а не как локальные переменные внутри метода. Причины этого:

- **Доступ к значению по умолчанию без явного инициализатора**: Поля класса автоматически инициализируются значением по умолчанию, если не задать его явно. Это позволяет продемонстрировать значения по умолчанию, такие как `0` для целочисленных типов, без необходимости явно присваивать их внутри метода.
- **Локальные переменные требуют явной инициализации**: Если бы мы определили эти переменные внутри метода `Main`, компилятор потребовал бы явного присваивания значения, так как локальные переменные в C# не получают значение по умолчанию автоматически.
- **Повторное использование**: Поля класса могут быть доступны из разных методов, если потребуется. Это делает их более гибкими, чем локальные переменные, которые доступны только внутри метода, где они объявлены.

### **Почему использовано ключевое слово `static`**
Все поля, такие как `sbyteDefault`, объявлены с модификатором `static`. Это связано с тем, что метод `Main()` тоже 
объявлен как `static`. В C# метод `Main` — это точка входа для программы, и компилятор требует, чтобы он был статическим.

Поле или метод, помеченные ключевым словом `static`, принадлежат самому классу, а не конкретному экземпляру этого класса. 
В данном случае:
- Метод `Main` принадлежит классу `Program`, а не объекту класса `Program`.
- Поля, к которым обращается метод `Main`, также должны быть статическими, иначе метод `Main` не сможет к ним обратиться.

Если бы поля `sbyteDefault`, `byteDefault` и т.д. не были статическими, то для доступа к ним внутри `Main()` потребовалось 
бы создавать экземпляр класса `Program`. Например:
```c#
Program program = new Program();
Console.WriteLine(program.sbyteDefault); // доступ через объект
```
Это избыточно и не имеет смысла в данном случае.

### **Подведем итоги**
- Поля класса, объявленные как `static`, используются для демонстрации значений по умолчанию, так как они автоматически инициализируются компилятором.
- Метод `Main()` также статический, чтобы быть точкой входа программы.
- Статические поля и метод могут обращаться друг к другу без создания экземпляра класса.

### Пример для иллюстрации разницы
Вот как программа могла бы выглядеть без использования `static` для полей:

```c#
namespace ex0015_integer_vars;

class Program
{
    sbyte sbyteDefault; // Поле экземпляра класса

    static void Main()
    {
        Program program = new Program(); // Создаем объект класса
        Console.WriteLine(program.sbyteDefault); // Теперь доступ через объект
    }
}
```

В этом примере для доступа к полю `sbyteDefault` требуется создать объект класса, потому что поле не является статическим. 
Это лишний шаг в нашем случае, так как переменные используются только в статическом контексте.

Скорее всего вам было не всё понятно в этих объяснениях, так как мы ещё не проходили что такое класс и экземпляр класса.
Вы всё это скоро узнаете. Пока намотайте на ус 😊.

Хотя давайте это же самое ещё раз проговорим чуток другими словами, возможно будет понятнее.

В C# при объявлении переменной, если ей не присваивается значение явно, то для нее автоматически задается **значение по умолчанию**. 
Однако есть нюансы:

1. **Локальные переменные** (объявленные внутри методов) **не инициализируются автоматически**, и попытка их использования до явного присваивания значения приведет к ошибке компиляции. Например:
   ```c#
   void PrintField() // это метод, не путайте с классом
   {
       int field; // Ошибка: локальная переменная не инициализирована
       Console.WriteLine(field); // Ошибка компиляции
   }
   ```

2. **Поля классов** и **переменные уровня класса/структуры** автоматически получают **значение по умолчанию**. Например:
   ```c#
   class Example
   {
       int field; // Поле получает значение по умолчанию: 0

       void PrintField()
       {
           Console.WriteLine(field); // Вывод: 0
       }
   }
   ```
К сожалению без оперирования понятиями классов и методов, объяснить все эти моменты было бы не возможно. И хотя мы ещё не
изучали что такое класс и метод класса, вы уже соприкоснулись с этими понятиями и нейронные связи в вашем мозгу уже прямо
сейчас начали расти. Чувствуете как мозги закипают? 😊 Это нейроночки у вас в мозгу растут. Вы становитесь умнее и умнее.
Хотя возможно пока вы это и не замечаете 😊. Да пребудет с тобой сила, падван.

>Причем все эти вещи, которые мы тут разжевывали касательно места, где объявляется переменная, общие для всех переменных, 
>не зависимо от их типа.

И ещё один момент. Как вы помните в главе ["Структура проекта C#"](Csharp-project-structure.md) 
мы подробно разбирали операторы верхнего уровня. Одной из причин почему их ввели, было упрощение изучения C# и снижение
порога вхождения. Хотя на самом деле, ни класс Program, ни статический метод Main, ни куда не девались. Их
просто скрыли чтобы не пугать начинающих. Но в любом случае они есть и от того что их скрыли легче не становится 😊.
Не находите? И на мой взгляд с этими вещами начинать работать и разбираться нужно в самом начале.
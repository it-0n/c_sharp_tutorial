# Строки в C#

В программировании скрытая магия встречается на каждом шагу. Например, даже простые типы значений вроде `int` или `double` 
на самом деле не так уж просты — это структуры, которые "маскируются" под нессылочные типы. 
Однако благодаря особенностям C# и .NET они всё равно ведут себя как полноценные объекты.

C# — это до мозга костей объектно-ориентированный язык. Это означает, что практически всё в нём является объектом, 
а каждый объект наследует свойства и методы базового класса `System.Object`. Представьте себе это как передачу 
генетического кода: как у всех людей есть общий набор базовых генов, так и у всех объектов есть общие свойства и методы. 
Например, все объекты умеют превращаться в строки благодаря методу `ToString()`.

[Строки](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/builtin-types/reference-types#the-string-type),
представленные в C# типом `string`, тоже наследуют этот "геном" базового класса `System.Object`, но, как в природе,
они дополнительно приобретают свои уникальные свойства и методы. Например:
- Свойство `Length` позволяет узнать длину строки.
- Метод `ToUpper()` превращает все буквы строки в заглавные.

## Скрытая магия .NET {id="net_magic"}

>Внимание! Информация в этом разделе поясняет что происходит в закулисье .NET. Так как мы коснулись темы ООП, то я 
> считаю полезным дать эту информацию, хотя с первого прочтения она может быть не очень понятной. Опять же, если
> что-то понятно не переживайте, чуть позже всё поймёте. Да пребудет с вами Сила!
> {style="note"}

Давайте на примере типа `string` посмотрим этот генетический код. То есть посмотрим кто родители класса `string`.

Создай консольное приложение `ex0050_string_gen` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи `Program.cs` к следующему виду:
```C#
public class Program
{
    public static void Main()
    {
        var type = "STRING".GetType();
        do
        {
            WriteLine(type.FullName);
            type = type.BaseType;
        }
        while (type != null);
    }
}
```
Здесь мы в цикле проходимся по дереву наследования. Свойство `.BaseType` содержит тип родителя типа. Циклы мы пока не изучали,
но это не должно уже вас смущать. Мы часто забегаем чуток вперед, так сказать даём пищу вашему мозгу, чтобы он заранее
начинал обрабатывать информацию.

Вывод у программы такой:
```
System.String
System.Object
```
Как видим сперва идет `String` правда немного странный, а затем уже `Object`, но тоже странный. Странность в том что перед
ними стоит `System`. И тут мы опять погрузимся немного в зазеркалье C#.

В .NET существует несколько **системных типов**, которые используются для работы с основными данными, такими как числа, 
строки, логические значения и другие. Например, когда мы пишем код с такими типами, как `int` или `string`, 
за кулисами эти типы на самом деле представляют собой более длинные имена, например, `System.Int32` или `System.String`. 
Эти имена помогают .NET понять, с каким типом данных работает программа, и обеспечить правильную работу операций над ними.

### Что такое системные типы в .NET?
Системные типы — это стандартные типы данных, встроенные в платформу .NET. Они включают такие типы, как:
- **`int`** (для целых чисел) — это сокращение для `System.Int32`.
- **`string`** (для строк) — это сокращение для `System.String`.
- **`bool`** (для логических значений) — это сокращение для `System.Boolean`.

Когда вы пишете программу, используя эти типы (например, `int`, `string`, `bool`), .NET понимает, что вы имеете в виду 
типы данных, определённые в сборках, которые являются частью самого .NET.

### Пространство имен `System`
Все эти системные типы находятся в специальном **пространстве имен** под названием `System`. Пространство имен — это как 
своего рода "папка", которая группирует вместе все типы, связанные с базовыми операциями. Например:
- `System.Int32` — это тип для целых чисел.
- `System.String` — это тип для строк.
- `System.Boolean` — это тип для логических значений (истина/ложь).

Когда вы пишете код в C#, например:
```C#
int age = 25;
string name = "Alice";
bool isStudent = true;
```
Это то же самое, что и:
```C#
System.Int32 age = 25;
System.String name = "Alice";
System.Boolean isStudent = true;
```
Однако, чтобы код был проще и короче, мы используем короткие алиасы (псевдонимы), 
такие, как `int`, `string` и `bool`. Пространство имен `System` предоставляет эти алиасы и помогает программе 
работать с различными типами данных.

### Где хранятся эти типы?
Системные типы физически хранятся в специальных **библиотеках** (файлах с расширением `.dll`), которые входят 
в состав .NET. Эти библиотеки содержат реализации типов данных, используемых во всей платформе. Например:
- В .NET Framework системные типы содержатся в библиотеке **`mscorlib.dll`**.
- В .NET Core и .NET 5+ типы данных хранятся в библиотеке **`System.Private.CoreLib.dll`**.

Эти библиотеки обеспечивают правильную работу программ на разных операционных системах (Windows, Linux, macOS).

### Как это связано с кодом?
Когда вы используете типы данных в вашем коде, такие как `int`, `string`, или `bool`, компилятор C# заменяет эти 
короткие имена на полные имена из пространства имен `System`. Это позволяет программе работать с данными, 
и для этого ей не нужно заботиться о том, как именно эти типы реализованы в библиотеках.

### Заключение
Системные типы в .NET — это стандартные типы, такие как `int`, `string`, `bool`, которые используются для базовых 
операций с данными. Они определены в пространстве имен `System` и хранятся в специальных библиотеках, 
таких как `mscorlib.dll` или `System.Private.CoreLib.dll`. Эти типы делают программирование проще, так как 
позволяют работать с основными данными без необходимости создавать собственные типы с нуля.

И уж если начали смотреть как глубока кроличья нора, то давайте нырнем ещё чуть глубже в эту тему. Поскольку сейчас мы
коснулись где физически хранятся системные типы .NET, то как раз можно разобраться чуть поглубже со сборками программ.

### Что такое сборка программы C#? {id="c_1"}

**Сборка** (или *assembly* в английском варианте) в C# — это физический файл, который содержит скомпилированный код 
программы. Сборка является основным единичным элементом распространения и выполнения .NET приложений. 
Сборка может содержать как исполняемый код, так и различные ресурсы (например, изображения, текстовые файлы, настройки), 
а также метаданные, которые описывают структуру программы.

### Что включается в сборку?

Сборка может содержать несколько важных элементов:

1. **Исполняемый код** — код программы, скомпилированный в промежуточный язык (IL — Intermediate Language), который затем выполняется на .NET Runtime (например, CLR — Common Language Runtime).
2. **Метаданные** — информация о типах, классах, методах, свойствах и других конструкциях программы. Эти метаданные описывают структуру сборки и позволяют .NET Runtime правильно загружать и выполнять код.
3. **Ресурсы** — дополнительные данные, такие как изображения, строки, локализованные текстовые файлы, конфигурационные файлы и другие ресурсы, которые могут быть использованы в программе.
4. **Манифест** — файл, который хранит информацию о самой сборке (например, её версия, культура, идентификатор), а также сведения о зависимостях от других сборок.

Сборка может быть одного из двух типов:
- **Динамическая сборка** (DLL): Содержит библиотеки и компоненты, которые могут быть использованы другими приложениями. Обычно имеет расширение `.dll`.
- **Статическая сборка** (EXE для Windows): Это исполняемый файл, который можно запустить как самостоятельную программу. Обычно имеет расширение `.exe`.

### Основные физические файлы в сборке

- **.dll** — динамическая библиотека, которая может быть загружена и использована другими программами. Это основной формат для библиотек в .NET.
- **.exe** — исполняемый файл, который можно запустить, и который, как правило, включает в себя точку входа для программы (метод `Main`).
- **.pdb** — файл с отладочной информацией, который позволяет отлаживать программу и получать более подробные сообщения об ошибках.

### Пример

Предположим, что вы создаете консольное приложение на C#. При его компиляции будет создано несколько файлов:

1. **App.exe** — исполняемый файл программы.
2. **App.dll** — динамическая библиотека, которая может содержать общие компоненты программы.
3. **App.pdb** — файл с отладочной информацией.

Если это приложение использует внешние библиотеки, то также будут созданы или включены в сборку соответствующие `.dll` файлы этих библиотек.

### Как это работает на практике?

Когда вы запускаете приложение, .NET Runtime загружает сборки, проверяет их зависимости (например, если программа ссылается на внешнюю библиотеку, .NET загрузит и её) и выполняет промежуточный код. Все библиотеки и файлы, включенные в программу, должны быть доступны на устройстве, на котором программа будет запускаться.

Если вы создаёте сборку, которая зависит от других библиотек (например, `MyApp.dll` зависит от `SomeLibrary.dll`), вы должны удостовериться, что все зависимости присутствуют на целевой машине. Если зависимости не найдены, приложение не сможет запуститься. Поэтому сборки могут включать манифесты, которые описывают необходимые для работы библиотеки.

В .NET существует два типа сборок, которые определяют, как ваше приложение будет зависеть от установленного 
.NET Runtime: **зависимая от платформы сборка** и **самодостаточная сборка**. Эти два подхода имеют важные различия, 
которые влияют на способ распространения и запуска вашего приложения.

### 1. **Зависимая от платформы сборка** {id="1_2"}
Когда вы создаете **зависимую от платформы сборку**, ваше приложение будет зависеть от установленного .NET Runtime на машине, где оно будет выполняться. В этом случае, приложение компилируется так, что оно использует системные библиотеки, которые предоставляются самим .NET Runtime. Например, библиотеки, такие как `System.String`, `System.Int32` и другие встроенные типы, загружаются непосредственно из `.NET Runtime`, установленного на компьютере.

Когда вы создаете зависимую от платформы сборку, вы должны убедиться, что на целевой машине уже установлена соответствующая версия .NET Runtime. Если .NET Runtime не установлен, ваше приложение не будет работать.

#### Преимущества зависимой сборки:
- **Меньший размер**: Поскольку ваше приложение не включает все системные библиотеки, его размер будет меньше.
- **Обновления безопасности**: Приложение использует актуальные версии библиотек, которые могут быть обновлены через системные обновления .NET Runtime.

#### Пример:
Создание зависимой от платформы сборки с помощью команды `dotnet publish` без флага `--self-contained`:

```bash
dotnet publish -c Release -r win-x64
```
Это создаст сборку, которая будет использовать установленный на машине .NET Runtime.

![self-contained сборка](assembly03.png){border-effect="line" thumbnail="true" width="700"}

Обратите внимание на количество файлов и общий размер сборки.

### 2. **Самодостаточная сборка** {id="2_2"}
**Самодостаточная сборка** включает в себя не только ваше приложение, но и все необходимые библиотеки .NET, включая 
все системные типы и компоненты, которые обычно поставляются с .NET Runtime (например, `System.String`, `System.Int32` и другие). 
Это означает, что ваше приложение может работать на машине, где .NET Runtime не установлен, поскольку все нужные 
компоненты уже включены в сборку.

Когда вы создаете самодостаточную сборку, ваше приложение будет полностью независимым от установленного .NET Runtime. 
Оно будет работать на любом компьютере без необходимости установки дополнительного программного обеспечения.

#### Преимущества самодостаточной сборки:
- **Независимость от установленных зависимостей**: Приложение не зависит от того, установлен ли на компьютере .NET Runtime.
- **Удобство распространения**: Вы можете распространять приложение как единую сборку, и пользователи смогут запускать его без дополнительных шагов.

#### Недостатки:
- **Больший размер**: Сборка будет значительно больше, так как она включает все необходимые библиотеки .NET Runtime.

#### Пример:
Создание самодостаточной сборки с помощью команды `dotnet publish` с флагом `--self-contained`:

```bash
dotnet publish -c Release -r win-x64 --self-contained
```

В этом примере:
- `-c Release` — компиляция в режиме релиза.
- `-r win-x64` — целевая платформа (например, Windows 64-bit).
- `--self-contained` — флаг, который указывает, что сборка должна быть самодостаточной, и все зависимости (включая .NET Runtime) должны быть включены в сборку.

На скриншоте можно видеть сколько файлов содержит `self-contained` сборка и сколько места она занимает. Не правда ли
разительно отличается от зависимой от платформы сборки.

![self-contained сборка](assembly01.png){border-effect="line" thumbnail="true" width="700"}

![self-contained сборка](assembly02.png){border-effect="line" thumbnail="true" width="700"}

### Разница между зависимой и самодостаточной сборкой

| Характеристика                         | Зависимая от платформы сборка                | Самодостаточная сборка                     |
|----------------------------------------|---------------------------------------------|-------------------------------------------|
| **Зависимость от .NET Runtime**        | Да, приложение зависит от установленного .NET Runtime | Нет, приложение включает все необходимые библиотеки .NET |
| **Размер сборки**                      | Меньше, так как не включает .NET Runtime и системные библиотеки | Больше, так как включает все библиотеки .NET |
| **Необходимость установки .NET Runtime**| Да, .NET Runtime должен быть установлен на целевой машине | Нет, приложение работает без .NET Runtime |
| **Обновления**                          | Приложение использует актуальные версии библиотек, которые обновляются через .NET Runtime | Приложение использует те версии библиотек, которые были включены при публикации |

### Когда использовать каждый тип сборки?
- **Зависимая от платформы сборка** подходит, если вы уверены, что на целевой машине уже установлен нужный .NET Runtime. Это может быть хорошим выбором для корпоративных приложений, где установка .NET Runtime уже предусмотрена.
- **Самодостаточная сборка** идеальна, если вы хотите, чтобы ваше приложение работало на любых компьютерах без дополнительных настроек и зависимостей. Это особенно удобно для приложений, которые распространяются среди пользователей, не имеющих опыта с .NET или для серверных приложений, где не всегда можно гарантировать наличие .NET Runtime.

Таким образом, выбор между зависимой и самодостаточной сборкой зависит от того, какие требования предъявляются к 
распространению вашего приложения и от того, насколько важно, чтобы приложение было независимым от установленных библиотек.

Ну вот! Если вы дочитали это, то вам приз! Запустите проект [ex0049_snake](https://github.com/it-0n/it0nCS/tree/main/episode02/ex0049_snake). Чтобы управлять змейкой используйте клавиши стрелок.
Увеличить скорость змейки - `PageUp`, уменьшить - `PageDown`. Перед запуском сделайте размер консольного окна побольше обычного.

## Особенности строк в C#
1. **Строки — неизменяемые (immutable) объекты.**  
   Как только строка создаётся, её содержимое нельзя изменить. Любое изменение создаёт новую строку, а старая остаётся неизменной.

   ```c#
   string str = "Hello";
   str = str + " World"; // Создаётся новая строка, а старая "Hello" остаётся в памяти.
   ```

2. **У строк есть полезные свойства, например:**
    - `Length`: возвращает количество символов в строке.
      ```c#
      string text = "Example";
      Console.WriteLine(text.Length); // 7
      ```

3. **У строк есть полезные методы, например:**
    - `ToUpper()`: преобразует строку в верхний регистр.
      ```c#
      Console.WriteLine("hello".ToUpper()); // HELLO
      ```
    - `Replace()`: заменяет символы или подстроки.
      ```c#
      Console.WriteLine("cat".Replace("c", "b")); // bat
      ```

4. **Эффективность:**  
   Из-за неизменяемости строки подходят для большинства задач, но если нужно часто изменять текст (например, в цикле), лучше использовать `StringBuilder`. Этот класс позволяет эффективно создавать и изменять текст.
   ```c#
   using System.Text;

   StringBuilder sb = new StringBuilder("Hello");
   sb.Append(" World");
   Console.WriteLine(sb.ToString()); // Hello World
   ```

5. **Почему строки неизменяемы?**  
   Это сделано для безопасности и удобства:
    - Один объект строки можно безопасно использовать в разных потоках.
    - Неизменяемость упрощает интернирование строк — одинаковые строки хранятся в одном экземпляре, что экономит память.

Строки — это не просто текст. Это мощные и удобные объекты, которые дают нам множество инструментов для работы с 
текстовыми данными. Помните об их неизменяемости, и если потребуется часто модифицировать текст, выбирайте `StringBuilder`.

И со всем этим добром мы будем знакомиться в этом разделе, падаван.

## Конкатенация строк и подстановка значений в строки

В C# объединение строк и подстановка значений в строки можно выполнять разными способами: от базового использования 
оператора `+` до современных, более удобных механизмов, таких как интерполяция строк. Рассмотрим основные подходы.

### **1. Конкатенация строк**

#### **Использование оператора `+`**
Оператор `+` объединяет строки, добавляя их друг к другу. Это самый простой способ объединения строк.

Пример:
```C#
string firstName = "Иван";
string lastName = "Петров";

string fullName = firstName + " " + lastName;
Console.WriteLine(fullName); // Вывод: Иван Петров
```

#### **Проблемы с конкатенацией строк:**
1. **Читаемость:** Если строк много или они сложные, такой код становится трудно читаемым.
2. **Производительность:** При большом числе операций конкатенации создается много временных объектов, что может замедлить программу (особенно в циклах).

### **2. Подстановка значений в строки**

#### **Старый способ: Метод `string.Format`**
Метод `string.Format` позволяет подставлять значения в строку, используя плейсхолдеры `{0}`, `{1}` и т.д.

Пример:
```C#
string name = "Иван";
int age = 25;

string message = string.Format("Меня зовут {0}, мне {1} лет.", name, age);
Console.WriteLine(message); // Вывод: Меня зовут Иван, мне 25 лет.
```

- Плейсхолдеры заменяются значениями, переданными в `string.Format`.
- Это читабельнее, чем использование `+`, если строка большая.

#### **Старый способ с `Console.WriteLine`**
`Console.WriteLine` позволяет напрямую использовать плейсхолдеры без вызова `string.Format`.

Пример:
```C#
Console.WriteLine("Первое число {0}, второе число {1}", 1, 2);
// Вывод: Первое число 1, второе число 2
```

**Почему это работает?** Метод `Console.WriteLine` вызывает `string.Format` внутри себя.

### **3. Современный способ: Интерполяция строк**

Интерполяция строк (добавлена в C# 6.0) позволяет встроить значения переменных прямо в строку, используя `$"..."`.

Пример:
```C#
string name = "Иван";
int age = 25;

string message = $"Меня зовут {name}, мне {age} лет.";
Console.WriteLine(message); // Вывод: Меня зовут Иван, мне 25 лет.
```

**Преимущества:**
- Простой и читабельный синтаксис.
- Можно вставлять сложные выражения:
  ```C#
  Console.WriteLine($"7 + 4 = {7 + 4}"); // Вывод: 7 + 4 = 11
  ```

### **Ошибки при конкатенации строк и числовых значений**
>При объединении строки с числом, число автоматически преобразуется в строку!
> {style="warning"}

#### Пример ошибки:
```C#
Console.WriteLine("Сумма 7 + 4 = " + 7 + 4);
```

**Ожидаемый результат:**  
`Сумма 7 + 4 = 11`

**Фактический результат:**  
`Сумма 7 + 4 = 74`

**Почему так происходит?**
- Оператор `+` сначала объединяет строку `"Сумма 7 + 4 = "` с числом `7`, преобразуя число в строку. Затем объединяет эту строку с числом `4`, снова преобразуя число в строку.

#### **Как исправить:**
Используйте скобки для выполнения арифметического выражения перед конкатенацией:
```C#
Console.WriteLine("Сумма 7 + 4 = " + (7 + 4));
// Вывод: Сумма 7 + 4 = 11
```

Или используйте интерполяцию строк:
```C#
Console.WriteLine($"Сумма 7 + 4 = {7 + 4}");
// Вывод: Сумма 7 + 4 = 11
```

### **Какой способ выбрать?**

- **Конкатенация с `+`:** Используйте только для простых операций.
- **Метод `string.Format`:** Подходит для работы со строками в старом коде.
- **Интерполяция строк:** Рекомендуется в новых проектах, так как это самый читабельный и мощный способ работы со строками.

## Сравнение строк

В программировании сравнение данных — это как проверка паспортов: иногда нужно убедиться, что у вас одинаковые 
имена (сравнение содержимого), а иногда — что вы стоите в одной очереди (сравнение ссылок). 
Строки в C# имеют свои особенности при сравнении, что делает работу с ними удобной, но иногда запутанной. 
Сейчас мы рассмотрим все доступные инструменты для сравнения строк в C#, 
включая операторы `==` и `!=`, методы `Equals`, `Compare`, `CompareTo`, а также разберем, как сравниваются ссылки.

### **Основы сравнения строк** {id="1_1"}
В C# строки представлены классом `string`, который является **immutable** (неизменяемым). Это значит, что после создания строка не может быть изменена, а операции над строками создают новые объекты. Для сравнения строк можно использовать:
1. Операторы `==` и `!=`.
2. Методы `Equals`, `Compare`, `CompareTo`.
3. Явное сравнение ссылок через `object.ReferenceEquals`.

Эти инструменты позволяют сравнивать строки по содержимому или ссылкам в зависимости от потребностей.

### **Сравнение строк через операторы `==` и `!=`** {id="2_1"}
В отличие от большинства классов, операторы `==` и `!=` для строк переопределены. Это позволяет сравнивать строки **по содержимому**.

#### Пример:
```c#
string str1 = "hello";
string str2 = "hello";
string str3 = "world";

Console.WriteLine(str1 == str2); // True, содержимое строк совпадает
Console.WriteLine(str1 != str3); // True, содержимое строк различается
```

### **Как строки сравниваются на уровне реализации?** {id="3_1"}
Когда вы используете `==` или `!=`, фактически вызывается метод `string.Equals`. Этот метод:
- Сравнивает строки побайтово.
- Возвращает `true`, если содержимое строк идентично, даже если ссылки различны.
- Сравнивает `null` корректно: если обе строки равны `null`, результат `true`.

#### Пример:
```c#
string str1 = null;
string str2 = null;

Console.WriteLine(str1 == str2); // True, обе строки null
Console.WriteLine(str1 != str2); // False
```

### **Явное сравнение ссылок**
Если нужно сравнить именно ссылки (адреса объектов в памяти), используйте `object.ReferenceEquals`. Это полезно для проверки, интернированы ли строки или ссылаются ли они на один и тот же объект.

#### Пример:
```c#
string str1 = "hello";
string str2 = "hello";
string str3 = new string("hello".ToCharArray());

Console.WriteLine(object.ReferenceEquals(str1, str2)); // True, благодаря интернированию
Console.WriteLine(object.ReferenceEquals(str1, str3)); // False, разные объекты
```

### **Сравнение строк с помощью методов**
Класс `string` предоставляет несколько методов для сравнения:

#### **5.1. Метод `Equals`**
Сравнивает строки **по содержимому**. Существует два варианта:
1. Без параметров (регистр учитывается).
2. С параметром `StringComparison` для указания настроек сравнения (например, игнорирование регистра).

#### Пример:
```c#
string str1 = "hello";
string str2 = "Hello";

Console.WriteLine(str1.Equals(str2)); // False, регистр учитывается
Console.WriteLine(str1.Equals(str2, StringComparison.OrdinalIgnoreCase)); // True, регистр игнорируется
```

#### **Метод `Compare`**
Сравнивает строки и возвращает:
- `0`, если строки равны.
- Отрицательное значение, если первая строка меньше второй.
- Положительное значение, если первая строка больше второй.

Этот метод позволяет указать настройки сравнения, например, игнорирование регистра.

#### Пример:
```c#
string str1 = "apple";
string str2 = "banana";

int result = string.Compare(str1, str2, StringComparison.OrdinalIgnoreCase);
Console.WriteLine(result); // Отрицательное значение, "apple" меньше "banana"
```

#### **Метод `CompareTo`**
Метод `CompareTo` работает аналогично `Compare`, но вызывается на экземпляре строки и не принимает дополнительных параметров.

#### Пример:
```c#
string str1 = "apple";
string str2 = "banana";

int result = str1.CompareTo(str2);
Console.WriteLine(result); // Отрицательное значение, "apple" меньше "banana"
```

### **Сравнение строк и других объектов**
Операторы `==` и `!=` для большинства объектов (например, пользовательских классов) сравнивают **ссылки**, если их не переопределить. Класс `string` переопределяет эти операторы, поэтому сравнение выполняется по содержимому.

#### Таблица поведения:
| **Тип**         | **Сравнение по умолчанию** | **Примечание**                                                                                           |
|------------------|---------------------------|---------------------------------------------------------------------------------------------------------|
| `string`         | По содержимому            | Операторы `==` и `!=` переопределены для сравнения значений.                                            |
| Другие классы    | По ссылкам                | Операторы `==` и `!=` сравнивают ссылки, если их не переопределить.                                     |
| Структуры        | По значению               | Например, для структур `Point` операторы сравнивают все поля, если структура не переопределяет поведение. |


А теперь к практике, падаван!

Создай консольное приложение `ex0051_string_compare` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```c#
using System;

class Program
{
    static void Main()
    {
        string str1 = "hello";
        string str2 = "Hello";
        string str3 = new string("hello".ToCharArray());

        // Операторы == и !=
        WriteLine(str1 == str2); // False
        WriteLine(str1 != str2); // True

        // Метод Equals
        WriteLine(str1.Equals(str2)); // False
        WriteLine(str1.Equals(str2, StringComparison.OrdinalIgnoreCase)); // True

        // Сравнение ссылок
        WriteLine(object.ReferenceEquals(str1, str3)); // False

        // Compare
        WriteLine(string.Compare(str1, str2, StringComparison.OrdinalIgnoreCase)); // 0

        // CompareTo
        WriteLine(str1.CompareTo(str2)); // Отрицательное значение, "hello" меньше "Hello"
    }
}
```
Вывод программы:
```
False
True 
False
True 
False
0    
-1
```

### **Заключение**
Сравнение строк в C# — это мощный инструмент, благодаря переопределению операторов `==` и `!=` и предоставлению 
специализированных методов. Вы можете использовать простые операторы для сравнения значений и 
при необходимости уточнять логику с помощью методов `Equals`, `Compare` и `CompareTo`. Главное — помнить, что для 
строк сравнивается содержимое, а для других объектов по умолчанию сравниваются ссылки.

## Интерполяция строк

**Интерполяция строк** в C# — это удобный способ работы со строками, который позволяет включать в строковый 
литерал выражения и автоматически преобразовывать их в текст. Вместо сложных методов форматирования, интерполяция 
делает код более понятным и читаемым.

Символ `$` перед строковым литералом указывает компилятору, что это интерполированная строка. Внутри такой строки можно использовать выражения, заключённые в фигурные скобки `{}`, которые будут автоматически заменены их значениями.

### Преимущества интерполяции строк

1. **Простота и читаемость**: Форматирование становится более интуитивным и удобным.
2. **Универсальность**: Поддерживает сложные выражения, выравнивание, форматирование дат, чисел и других данных.
3. **Гибкость**: Легко комбинируется с шаблонами, например, сопоставлением.

### Сравнение с составным форматированием

Рассмотрим два примера:

```C#
var name = "Мария";
var date = DateTime.Now;

// Составное форматирование
Console.WriteLine("Привет, {0}! Сегодня {1}, текущее время {2:HH:mm}.", name, date.DayOfWeek, date);

// Интерполяция строк
Console.WriteLine($"Привет, {name}! Сегодня {date.DayOfWeek}, текущее время {date:HH:mm}.");
```

Оба примера выведут одинаковый результат, например:  
`Привет, Мария! Сегодня Понедельник, текущее время 14:30.`

Интерполяция строк более лаконична и наглядна.

### Как работает интерполяция строк?

- **Символ `$`** указывает на интерполированную строку.
- **Выражения внутри `{}`** заменяются их текстовыми значениями при выполнении программы.
- **Фигурные скобки** могут содержать не только переменные, но и любые выражения (например, математические операции).

### Структура интерполированной строки

Каждое выражение интерполяции имеет следующий синтаксис:

```C#
{<выражение>[,<выравнивание>][:<строка_формата>]}
```

#### Пояснения:
1. **`выражение`** — переменная или операция, результат которой нужно вставить в строку.
2. **`выравнивание`** (опционально) — минимальная ширина результата. Если положительное, текст выравнивается по правому краю, если отрицательное — по левому.
3. **`строка_формата`** (опционально) — формат вывода значения. Например, для чисел можно указать количество знаков после запятой, а для дат — формат отображения.

### Примеры выравнивания и форматирования

#### Выравнивание текста
```C#
Console.WriteLine($"|{"Слева",-10}|{"Справа",10}|");
```
Результат:
```
|Слева     |     Справа|
```

#### Форматирование чисел
```C#
const int Width = 15;
Console.WriteLine($"{Math.PI,Width} - значение числа Пи по умолчанию");
Console.WriteLine($"{Math.PI,Width:F3} - Пи с тремя знаками после запятой");
```
Результат:
```
          3.14159265358979 - значение числа Пи по умолчанию  
                    3.142 - Пи с тремя знаками после запятой
```

### Использование шаблонов с интерполяцией

С C# 11 стало проще форматировать длинные выражения. Например, сопоставление температур с комфортностью:

```C#
class Program
{
    static void Main()
    {
        var temperature = 25;

        string message = $"Температура {temperature}°C считается {temperature switch
        {
            <= -40 => "смертельно опасной",
            <= -25 => "очень холодной, опасной",
            <= 0 => "холодной, но приемлемой",
            <= 19 => "прохладной",
            <= 27 => "комфортной",
            <= 36 => "жаркой",
            <= 45 => "очень жаркой",
            _ => "черезмерно жаркой и опасной",
        }}.";
        WriteLine(message);
    }
}
```

#### Результаты:
- Для `-15°C`: `Температура -15°C считается холодной, но приемлемой.`
- Для `25°C`: `Температура 25°C считается комфортной.`

### Особенности

- Интерполяция поддерживает только те выражения, которые доступны в контексте выполнения программы.
- Интерполяция строки может быть использована для создания **константной строки** только если все выражения в ней — это константы.

### Заключение

Интерполяция строк — мощный инструмент C#, который делает форматирование строк удобным и читаемым. 
Она упрощает написание кода и улучшает его понимание, особенно в случаях, когда нужно работать со сложными 
выражениями или форматировать данные.

## Форматирование в интерполированных строках

Вообще [форматирование строк и других типов](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/formatting-types), 
можно использовать не только в интерполированных строках. Но уж поскольку мы сейчас рассматривали интерполяцию строк,
то познакомимся с форматированием строк в этом контексте, тем более что этот кейс используется чаще всего.

Но вообще [тема форматирования строк и других типов очень обширна](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/formatting-types), 
так как предлагает множество вариантов на все случаи жизни. Поэтому так же рекомендую пройти по ссылке и ознакомиться с ней.
Тут же мы рассмотри только основные моменты, чтобы было понятие об этой теме.

Ещё рза структура форматирования для интерполированных строк:
```C#
{<выражение>[,<выравнивание>][:<строка_формата>]}
```

### Компоненты форматирования:

1. **Выражение**  
   Любое корректное C# выражение. Например:
   ```C#
   int a = 5, b = 10;
   Console.WriteLine($"Сумма: {a + b}"); // Сумма: 15
   ```

2. **Выравнивание**  
   Определяет минимальную ширину строки:
   - Положительное число — выравнивание по правому краю.
   - Отрицательное число — выравнивание по левому краю.
   ```C#
   Console.WriteLine($"|{"Лево",-10}|{"Право",10}|");
   // |Лево      |     Право|
   ```

3. **Строка формата**  
   Спецификаторы, задающие вид [числа](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/standard-numeric-format-strings), [даты](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/standard-date-and-time-format-strings), [времени](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/custom-date-and-time-format-strings) или строки.

### Примеры форматирования

#### Числа

1. **[Целые числа](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/standard-numeric-format-strings)**
   - **`D` (Decimal):** минимальное количество цифр.
   - **`X` (Hexadecimal):** шестнадцатеричный формат.
   - **`N` (Number):** разделители разрядов.
   ```C#
   int value = 255;
   Console.WriteLine($"Десятичное: {value:D5}"); // 00255
   Console.WriteLine($"Шестнадцатеричное: {value:X}"); // FF
   Console.WriteLine($"Разделители: {value:N0}"); // 255
   ```

2. **[Дробные числа](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/standard-numeric-format-strings)**
   - **`F` (Fixed-point):** количество знаков после запятой.
   - **`E` (Exponential):** экспоненциальный формат.
   - **`P` (Percent):** процент.
   ```C#
   double pi = 3.14159;
   Console.WriteLine($"Фиксированная точка: {pi:F2}"); // 3.14
   Console.WriteLine($"Экспоненциально: {pi:E2}"); // 3.14E+000
   Console.WriteLine($"Процент: {pi:P2}"); // 314.16%
   ```

3. **[Бинарные числ](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/standard-numeric-format-strings#BFormatString)а (c .NET 8)**  
   Используем встроенный метод `Convert.ToString`:
   ```C#
   int number = 42;
   Console.WriteLine($"Бинарное: {Convert.ToString(number, 2)}"); // 101010
   ```

#### Даты и время

1. **[Форматы даты и времени](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/standard-date-and-time-format-strings)**
   - **`d` (Short date):** 28.12.2024
   - **`D` (Long date):** 28 декабря 2024 г.
   - **`T` (Full time):** 18:45:30
   ```C#
   DateTime now = DateTime.Now;
   Console.WriteLine($"Краткая дата: {now:d}");
   Console.WriteLine($"Полная дата: {now:D}");
   Console.WriteLine($"Время: {now:T}");
   ```

2. **[Кастомные шаблоны](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/custom-date-and-time-format-strings)**
   ```C#
   Console.WriteLine($"{now:dd-MMM-yyyy}"); // 28-Dec-2024
   Console.WriteLine($"{now:HH:mm:ss}");   // 18:45:30
   ```

#### Валюта
Используйте формат **`C`**:
```C#
decimal price = 1234.56m;
Console.WriteLine($"Цена: {price:C2}"); // Цена: 1 234,56 ₽
```

Закрепим это всё на практике.

Создай консольное приложение `ex0052_string_interpolation` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```C#
using System;

class Program
{
    static void Main()
    {
        // Пример 1: Форматирование целых чисел
        int number = 123456;
        WriteLine($"Обычное число: {number}");
        WriteLine($"Число c дополнительными разрядами слева: {number:D10}");
        WriteLine($"Число с выравниванием по правому краю (10 символов): {number,12}");
        WriteLine($"Число с выравниванием по левому краю (-10 символов): {number,-12}");
        WriteLine($"Число в двоичном формате: {number:b}");
        WriteLine($"Число в шестнадцатиричном формате: {number:X}"); // большие буквы в выводимых значениях
        WriteLine($"Число в шестнадцатиричном формате: {number:x}"); // маленькие буквы в выводимых значениях
        WriteLine($"Число с разделением на разряды: {number:N0}");

        // Пример 2: Форматирование дробных чисел
        double pi = Math.PI;
        WriteLine($"Число Pi: {pi}");
        WriteLine($"Число Pi (2 знака после запятой): {pi:F2}");
        WriteLine($"Число Pi (4 знака после запятой): {pi:F4}");
        WriteLine($"Проценты: {(double)number/1000000:P4}"); //скомбинирорвано выражение приведения к double и деление

        // Пример 3: Форматирование валют
        decimal price = 1234.4321m;
        WriteLine($"Цена: {price:C}"); // C - валюта по умолчанию для текущей культуры
        WriteLine($"Цена (4 знака после запятой): {price:C4}"); // выдуманный пример для примера :)

        // Пример 4: Форматирование дат и времени
        DateTime now = DateTime.Now;
        WriteLine($"Текущая дата и время: {now}");
        WriteLine($"Только дата: {now:yyyy-MM-dd}");
        WriteLine($"Только дата: {now:dd MMMM yyyy}");
        WriteLine($"День недели и дата: {now:dddd dd MMMM yyyy}");
        WriteLine($"Только время: {now:HH:mm:ss}");

        // Пример 5: Комбинация выравнивания и форматирования
        WriteLine($"|{"Название",-15}|{"Значение",15}|");
        WriteLine($"|{"Pi",-15}|{pi,15:F3}|");
        WriteLine($"|{"Цена",-15}|{price,15:C2}|");

        // Пример 6: Сопоставление шаблонов с интерполяцией строк
        // Объяснение:
        // Этот код использует сопоставление шаблонов (pattern matching) для определения 
        // диапазона температур и соответствующего описания.
        // `switch` проверяет значение переменной `temperature` по порядку сверху вниз.
        // Как только совпадение найдено, оно возвращает результат и остальные условия не проверяются.
        var temperature = 25;
        string message = $"Температура {temperature}°C считается {temperature switch
        {
            <= -40 => "смертельно опасной",     // Если температура <= -40
            <= -25 => "очень холодной, опасной", // Если температура от -40 до -25
            <= 0 => "холодной, но приемлемой",   // Если температура от -25 до 0
            <= 19 => "прохладной",               // Если температура от 0 до 19
            <= 27 => "комфортной",               // Если температура от 19 до 27
            <= 36 => "жаркой",                   // Если температура от 27 до 36
            <= 45 => "очень жаркой",             // Если температура от 36 до 45
            _ => "чрезмерно жаркой и опасной",   // Любая температура больше 45
        }}.";
        WriteLine(message);
    }
}
```

Оператор `switch` мы тоже пока не проходили, но в комментариях я дал краткое пояснение как он работает.

Вывод программы:

```
Обычное число: 123456
Число c дополнительными разрядами слева: 0000123456
Число с выравниванием по правому краю (10 символов):       123456
Число с выравниванием по левому краю (-10 символов): 123456
Число в двоичном формате: 11110001001000000
Число в шестнадцатиричном формате: 1E240
Число в шестнадцатиричном формате: 1e240
Число с разделением на разряды: 123 456
Число Pi: 3,141592653589793
Число Pi (2 знака после запятой): 3,14
Число Pi (4 знака после запятой): 3,1416
Проценты: 12,3456 %
Цена: 1 234,43 ₽
Цена (4 знака после запятой): 1 234,4321 ₽
Текущая дата и время: 28.12.2024 13:10:56
Только дата: 2024-12-28
Только дата: 28 декабря 2024
День недели и дата: суббота 28 декабря 2024
Только время: 13:10:56
|Название       |       Значение|
|Pi             |          3,142|
|Цена           |     1 234,43 ₽|
Температура 25°C считается комфортной.
```

>Символ валюты может у вас отличаться. Это зависит от ваших региональных настроек.
> {style="note"}
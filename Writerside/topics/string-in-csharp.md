# Строки в C#

В программировании скрытая магия встречается на каждом шагу. Например, даже простые типы значений вроде `int` или `double` 
на самом деле не так уж просты — это структуры, которые "маскируются" под нессылочные типы. 
Однако благодаря особенностям C# и .NET они всё равно ведут себя как полноценные объекты.

C# — это до мозга костей объектно-ориентированный язык. Это означает, что практически всё в нём является объектом, 
а каждый объект наследует свойства и методы базового класса `System.Object`. Представьте себе это как передачу 
генетического кода: как у всех людей есть общий набор базовых генов, так и у всех объектов есть общие свойства и методы. 
Например, все объекты умеют превращаться в строки благодаря методу `ToString()`.

[Строки](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/builtin-types/reference-types#the-string-type),
представленные в C# типом `string`, тоже наследуют этот "геном" базового класса `System.Object`, но, как в природе,
они дополнительно приобретают [свои уникальные свойства и методы](https://learn.microsoft.com/ru-ru/dotnet/api/system.string). Например:
- Свойство `Length` позволяет узнать длину строки.
- Метод `ToUpper()` превращает все буквы строки в заглавные.

## Скрытая магия .NET {id="net_magic"}

>Внимание! Информация в этом разделе поясняет что происходит в закулисье .NET. Так как мы коснулись темы ООП, то я 
> считаю полезным дать эту информацию, хотя с первого прочтения она может быть не очень понятной. Опять же, если
> что-то понятно не переживайте, чуть позже всё поймёте. Да пребудет с вами Сила!
> {style="note"}

Давайте на примере типа `string` посмотрим этот генетический код. То есть посмотрим кто родители класса `string`.

Создай консольное приложение `ex0050_string_gen` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи `Program.cs` к следующему виду:
```C#
public class Program
{
    public static void Main()
    {
        var type = "STRING".GetType();
        do
        {
            WriteLine(type.FullName);
            type = type.BaseType;
        }
        while (type != null);
    }
}
```
Здесь мы в цикле проходимся по дереву наследования. Свойство `.BaseType` содержит тип родителя типа. Циклы мы пока не изучали,
но это не должно уже вас смущать. Мы часто забегаем чуток вперед, так сказать даём пищу вашему мозгу, чтобы он заранее
начинал обрабатывать информацию.

Вывод у программы такой:
```
System.String
System.Object
```
Как видим сперва идет `String` правда немного странный, а затем уже `Object`, но тоже странный. Странность в том что перед
ними стоит `System`. И тут мы опять погрузимся немного в зазеркалье C#.

В .NET существует несколько **системных типов**, которые используются для работы с основными данными, такими как числа, 
строки, логические значения и другие. Например, когда мы пишем код с такими типами, как `int` или `string`, 
за кулисами эти типы на самом деле представляют собой более длинные имена, например, `System.Int32` или `System.String`. 
Эти имена помогают .NET понять, с каким типом данных работает программа, и обеспечить правильную работу операций над ними.

### Что такое системные типы в .NET?
Системные типы — это стандартные типы данных, встроенные в платформу .NET. Они включают такие типы, как:
- **`int`** (для целых чисел) — это сокращение для `System.Int32`.
- **`string`** (для строк) — это сокращение для `System.String`.
- **`bool`** (для логических значений) — это сокращение для `System.Boolean`.

Когда вы пишете программу, используя эти типы (например, `int`, `string`, `bool`), .NET понимает, что вы имеете в виду 
типы данных, определённые в сборках, которые являются частью самого .NET.

### Пространство имен `System`
Все эти системные типы находятся в специальном **пространстве имен** под названием `System`. Пространство имен — это как 
своего рода "папка", которая группирует вместе все типы, связанные с базовыми операциями. Например:
- `System.Int32` — это тип для целых чисел.
- `System.String` — это тип для строк.
- `System.Boolean` — это тип для логических значений (истина/ложь).

Когда вы пишете код в C#, например:
```C#
int age = 25;
string name = "Alice";
bool isStudent = true;
```
Это то же самое, что и:
```C#
System.Int32 age = 25;
System.String name = "Alice";
System.Boolean isStudent = true;
```
Однако, чтобы код был проще и короче, мы используем короткие алиасы (псевдонимы), 
такие, как `int`, `string` и `bool`. Пространство имен `System` предоставляет эти алиасы и помогает программе 
работать с различными типами данных.

### Где хранятся эти типы?
Системные типы физически хранятся в специальных **библиотеках** (файлах с расширением `.dll`), которые входят 
в состав .NET. Эти библиотеки содержат реализации типов данных, используемых во всей платформе. Например:
- В .NET Framework системные типы содержатся в библиотеке **`mscorlib.dll`**.
- В .NET Core и .NET 5+ типы данных хранятся в библиотеке **`System.Private.CoreLib.dll`**.

Эти библиотеки обеспечивают правильную работу программ на разных операционных системах (Windows, Linux, macOS).

### Как это связано с кодом?
Когда вы используете типы данных в вашем коде, такие как `int`, `string`, или `bool`, компилятор C# заменяет эти 
короткие имена на полные имена из пространства имен `System`. Это позволяет программе работать с данными, 
и для этого ей не нужно заботиться о том, как именно эти типы реализованы в библиотеках.

### Заключение
Системные типы в .NET — это стандартные типы, такие как `int`, `string`, `bool`, которые используются для базовых 
операций с данными. Они определены в пространстве имен `System` и хранятся в специальных библиотеках, 
таких как `mscorlib.dll` или `System.Private.CoreLib.dll`. Эти типы делают программирование проще, так как 
позволяют работать с основными данными без необходимости создавать собственные типы с нуля.

И уж если начали смотреть как глубока кроличья нора, то давайте нырнем ещё чуть глубже в эту тему. Поскольку сейчас мы
коснулись где физически хранятся системные типы .NET, то как раз можно разобраться чуть поглубже со сборками программ.

### Что такое сборка программы C#? {id="c_1"}

**Сборка** (или *assembly* в английском варианте) в C# — это физический файл, который содержит скомпилированный код 
программы. Сборка является основным единичным элементом распространения и выполнения .NET приложений. 
Сборка может содержать как исполняемый код, так и различные ресурсы (например, изображения, текстовые файлы, настройки), 
а также метаданные, которые описывают структуру программы.

### Что включается в сборку?

Сборка может содержать несколько важных элементов:

1. **Исполняемый код** — код программы, скомпилированный в промежуточный язык (IL — Intermediate Language), который затем выполняется на .NET Runtime (например, CLR — Common Language Runtime).
2. **Метаданные** — информация о типах, классах, методах, свойствах и других конструкциях программы. Эти метаданные описывают структуру сборки и позволяют .NET Runtime правильно загружать и выполнять код.
3. **Ресурсы** — дополнительные данные, такие как изображения, строки, локализованные текстовые файлы, конфигурационные файлы и другие ресурсы, которые могут быть использованы в программе.
4. **Манифест** — файл, который хранит информацию о самой сборке (например, её версия, культура, идентификатор), а также сведения о зависимостях от других сборок.

Сборка может быть одного из двух типов:
- **Динамическая сборка** (DLL): Содержит библиотеки и компоненты, которые могут быть использованы другими приложениями. Обычно имеет расширение `.dll`.
- **Статическая сборка** (EXE для Windows): Это исполняемый файл, который можно запустить как самостоятельную программу. Обычно имеет расширение `.exe`.

### Основные физические файлы в сборке

- **.dll** — динамическая библиотека, которая может быть загружена и использована другими программами. Это основной формат для библиотек в .NET.
- **.exe** — исполняемый файл, который можно запустить, и который, как правило, включает в себя точку входа для программы (метод `Main`).
- **.pdb** — файл с отладочной информацией, который позволяет отлаживать программу и получать более подробные сообщения об ошибках.

### Пример

Предположим, что вы создаете консольное приложение на C#. При его компиляции будет создано несколько файлов:

1. **App.exe** — исполняемый файл программы.
2. **App.dll** — динамическая библиотека, которая может содержать общие компоненты программы.
3. **App.pdb** — файл с отладочной информацией.

Если это приложение использует внешние библиотеки, то также будут созданы или включены в сборку соответствующие `.dll` файлы этих библиотек.

### Как это работает на практике?

Когда вы запускаете приложение, .NET Runtime загружает сборки, проверяет их зависимости (например, если программа ссылается на внешнюю библиотеку, .NET загрузит и её) и выполняет промежуточный код. Все библиотеки и файлы, включенные в программу, должны быть доступны на устройстве, на котором программа будет запускаться.

Если вы создаёте сборку, которая зависит от других библиотек (например, `MyApp.dll` зависит от `SomeLibrary.dll`), вы должны удостовериться, что все зависимости присутствуют на целевой машине. Если зависимости не найдены, приложение не сможет запуститься. Поэтому сборки могут включать манифесты, которые описывают необходимые для работы библиотеки.

В .NET существует два типа сборок, которые определяют, как ваше приложение будет зависеть от установленного 
.NET Runtime: **зависимая от платформы сборка** и **самодостаточная сборка**. Эти два подхода имеют важные различия, 
которые влияют на способ распространения и запуска вашего приложения.

### 1. **Зависимая от платформы сборка** {id="1_2"}
Когда вы создаете **зависимую от платформы сборку**, ваше приложение будет зависеть от установленного .NET Runtime на машине, где оно будет выполняться. В этом случае, приложение компилируется так, что оно использует системные библиотеки, которые предоставляются самим .NET Runtime. Например, библиотеки, такие как `System.String`, `System.Int32` и другие встроенные типы, загружаются непосредственно из `.NET Runtime`, установленного на компьютере.

Когда вы создаете зависимую от платформы сборку, вы должны убедиться, что на целевой машине уже установлена соответствующая версия .NET Runtime. Если .NET Runtime не установлен, ваше приложение не будет работать.

#### Преимущества зависимой сборки:
- **Меньший размер**: Поскольку ваше приложение не включает все системные библиотеки, его размер будет меньше.
- **Обновления безопасности**: Приложение использует актуальные версии библиотек, которые могут быть обновлены через системные обновления .NET Runtime.

#### Пример:
Создание зависимой от платформы сборки с помощью команды `dotnet publish` без флага `--self-contained`:

```bash
dotnet publish -c Release -r win-x64
```
Это создаст сборку, которая будет использовать установленный на машине .NET Runtime.

![self-contained сборка](assembly03.png){border-effect="line" thumbnail="true" width="700"}

Обратите внимание на количество файлов и общий размер сборки.

### 2. **Самодостаточная сборка** {id="2_2"}
**Самодостаточная сборка** включает в себя не только ваше приложение, но и все необходимые библиотеки .NET, включая 
все системные типы и компоненты, которые обычно поставляются с .NET Runtime (например, `System.String`, `System.Int32` и другие). 
Это означает, что ваше приложение может работать на машине, где .NET Runtime не установлен, поскольку все нужные 
компоненты уже включены в сборку.

Когда вы создаете самодостаточную сборку, ваше приложение будет полностью независимым от установленного .NET Runtime. 
Оно будет работать на любом компьютере без необходимости установки дополнительного программного обеспечения.

#### Преимущества самодостаточной сборки:
- **Независимость от установленных зависимостей**: Приложение не зависит от того, установлен ли на компьютере .NET Runtime.
- **Удобство распространения**: Вы можете распространять приложение как единую сборку, и пользователи смогут запускать его без дополнительных шагов.

#### Недостатки:
- **Больший размер**: Сборка будет значительно больше, так как она включает все необходимые библиотеки .NET Runtime.

#### Пример:
Создание самодостаточной сборки с помощью команды `dotnet publish` с флагом `--self-contained`:

```bash
dotnet publish -c Release -r win-x64 --self-contained
```

В этом примере:
- `-c Release` — компиляция в режиме релиза.
- `-r win-x64` — целевая платформа (например, Windows 64-bit).
- `--self-contained` — флаг, который указывает, что сборка должна быть самодостаточной, и все зависимости (включая .NET Runtime) должны быть включены в сборку.

На скриншоте можно видеть сколько файлов содержит `self-contained` сборка и сколько места она занимает. Не правда ли
разительно отличается от зависимой от платформы сборки.

![self-contained сборка](assembly01.png){border-effect="line" thumbnail="true" width="700"}

![self-contained сборка](assembly02.png){border-effect="line" thumbnail="true" width="700"}

### Разница между зависимой и самодостаточной сборкой

| Характеристика                         | Зависимая от платформы сборка                | Самодостаточная сборка                     |
|----------------------------------------|---------------------------------------------|-------------------------------------------|
| **Зависимость от .NET Runtime**        | Да, приложение зависит от установленного .NET Runtime | Нет, приложение включает все необходимые библиотеки .NET |
| **Размер сборки**                      | Меньше, так как не включает .NET Runtime и системные библиотеки | Больше, так как включает все библиотеки .NET |
| **Необходимость установки .NET Runtime**| Да, .NET Runtime должен быть установлен на целевой машине | Нет, приложение работает без .NET Runtime |
| **Обновления**                          | Приложение использует актуальные версии библиотек, которые обновляются через .NET Runtime | Приложение использует те версии библиотек, которые были включены при публикации |

### Когда использовать каждый тип сборки?
- **Зависимая от платформы сборка** подходит, если вы уверены, что на целевой машине уже установлен нужный .NET Runtime. Это может быть хорошим выбором для корпоративных приложений, где установка .NET Runtime уже предусмотрена.
- **Самодостаточная сборка** идеальна, если вы хотите, чтобы ваше приложение работало на любых компьютерах без дополнительных настроек и зависимостей. Это особенно удобно для приложений, которые распространяются среди пользователей, не имеющих опыта с .NET или для серверных приложений, где не всегда можно гарантировать наличие .NET Runtime.

Таким образом, выбор между зависимой и самодостаточной сборкой зависит от того, какие требования предъявляются к 
распространению вашего приложения и от того, насколько важно, чтобы приложение было независимым от установленных библиотек.

Ну вот! Если вы дочитали это, то вам приз! Запустите проект [ex0049_snake](https://github.com/it-0n/it0nCS/tree/main/episode02/ex0049_snake). Чтобы управлять змейкой используйте клавиши стрелок.
Увеличить скорость змейки - `PageUp`, уменьшить - `PageDown`. Перед запуском сделайте размер консольного окна побольше обычного.

## Особенности строк в C#
1. **Строки — неизменяемые (immutable) объекты.**  
   Как только строка создаётся, её содержимое нельзя изменить. Любое изменение создаёт новую строку, а старая остаётся неизменной.

   ```c#
   string str = "Hello";
   str = str + " World"; // Создаётся новая строка, а старая "Hello" остаётся в памяти.
   ```

2. **У строк есть полезные свойства, например:**
    - `Length`: возвращает количество символов в строке.
      ```c#
      string text = "Example";
      Console.WriteLine(text.Length); // 7
      ```

3. **У строк есть полезные методы, например:**
    - `ToUpper()`: преобразует строку в верхний регистр.
      ```c#
      Console.WriteLine("hello".ToUpper()); // HELLO
      ```
    - `Replace()`: заменяет символы или подстроки.
      ```c#
      Console.WriteLine("cat".Replace("c", "b")); // bat
      ```

4. **Эффективность:**  
   Из-за неизменяемости строки подходят для большинства задач, но если нужно часто изменять текст (например, в цикле), лучше использовать `StringBuilder`. Этот класс позволяет эффективно создавать и изменять текст.
   ```c#
   using System.Text;

   StringBuilder sb = new StringBuilder("Hello");
   sb.Append(" World");
   Console.WriteLine(sb.ToString()); // Hello World
   ```
5. **Строки представляют собой массив символов**.

   Каждая строка фактически является последовательностью объектов `char`, где каждый символ занимает отдельную ячейку массива. К символам строки можно обращаться по индексу, начиная с нуля (нулевой индекс соответствует первому символу строки).
   ```C#
   string text = "Example";
   Console.WriteLine(text[0]); // Первый символ: E
   Console.WriteLine(text[6]); // Последний символ: e
   ```
   Если попытаться обратиться к индексу, превышающему длину строки, будет выброшено исключение `IndexOutOfRangeException`.
   ```C#
   string text = "Example";
   Console.WriteLine(text[7]); // Ошибка: IndexOutOfRangeException
   ```

### **Почему строки неизменяемы?**  
   Это сделано для безопасности и удобства:
    - Один объект строки можно безопасно использовать в разных потоках.
    - Неизменяемость упрощает интернирование строк — одинаковые строки хранятся в одном экземпляре, что экономит память.

### **Итог**
Строки — это не просто текст. Это мощные и удобные объекты, которые дают нам множество инструментов для работы с 
текстовыми данными. Помните об их неизменяемости, и если потребуется часто модифицировать текст, выбирайте `StringBuilder`.

И со всем этим добром мы будем знакомиться в этом разделе, падаван.

## Создание строк

По существу мы уже много раз это делали, создавали строки. Сейчас мы просто чуток формализуем этот момент и опишем некоторые особенности.
На самом деле любое выражение возвращающее строку может быть использовано для [создания новой строки](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/creating-new).

Итак, создать строки можно через:

1. **Литералы строк**:
   ```c#
   string str1 = "Привет, мир!";
   ```
   Строковые литералы позволяют напрямую задавать значение строки.

2. **Конструктор класса `String`**:
   ```c#
   char[] chars = { 'П', 'р', 'и', 'в', 'е', 'т' };
   string str2 = new string(chars);
   ```
   Конструктор `String` позволяет создавать строки из массива символов.

3. **Метод `String.Concat`**:
   ```c#
   string str3 = String.Concat("Привет", ", ", "мир", "!");
   ```
   Метод `Concat` объединяет несколько строк в одну.

4. **Метод `String.Join`**:
   ```c#
   string[] words = { "Привет", "мир" };
   string str4 = String.Join(", ", words);
   ```
   Метод `Join` объединяет элементы массива строк, вставляя между ними заданный разделитель.

5. **Метод `String.Insert`**:
   ```c#
   string str5 = "Привет мир";
   str5 = str5.Insert(6, ",");
   ```
   Метод `Insert` вставляет подстроку в указанную позицию исходной строки.

6. **Метод `String.CopyTo`**:
   ```c#
   string str6 = "Привет";
   char[] destination = new char[7];
   str6.CopyTo(0, destination, 0, str6.Length);
   ```
   Метод `CopyTo` копирует определённое количество символов из строки в массив символов.

### Операция `+` и метод `String.Concat`

В C# для объединения строк можно использовать как оператор `+`, так и метод `String.Concat`.

- **Оператор `+`**:
  ```c#
  string greeting = "Привет" + ", " + "мир" + "!";
  ```
  Оператор `+` упрощает объединение строк, делая код более читаемым. Однако при множественном объединении он может быть менее эффективен, так как создаёт временные объекты строк.

- **Метод `String.Concat`**:
  ```c#
  string greeting = String.Concat("Привет", ", ", "мир", "!");
  ```
  Метод `Concat` напрямую объединяет строки без создания промежуточных объектов, что может быть более эффективно при объединении большого количества строк.

### Рекомендации по использованию

- **Оператор `+`**: Подходит для объединения небольшого количества строк в простых выражениях.

- **Метод `String.Concat`**: Рекомендуется использовать при необходимости объединения большого числа строк или в циклах, где важна производительность.

- **Класс `StringBuilder`**: Для частого или интенсивного объединения строк рекомендуется использовать `StringBuilder`, который обеспечивает более эффективную работу с изменяемыми строками.

  ```c#
  StringBuilder sb = new StringBuilder();
  sb.Append("Привет");
  sb.Append(", ");
  sb.Append("мир");
  sb.Append("!");
  string result = sb.ToString();
  ```

Использование `StringBuilder` позволяет избежать создания множества временных объектов и улучшает производительность при множественных операциях со строками.

И попрактикуемся!

Создай консольное приложение `ex0061_string_create` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```C#
using System;
using System.Text;

class Program
{
    static void Main(string[] args)
    {
        // 1. Создание строки через литералы
        string literalString = "Привет, мир!";
        WriteLine("Литерал строки: " + literalString);

        // 2. Создание строки из массива символов
        char[] chars = { 'П', 'р', 'и', 'в', 'е', 'т' };
        string charArrayString = new string(chars);
        WriteLine("Строка из массива символов: " + charArrayString);

        // 3. Использование String.Concat
        string concatString = String.Concat("Привет", ", ", "мир", "!");
        WriteLine("String.Concat: " + concatString);

        // 4. Использование String.Join
        string[] words = { "Привет", "мир" };
        string joinString = String.Join(", ", words);
        WriteLine("String.Join: " + joinString);

        // 5. Использование String.Insert
        string insertString = "Привет мир";
        insertString = insertString.Insert(6, ",");
        WriteLine("String.Insert: " + insertString);

        // 6. Использование String.CopyTo
        string copyString = "Привет";
        char[] destination = new char[7];
        copyString.CopyTo(0, destination, 0, copyString.Length);
        WriteLine("String.CopyTo: " + new string(destination));

        // 7. Использование оператора +
        string plusString = "Привет" + ", " + "мир" + "!";
        WriteLine("Оператор +: " + plusString);

        // 8. Использование StringBuilder
        StringBuilder sb = new StringBuilder();
        sb.Append("Привет");
        sb.Append(", ");
        sb.Append("мир");
        sb.Append("!");
        string stringBuilderString = sb.ToString();
        WriteLine("StringBuilder: " + stringBuilderString);
    }
}
```

#### Объяснение программы
1. **Литералы**: Самый простой способ создания строки.
2. **Массив символов**: Преобразование массива символов в строку.
3. **String.Concat**: Конкатенация строк. Используется для объединения нескольких строк.
4. **String.Join**: Создаёт строку из коллекции, добавляя разделитель.
5. **String.Insert**: Вставляет строку в указанное место.
6. **String.CopyTo**: Копирует символы из строки в массив символов.
7. **Оператор `+`**: Удобный, но менее эффективный при частых операциях.
8. **StringBuilder**: Используется для частого изменения строки.

#### Вывод программы:

```
Литерал строки: Привет, мир!
Строка из массива символов: Привет
String.Concat: Привет, мир!
String.Join: Привет, мир
String.Insert: Привет, мир
String.CopyTo: Привет
Оператор +: Привет, мир!
StringBuilder: Привет, мир!
```

## Конкатенация строк и подстановка значений в строки

В C# объединение строк и подстановку значений в строки можно выполнять разными способами: от базового использования 
оператора `+` до современных, более удобных механизмов, таких как интерполяция строк. Рассмотрим основные подходы.

### **1. Конкатенация строк**

#### **Использование оператора `+`**
Оператор `+` объединяет строки, добавляя их друг к другу. Это самый простой способ объединения строк.

Пример:
```C#
string firstName = "Иван";
string lastName = "Петров";

string fullName = firstName + " " + lastName;
Console.WriteLine(fullName); // Вывод: Иван Петров
```

#### **Проблемы с конкатенацией строк:**
1. **Читаемость:** Если строк много или они сложные, такой код становится трудно читаемым.
2. **Производительность:** При большом числе операций конкатенации создается много временных объектов, что может замедлить программу (особенно в циклах).

### **2. Подстановка значений в строки**

#### **Старый способ: Метод `string.Format`**
Метод `string.Format` позволяет подставлять значения в строку, используя плейсхолдеры `{0}`, `{1}` и т.д.

Пример:
```C#
string name = "Иван";
int age = 25;

string message = string.Format("Меня зовут {0}, мне {1} лет.", name, age);
Console.WriteLine(message); // Вывод: Меня зовут Иван, мне 25 лет.
```

- Плейсхолдеры заменяются значениями, переданными в `string.Format`.
- Это читабельнее, чем использование `+`, если строка большая.

#### **Старый способ с `Console.WriteLine`**
`Console.WriteLine` позволяет напрямую использовать плейсхолдеры без вызова `string.Format`.

Пример:
```C#
Console.WriteLine("Первое число {0}, второе число {1}", 1, 2);
// Вывод: Первое число 1, второе число 2
```

**Почему это работает?** Метод `Console.WriteLine` вызывает `string.Format` внутри себя.

### **3. Современный способ: Интерполяция строк**

Интерполяция строк (добавлена в C# 6.0) позволяет встроить значения переменных прямо в строку, используя `$"..."`.

Пример:
```C#
string name = "Иван";
int age = 25;

string message = $"Меня зовут {name}, мне {age} лет.";
Console.WriteLine(message); // Вывод: Меня зовут Иван, мне 25 лет.
```

**Преимущества:**
- Простой и читабельный синтаксис.
- Можно вставлять сложные выражения:
  ```C#
  Console.WriteLine($"7 + 4 = {7 + 4}"); // Вывод: 7 + 4 = 11
  ```

### **Ошибки при конкатенации строк и числовых значений**
>При объединении строки с числом, число автоматически преобразуется в строку!
> {style="warning"}

#### Пример ошибки:
```C#
Console.WriteLine("Сумма 7 + 4 = " + 7 + 4);
```

**Ожидаемый результат:**  
`Сумма 7 + 4 = 11`

**Фактический результат:**  
`Сумма 7 + 4 = 74`

**Почему так происходит?**
- Оператор `+` сначала объединяет строку `"Сумма 7 + 4 = "` с числом `7`, преобразуя число в строку. Затем объединяет эту строку с числом `4`, снова преобразуя число в строку.

#### **Как исправить:**
Используйте скобки для выполнения арифметического выражения перед конкатенацией:
```C#
Console.WriteLine("Сумма 7 + 4 = " + (7 + 4));
// Вывод: Сумма 7 + 4 = 11
```

Или используйте интерполяцию строк:
```C#
Console.WriteLine($"Сумма 7 + 4 = {7 + 4}");
// Вывод: Сумма 7 + 4 = 11
```

### **Какой способ выбрать?**

- **Конкатенация с `+`:** Используйте только для простых операций.
- **Метод `string.Format`:** Подходит для работы со строками в старом коде.
- **Интерполяция строк:** Рекомендуется в новых проектах, так как это самый читабельный и мощный способ работы со строками.

## Сравнение строк

В программировании сравнение данных — это как проверка паспортов: иногда нужно убедиться, что у вас одинаковые 
имена (сравнение содержимого), а иногда — что вы стоите в одной очереди (сравнение ссылок). 
Строки в C# имеют свои особенности при сравнении, что делает работу с ними удобной, но иногда запутанной. 
Сейчас мы рассмотрим все доступные инструменты для сравнения строк в C#, 
включая операторы `==` и `!=`, методы `Equals`, `Compare`, `CompareTo`, а также разберем, как сравниваются ссылки.

### **Основы сравнения строк** {id="1_1"}
В C# строки представлены классом `string`, который является **immutable** (неизменяемым). Это значит, что после создания строка не может быть изменена, а операции над строками создают новые объекты. Для сравнения строк можно использовать:
1. Операторы `==` и `!=`.
2. Методы `Equals`, `Compare`, `CompareTo`.
3. Явное сравнение ссылок через `object.ReferenceEquals`.

Эти инструменты позволяют сравнивать строки по содержимому или ссылкам в зависимости от потребностей.

### **Сравнение строк через операторы `==` и `!=`** {id="2_1"}
В отличие от большинства классов, операторы `==` и `!=` для строк переопределены. Это позволяет сравнивать строки **по содержимому**.

#### Пример:
```c#
string str1 = "hello";
string str2 = "hello";
string str3 = "world";

Console.WriteLine(str1 == str2); // True, содержимое строк совпадает
Console.WriteLine(str1 != str3); // True, содержимое строк различается
```

### **Как строки сравниваются на уровне реализации?** {id="3_1"}
Когда вы используете `==` или `!=`, фактически вызывается метод `string.Equals`. Этот метод:
- Сравнивает строки побайтово.
- Возвращает `true`, если содержимое строк идентично, даже если ссылки различны.
- Сравнивает `null` корректно: если обе строки равны `null`, результат `true`.

#### Пример:
```c#
string str1 = null;
string str2 = null;

Console.WriteLine(str1 == str2); // True, обе строки null
Console.WriteLine(str1 != str2); // False
```

### **Явное сравнение ссылок**
Если нужно сравнить именно ссылки (адреса объектов в памяти), используйте `object.ReferenceEquals`. Это полезно для проверки, интернированы ли строки или ссылаются ли они на один и тот же объект.

#### Пример:
```c#
string str1 = "hello";
string str2 = "hello";
string str3 = new string("hello".ToCharArray());

Console.WriteLine(object.ReferenceEquals(str1, str2)); // True, благодаря интернированию
Console.WriteLine(object.ReferenceEquals(str1, str3)); // False, разные объекты
```

### **Сравнение строк с помощью методов**
Класс `string` предоставляет несколько методов для сравнения:

#### **5.1. Метод [Equals](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.equals)**
Сравнивает строки **по содержимому**. Существует два варианта:
1. Без параметров (регистр учитывается).
2. С параметром `StringComparison` для указания настроек сравнения (например, игнорирование регистра).

#### Пример:
```c#
string str1 = "hello";
string str2 = "Hello";

Console.WriteLine(str1.Equals(str2)); // False, регистр учитывается
Console.WriteLine(str1.Equals(str2, StringComparison.OrdinalIgnoreCase)); // True, регистр игнорируется
```

#### **Метод [Compare](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.compare)**
Сравнивает строки и возвращает:
- `0`, если строки равны.
- Отрицательное значение, если первая строка меньше второй.
- Положительное значение, если первая строка больше второй.

Этот метод позволяет указать настройки сравнения, например, игнорирование регистра.

#### Пример:
```c#
string str1 = "apple";
string str2 = "banana";

int result = string.Compare(str1, str2, StringComparison.OrdinalIgnoreCase);
Console.WriteLine(result); // Отрицательное значение, "apple" меньше "banana"
```

#### **Метод [CompareTo](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.compareto)**
Метод `CompareTo` работает аналогично `Compare`, но вызывается на экземпляре строки и не принимает дополнительных параметров.

#### Пример:
```c#
string str1 = "apple";
string str2 = "banana";

int result = str1.CompareTo(str2);
Console.WriteLine(result); // Отрицательное значение, "apple" меньше "banana"
```

### **Сравнение строк и других объектов**
Операторы `==` и `!=` для большинства объектов (например, пользовательских классов) сравнивают **ссылки**, если их не переопределить. Класс `string` переопределяет эти операторы, поэтому сравнение выполняется по содержимому.

#### Таблица поведения:
| **Тип**         | **Сравнение по умолчанию** | **Примечание**                                                                                           |
|------------------|---------------------------|---------------------------------------------------------------------------------------------------------|
| `string`         | По содержимому            | Операторы `==` и `!=` переопределены для сравнения значений.                                            |
| Другие классы    | По ссылкам                | Операторы `==` и `!=` сравнивают ссылки, если их не переопределить.                                     |
| Структуры        | По значению               | Например, для структур `Point` операторы сравнивают все поля, если структура не переопределяет поведение. |


А теперь к практике, падаван!

Создай консольное приложение `ex0051_string_compare` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```c#
using System;

class Program
{
    static void Main()
    {
        string str1 = "hello";
        string str2 = "Hello";
        string str3 = new string("hello".ToCharArray());

        // Операторы == и !=
        WriteLine(str1 == str2); // False
        WriteLine(str1 != str2); // True

        // Метод Equals
        WriteLine(str1.Equals(str2)); // False
        WriteLine(str1.Equals(str2, StringComparison.OrdinalIgnoreCase)); // True

        // Сравнение ссылок
        WriteLine(object.ReferenceEquals(str1, str3)); // False

        // Compare
        WriteLine(string.Compare(str1, str2, StringComparison.OrdinalIgnoreCase)); // 0

        // CompareTo
        WriteLine(str1.CompareTo(str2)); // Отрицательное значение, "hello" меньше "Hello"
    }
}
```
Вывод программы:
```
False
True 
False
True 
False
0    
-1
```

### **Заключение**
Сравнение строк в C# — это мощный инструмент, благодаря переопределению операторов `==` и `!=` и предоставлению 
специализированных методов. Вы можете использовать простые операторы для сравнения значений и 
при необходимости уточнять логику с помощью методов `Equals`, `Compare` и `CompareTo`. Главное — помнить, что для 
строк сравнивается содержимое, а для других объектов по умолчанию сравниваются ссылки.

## Продвинутые методы сравнения строк

В этом разделе мы быстро пройдёмся по продвинутым методам сравнения строк.
А так же освежим парочку методов из предыдущего поста, чтобы понять разницу между тремя очень похожими по названию методами.

1. **[String.CompareOrdinal](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.compareordinal)**
   - Этот метод сравнивает строки **побайтово** (используя коды символов) и **игнорирует настройки культуры**.
   - Используется, если нужен точный и быстрый побайтовый порядок, без учета локальных правил языка.
   - Возвращает:
      - `0` — строки равны,
      - `< 0` — первая строка меньше второй,
      - `> 0` — первая строка больше второй.

   **Пример:**
   ```C#
   int result = String.CompareOrdinal("apple", "banana");
   Console.WriteLine(result); // -1, так как 'a' меньше 'b' в таблице символов.
   ```

2. **[String.Compare](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.compare)**
   - Сравнивает строки с учетом или без учета регистра и может учитывать локальные правила языка (культуры).
   - Возвращает те же значения, что и `CompareOrdinal`.

   **Пример:**
   ```C#
   int result = String.Compare("apple", "Apple", true); // true — игнорируем регистр
   Console.WriteLine(result); // 0, так как регистр игнорируется.
   ```

3. **[String.CompareTo](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.compareto)**
   - Вызывается у конкретной строки и сравнивает её с другой строкой.
   - Это **упрощённый вариант**, который не позволяет настроить параметры (например, игнорировать регистр).
   - Возвращает те же значения, что и `Compare`.

   **Пример:**
   ```C#
   int result = "apple".CompareTo("banana");
   Console.WriteLine(result); // -1, так как 'apple' меньше 'banana'.
   ```

4. **[String.StartsWith](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.startswith)**
   - Проверяет, **начинается ли строка** с указанного подстроки.
   - Возвращает `true` или `false`.

   **Пример:**
   ```C#
   bool result = "hello world".StartsWith("hello");
   Console.WriteLine(result); // true, строка начинается с "hello".
   ```

5. **[String.EndsWith](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.endswith)**
   - Проверяет, **заканчивается ли строка** на указанную подстроку.
   - Возвращает `true` или `false`.

   **Пример:**
   ```C#
   bool result = "hello world".EndsWith("world");
   Console.WriteLine(result); // true, строка заканчивается на "world".
   ```

6. **[String.Contains](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.contains)**
   - Проверяет, **содержит ли строка** указанную подстроку.
   - Возвращает `true` или `false`.

   **Пример:**
   ```C#
   bool result = "hello world".Contains("lo wo");
   Console.WriteLine(result); // true, строка содержит "lo wo".
   ```

7. **[String.IndexOf](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.indexof)**
   - Возвращает индекс первого вхождения указанной подстроки.
   - Если подстрока не найдена, возвращает `-1`.

   **Пример:**
   ```C#
   int index = "hello world".IndexOf("world");
   Console.WriteLine(index); // 6, так как "world" начинается с позиции 6.
   ```

8. **[String.LastIndexOf](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.lastindexof)**
   - Возвращает индекс последнего вхождения указанной подстроки.
   - Если подстрока не найдена, возвращает `-1`.

   **Пример:**
   ```C#
   int index = "hello world world".LastIndexOf("world");
   Console.WriteLine(index); // 12, последнее вхождение "world" начинается с позиции 12.
   ```

А теперь закрепим это все на практике.

Создай консольное приложение `ex0053_string_advanced_compare` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```C#
using System;

class Program
{
    static void Main()
    {
        // CompareOrdinal
        int compareOrdinal = String.CompareOrdinal("apple", "banana");
        WriteLine($"CompareOrdinal: {compareOrdinal}");

        // Compare
        int compare = String.Compare("apple", "Apple", true);
        WriteLine($"Compare (ignore case): {compare}");

        // CompareTo
        int compareTo = "apple".CompareTo("banana");
        WriteLine($"CompareTo: {compareTo}");

        // StartsWith
        bool startsWith = "hello world".StartsWith("hello");
        WriteLine($"StartsWith: {startsWith}");

        // EndsWith
        bool endsWith = "hello world".EndsWith("world");
        WriteLine($"EndsWith: {endsWith}");

        // Contains
        bool contains = "hello world".Contains("lo wo");
        WriteLine($"Contains: {contains}");

        // IndexOf
        int indexOf = "hello world".IndexOf("world");
        WriteLine($"IndexOf: {indexOf}");

        // LastIndexOf
        int lastIndexOf = "hello world world".LastIndexOf("world");
        WriteLine($"LastIndexOf: {lastIndexOf}");
    }
}
```

Вывод программы:
```
CompareOrdinal: -1
Compare (ignore case): 0
CompareTo: -1   
StartsWith: True
EndsWith: True  
Contains: True  
IndexOf: 6
LastIndexOf: 12
```

Давайте разберём каждую строку программы чтобы, понять почему выводятся именно такие значения.

### **`CompareOrdinal`**
```C#
int compareOrdinal = String.CompareOrdinal("apple", "banana");
WriteLine($"CompareOrdinal: {compareOrdinal}");
```

1. `String.CompareOrdinal` сравнивает строки **побайтово** (по кодам символов Unicode).
2. Сравниваем строки `"apple"` и `"banana"`. Первый различающийся символ: `'a'` из `"apple"` и `'b'` из `"banana"`.
3. В таблице Unicode код символа `'a'` меньше кода символа `'b'`. Поэтому результат: **`-1`** (первая строка меньше второй).

### **`Compare`** {id="compare_1"}
```C#
int compare = String.Compare("apple", "Apple", true);
WriteLine($"Compare (ignore case): {compare}");
```

1. `String.Compare` может учитывать или игнорировать регистр. В данном случае `true` означает, что регистр игнорируется.
2. Сравниваем `"apple"` и `"Apple"`. Если игнорировать регистр, строки становятся одинаковыми: `"apple"` == `"apple"`.
3. Поэтому результат: **`0`** (строки равны).

### **`CompareTo`** {id="compareto_1"}
```C#
int compareTo = "apple".CompareTo("banana");
WriteLine($"CompareTo: {compareTo}");
```

1. `CompareTo` сравнивает строки, как `String.Compare`, но всегда учитывает регистр и использует настройки текущей культуры.
2. `"apple"` меньше `"banana"`, так как `'a'` меньше `'b'` в алфавитном порядке.
3. Поэтому результат: **`-1`** (первая строка меньше второй).

### **`StartsWith`**
```C#
bool startsWith = "hello world".StartsWith("hello");
WriteLine($"StartsWith: {startsWith}");
```

1. `StartsWith` проверяет, начинается ли строка `"hello world"` с подстроки `"hello"`.
2. Первая часть строки (`"hello"`) совпадает с подстрокой `"hello"`.
3. Поэтому результат: **`true`** (строка действительно начинается с `"hello"`).

### **`EndsWith`**
```C#
bool endsWith = "hello world".EndsWith("world");
WriteLine($"EndsWith: {endsWith}");
```

1. `EndsWith` проверяет, заканчивается ли строка `"hello world"` подстрокой `"world"`.
2. Последняя часть строки (`"world"`) совпадает с подстрокой `"world"`.
3. Поэтому результат: **`true`** (строка действительно заканчивается на `"world"`).

### **`Contains`**
```C#
bool contains = "hello world".Contains("lo wo");
WriteLine($"Contains: {contains}");
```

1. `Contains` проверяет, содержится ли подстрока `"lo wo"` внутри строки `"hello world"`.
2. Строка `"hello world"` действительно содержит последовательность символов `"lo wo"`.
3. Поэтому результат: **`true`** (подстрока найдена).

### **`IndexOf`**
```C#
int indexOf = "hello world".IndexOf("world");
WriteLine($"IndexOf: {indexOf}");
```

1. `IndexOf` возвращает индекс первого вхождения подстроки `"world"` в строку `"hello world"`.
2. Подстрока `"world"` начинается с позиции 6 (индексация с нуля).
3. Поэтому результат: **`6`**.

### **`LastIndexOf`**
```C#
int lastIndexOf = "hello world world".LastIndexOf("world");
WriteLine($"LastIndexOf: {lastIndexOf}");
```

1. `LastIndexOf` возвращает индекс **последнего вхождения** подстроки `"world"` в строку `"hello world world"`.
2. Подстрока `"world"` встречается дважды: на позициях 6 и 12.
3. Последнее вхождение начинается с позиции 12.
4. Поэтому результат: **`12`**.

### Ещё рза вывод программы с пояснениями:
```
CompareOrdinal: -1       // "apple" меньше "banana".
Compare (ignore case): 0 // "apple" равен "Apple" при игнорировании регистра.
CompareTo: -1            // "apple" меньше "banana".
StartsWith: True         // "hello world" начинается с "hello".
EndsWith: True           // "hello world" заканчивается на "world".
Contains: True           // "hello world" содержит "lo wo".
IndexOf: 6               // Первое вхождение "world" начинается с позиции 6.
LastIndexOf: 12          // Последнее вхождение "world" начинается с позиции 12.
```

## Интерполяция строк

**Интерполяция строк** в C# — это удобный способ работы со строками, который позволяет включать в строковый 
литерал выражения и автоматически преобразовывать их в текст. Вместо сложных методов форматирования, интерполяция 
делает код более понятным и читаемым.

Символ `$` перед строковым литералом указывает компилятору, что это интерполированная строка. Внутри такой строки можно использовать выражения, заключённые в фигурные скобки `{}`, которые будут автоматически заменены их значениями.

### Преимущества интерполяции строк

1. **Простота и читаемость**: Форматирование становится более интуитивным и удобным.
2. **Универсальность**: Поддерживает сложные выражения, выравнивание, форматирование дат, чисел и других данных.
3. **Гибкость**: Легко комбинируется с шаблонами, например, сопоставлением.

### Сравнение с составным форматированием

Рассмотрим два примера:

```C#
var name = "Мария";
var date = DateTime.Now;

// Составное форматирование
Console.WriteLine("Привет, {0}! Сегодня {1}, текущее время {2:HH:mm}.", name, date.DayOfWeek, date);

// Интерполяция строк
Console.WriteLine($"Привет, {name}! Сегодня {date.DayOfWeek}, текущее время {date:HH:mm}.");
```

Оба примера выведут одинаковый результат, например:  
`Привет, Мария! Сегодня Понедельник, текущее время 14:30.`

Интерполяция строк более лаконична и наглядна.

### Как работает интерполяция строк?

- **Символ `$`** указывает на интерполированную строку.
- **Выражения внутри `{}`** заменяются их текстовыми значениями при выполнении программы.
- **Фигурные скобки** могут содержать не только переменные, но и любые выражения (например, математические операции).

### Структура интерполированной строки

Каждое выражение интерполяции имеет следующий синтаксис:

```C#
{<выражение>[,<выравнивание>][:<строка_формата>]}
```

#### Пояснения:
1. **`выражение`** — переменная или операция, результат которой нужно вставить в строку.
2. **`выравнивание`** (опционально) — минимальная ширина результата. Если положительное, текст выравнивается по правому краю, если отрицательное — по левому.
3. **`строка_формата`** (опционально) — формат вывода значения. Например, для чисел можно указать количество знаков после запятой, а для дат — формат отображения.

### Примеры выравнивания и форматирования

#### Выравнивание текста
```C#
Console.WriteLine($"|{"Слева",-10}|{"Справа",10}|");
```
Результат:
```
|Слева     |     Справа|
```

#### Форматирование чисел
```C#
const int Width = 15;
Console.WriteLine($"{Math.PI,Width} - значение числа Пи по умолчанию");
Console.WriteLine($"{Math.PI,Width:F3} - Пи с тремя знаками после запятой");
```
Результат:
```
          3.14159265358979 - значение числа Пи по умолчанию  
                    3.142 - Пи с тремя знаками после запятой
```

### Использование шаблонов с интерполяцией

С C# 11 стало проще форматировать длинные выражения. Например, сопоставление температур с комфортностью:

```C#
class Program
{
    static void Main()
    {
        var temperature = 25;

        string message = $"Температура {temperature}°C считается {temperature switch
        {
            <= -40 => "смертельно опасной",
            <= -25 => "очень холодной, опасной",
            <= 0 => "холодной, но приемлемой",
            <= 19 => "прохладной",
            <= 27 => "комфортной",
            <= 36 => "жаркой",
            <= 45 => "очень жаркой",
            _ => "черезмерно жаркой и опасной",
        }}.";
        WriteLine(message);
    }
}
```

#### Результаты:
- Для `-15°C`: `Температура -15°C считается холодной, но приемлемой.`
- Для `25°C`: `Температура 25°C считается комфортной.`

### Особенности

- Интерполяция поддерживает только те выражения, которые доступны в контексте выполнения программы.
- Интерполяция строки может быть использована для создания **константной строки** только если все выражения в ней — это константы.

### Заключение

Интерполяция строк — мощный инструмент C#, который делает форматирование строк удобным и читаемым. 
Она упрощает написание кода и улучшает его понимание, особенно в случаях, когда нужно работать со сложными 
выражениями или форматировать данные.

## Форматирование в интерполированных строках

Вообще [форматирование строк и других типов](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/formatting-types), 
можно использовать не только в интерполированных строках. Но уж поскольку мы сейчас рассматривали интерполяцию строк,
то познакомимся с форматированием строк в этом контексте, тем более что этот кейс используется чаще всего.

[Тема форматирования строк и других типов очень обширна](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/formatting-types), 
так как предлагает множество вариантов на все случаи жизни. Поэтому так же рекомендую пройти по ссылке и ознакомиться с ней.
Тут же мы рассмотри только основные моменты, чтобы было понятие об этой теме.

Ещё рза структура форматирования для интерполированных строк:
```C#
{<выражение>[,<выравнивание>][:<строка_формата>]}
```

### Компоненты форматирования:

1. **Выражение**  
   Любое корректное C# выражение. Например:
   ```C#
   int a = 5, b = 10;
   Console.WriteLine($"Сумма: {a + b}"); // Сумма: 15
   ```

2. **Выравнивание**  
   Определяет минимальную ширину строки:
   - Положительное число — выравнивание по правому краю.
   - Отрицательное число — выравнивание по левому краю.
   ```C#
   Console.WriteLine($"|{"Лево",-10}|{"Право",10}|");
   // |Лево      |     Право|
   ```

3. **Строка формата**  
   Спецификаторы, задающие вид [числа](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/standard-numeric-format-strings), [даты](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/standard-date-and-time-format-strings), [времени](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/custom-date-and-time-format-strings) или строки.

### Примеры форматирования

#### Числа

1. **[Целые числа](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/standard-numeric-format-strings)**
   - **`D` (Decimal):** минимальное количество цифр.
   - **`X` (Hexadecimal):** шестнадцатеричный формат.
   - **`N` (Number):** разделители разрядов.
   ```C#
   int value = 255;
   Console.WriteLine($"Десятичное: {value:D5}"); // 00255
   Console.WriteLine($"Шестнадцатеричное: {value:X}"); // FF
   Console.WriteLine($"Разделители: {value:N0}"); // 255
   ```

2. **[Дробные числа](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/standard-numeric-format-strings)**
   - **`F` (Fixed-point):** количество знаков после запятой.
   - **`E` (Exponential):** экспоненциальный формат.
   - **`P` (Percent):** процент.
   ```C#
   double pi = 3.14159;
   Console.WriteLine($"Фиксированная точка: {pi:F2}"); // 3.14
   Console.WriteLine($"Экспоненциально: {pi:E2}"); // 3.14E+000
   Console.WriteLine($"Процент: {pi:P2}"); // 314.16%
   ```

3. **[Бинарные числ](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/standard-numeric-format-strings#BFormatString)а (c .NET 8)**  
   Используем встроенный метод `Convert.ToString`:
   ```C#
   int number = 42;
   Console.WriteLine($"Бинарное: {Convert.ToString(number, 2)}"); // 101010
   ```

#### Даты и время

1. **[Форматы даты и времени](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/standard-date-and-time-format-strings)**
   - **`d` (Short date):** 28.12.2024
   - **`D` (Long date):** 28 декабря 2024 г.
   - **`T` (Full time):** 18:45:30
   ```C#
   DateTime now = DateTime.Now;
   Console.WriteLine($"Краткая дата: {now:d}");
   Console.WriteLine($"Полная дата: {now:D}");
   Console.WriteLine($"Время: {now:T}");
   ```

2. **[Кастомные шаблоны](https://learn.microsoft.com/ru-ru/dotnet/standard/base-types/custom-date-and-time-format-strings)**
   ```C#
   Console.WriteLine($"{now:dd-MMM-yyyy}"); // 28-Dec-2024
   Console.WriteLine($"{now:HH:mm:ss}");   // 18:45:30
   ```

#### Валюта
Используйте формат **`C`**:
```C#
decimal price = 1234.56m;
Console.WriteLine($"Цена: {price:C2}"); // Цена: 1 234,56 ₽
```

Закрепим это всё на практике.

Создай консольное приложение `ex0052_string_interpolation` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```C#
using System;

class Program
{
    static void Main()
    {
        // Пример 1: Форматирование целых чисел
        int number = 123456;
        WriteLine($"Обычное число: {number}");
        WriteLine($"Число c дополнительными разрядами слева: {number:D10}");
        WriteLine($"Число с выравниванием по правому краю (10 символов): {number,12}");
        WriteLine($"Число с выравниванием по левому краю (-10 символов): {number,-12}");
        WriteLine($"Число в двоичном формате: {number:b}");
        WriteLine($"Число в шестнадцатиричном формате: {number:X}"); // большие буквы в выводимых значениях
        WriteLine($"Число в шестнадцатиричном формате: {number:x}"); // маленькие буквы в выводимых значениях
        WriteLine($"Число с разделением на разряды: {number:N0}");

        // Пример 2: Форматирование дробных чисел
        double pi = Math.PI;
        WriteLine($"Число Pi: {pi}");
        WriteLine($"Число Pi (2 знака после запятой): {pi:F2}");
        WriteLine($"Число Pi (4 знака после запятой): {pi:F4}");
        WriteLine($"Проценты: {(double)number/1000000:P4}"); //скомбинирорвано выражение приведения к double и деление

        // Пример 3: Форматирование валют
        decimal price = 1234.4321m;
        WriteLine($"Цена: {price:C}"); // C - валюта по умолчанию для текущей культуры
        WriteLine($"Цена (4 знака после запятой): {price:C4}"); // выдуманный пример для примера :)

        // Пример 4: Форматирование дат и времени
        DateTime now = DateTime.Now;
        WriteLine($"Текущая дата и время: {now}");
        WriteLine($"Только дата: {now:yyyy-MM-dd}");
        WriteLine($"Только дата: {now:dd MMMM yyyy}");
        WriteLine($"День недели и дата: {now:dddd dd MMMM yyyy}");
        WriteLine($"Только время: {now:HH:mm:ss}");

        // Пример 5: Комбинация выравнивания и форматирования
        WriteLine($"|{"Название",-15}|{"Значение",15}|");
        WriteLine($"|{"Pi",-15}|{pi,15:F3}|");
        WriteLine($"|{"Цена",-15}|{price,15:C2}|");

        // Пример 6: Сопоставление шаблонов с интерполяцией строк
        // Объяснение:
        // Этот код использует сопоставление шаблонов (pattern matching) для определения 
        // диапазона температур и соответствующего описания.
        // `switch` проверяет значение переменной `temperature` по порядку сверху вниз.
        // Как только совпадение найдено, оно возвращает результат и остальные условия не проверяются.
        var temperature = 25;
        string message = $"Температура {temperature}°C считается {temperature switch
        {
            <= -40 => "смертельно опасной",     // Если температура <= -40
            <= -25 => "очень холодной, опасной", // Если температура от -40 до -25
            <= 0 => "холодной, но приемлемой",   // Если температура от -25 до 0
            <= 19 => "прохладной",               // Если температура от 0 до 19
            <= 27 => "комфортной",               // Если температура от 19 до 27
            <= 36 => "жаркой",                   // Если температура от 27 до 36
            <= 45 => "очень жаркой",             // Если температура от 36 до 45
            _ => "чрезмерно жаркой и опасной",   // Любая температура больше 45
        }}.";
        WriteLine(message);
    }
}
```

Оператор `switch` мы тоже пока не проходили, но в комментариях я дал краткое пояснение как он работает.

Вывод программы:

```
Обычное число: 123456
Число c дополнительными разрядами слева: 0000123456
Число с выравниванием по правому краю (10 символов):       123456
Число с выравниванием по левому краю (-10 символов): 123456
Число в двоичном формате: 11110001001000000
Число в шестнадцатиричном формате: 1E240
Число в шестнадцатиричном формате: 1e240
Число с разделением на разряды: 123 456
Число Pi: 3,141592653589793
Число Pi (2 знака после запятой): 3,14
Число Pi (4 знака после запятой): 3,1416
Проценты: 12,3456 %
Цена: 1 234,43 ₽
Цена (4 знака после запятой): 1 234,4321 ₽
Текущая дата и время: 28.12.2024 13:10:56
Только дата: 2024-12-28
Только дата: 28 декабря 2024
День недели и дата: суббота 28 декабря 2024
Только время: 13:10:56
|Название       |       Значение|
|Pi             |          3,142|
|Цена           |     1 234,43 ₽|
Температура 25°C считается комфортной.
```

>Символ валюты может у вас отличаться. Это зависит от ваших региональных настроек.
> {style="note"}

## Дословный (verbatim) текст в строковых литералах

**[Дословные строки](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/tokens/verbatim)** в C# 
определяются с использованием символа `@` перед строкой. Они позволяют записывать текст **"как есть"**, 
без необходимости использования escape-последовательностей. Это полезно для строк, содержащих символы `\`, `"`, 
или многострочные значения.

### **Для чего нужны дословные строки?**

1. **Чтение путей файлов**:
   Например, строка `"C:\tvstock\new2024\"` интерпретируется компилятором, и символы `\t`, `\n` распознаются как **табуляция** и **новая строка**, вызывая поведение которого не ожидалось. Чтобы избежать этого, используется дословный литерал:  
   `@"C:\tvstock\new2024\"`.

**Пояснение примера с путем до файла**
```C#
string pathToFile = "C:\tvstock\new2024\";
```

- Компилятор видит строку и интерпретирует `\t` как символ табуляции, а `\n` как переход на новую строку, что вообще вызовет ошибку компиляции.
- Это вызывает **неожиданное поведение**:
  - Строка становится: `"C:    vstockew2024"` (с табуляцией вместо `\t` и ожиданием двойной кавычки после `\n` для завершения строки, что и вызывает ошибку компиляции).
- Чтобы избежать такого поведения, можно записать эту строку так:
  - Экранировать символы: `"C:\\tvstock\\new2024\\"`
  - Использовать дословный литерал: `@"C:\tvstock\new2024\"`.

2. **Многострочные строки**:
   Дословные строки позволяют писать текст на нескольких строках, например:
   ```C#
   string message = @"Это строка
   на нескольких строках
   без использования escape-последовательностей.";
   ```

3. **Упрощение работы с символами `\` и `"`**:
   В дословных строках можно использовать `\` и `"` без необходимости их экранировать:
   ```C#
   string quote = @"Она сказала: ""Привет!""";
   ```

### **Escape-последовательности** (вспомним некоторые из них) {id="escape_1"}

**Escape-последовательности** используются в строках, которые не являются дословными (без `@`). Они начинаются с символа `\` и представляют собой специальные символы:

- `\n` – новая строка.
- `\t` – табуляция.
- `\\` – обратный слэш.
- `\"` – двойная кавычка.
- `\uXXXX` – символ Unicode.

**Пример:**
```C#
string path = "C:\\tvstock\\new2024\\";
string quote = "Она сказала: \"Привет!\"";
```

Попрактикуемся чтобы лучше понять эту тему!

Создай консольное приложение `ex0054_verbatim_strings` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```C#
class VerbatimAndEscapeDemo
{
    static void Main()
    {
        // Обычная строка с escape-последовательностями
        string regularPath = "C:\\tvstock\\new2024\\";
        WriteLine($"Обычная строка: {regularPath}");

        // Дословная строка
        string verbatimPath = @"C:\tvstock\new2024\";
        WriteLine($"Дословная строка: {verbatimPath}");

        // Строка с кавычками
        string regularQuote = "Она сказала: \"Привет!\"";
        WriteLine($"Обычная строка с кавычками: {regularQuote}");

        string verbatimQuote = @"Она сказала: ""Привет!""";
        WriteLine($"Дословная строка с кавычками: {verbatimQuote}");

        // Многострочная строка
        string multiline = @"Это первая строка.
Это вторая строка.
Это третья строка.";
        WriteLine("Многострочная строка:");
        WriteLine(multiline);

        // Различия в интерпретации символов
        string escapeSequence = "Строка с табуляцией:\tи переводом строки.\nКонец строки.";
        WriteLine("Обычная строка с escape-последовательностями:");
        WriteLine(escapeSequence);

        string verbatimLiteral = @"Строка с табуляцией:\tи переводом строки.\nКонец строки.";
        WriteLine("Дословная строка (символы интерпретируются буквально):");
        WriteLine(verbatimLiteral);
    }
}
```

### **Объяснение программы**

1. **`regularPath`**: Экранирование символов `\` превращает строку `"C:\\tvstock\\new2024\\"` в корректный путь.
2. **`verbatimPath`**: Дословная строка записана "как есть" без экранирования.
3. **`regularQuote` и `verbatimQuote`**: Показывают разницу между экранированной кавычкой и дословным использованием `""`.
4. **Многострочная строка**: `@"...` позволяет использовать несколько строк без `\n`.
5. **Различия интерпретации**:
   - В `escapeSequence` `\t` создаёт табуляцию, а `\n` — новую строку.
   - В `verbatimLiteral` `\t` и `\n` воспринимаются как текст.

### **Вывод программы**

```
Обычная строка: C:\tvstock\new2024\
Дословная строка: C:\tvstock\new2024\
Обычная строка с кавычками: Она сказала: "Привет!"      
Дословная строка с кавычками: Она сказала: "Привет!"    
Многострочная строка:
Это первая строка.
Это вторая строка.
Это третья строка.
Обычная строка с escape-последовательностями:
Строка с табуляцией:    и переводом строки.
Конец строки.
Дословная строка (символы интерпретируются буквально):  
Строка с табуляцией:\tи переводом строки.\nКонец строки.
```

Эта программа демонстрирует, как использовать оба подхода, их различия и сценарии применения.

## Совместное использование дословного (verbatim) текста и интерполяции {id="verbatim_1"}

C# позволяет комбинировать **дословный литерал (verbatim)** со **строковой интерполяцией** для упрощения 
работы со строками, особенно если они содержат обратные слэши (`\`) или другие специальные символы, 
и при этом требуется вставить значения переменных.

Для обозначения такой строки используется синтаксис: `$@"строка"`.

- Символ `$` включает интерполяцию.
- Символ `@` делает строку дословной, отменяя интерпретацию escape-последовательностей.

### Особенности
1. **Использование переменных в строке**:
   Интерполяция позволяет вставлять значения переменных с помощью `{}`.
2. **Сохранение обратных слэшей**:
   Благодаря `@`, все символы, такие как `\`, воспринимаются буквально, что удобно для файловых путей.
3. **Совместимость**:
   Можно вставлять выражения, вызывать методы, форматировать данные.

### Примеры использования

#### Пример 1: Формирование пути к файлу {id="1_3"}
```C#
string projectName = "MyProject";
string fileName = "report.txt";

// Интерполяция и verbatim одновременно
string filePath = $@"C:\Projects\{projectName}\Output\{fileName}";

Console.WriteLine(filePath);
// Результат: C:\Projects\MyProject\Output\report.txt
```

#### Пример 2: Форматированный текст с многострочными строками {id="2_3"}
```C#
string userName = "Max";
string projectName = "Important-Docs";

// Интерполяция, многострочные строки и verbatim
string message = $@"
Привет, {userName}!
Ваш проект '{projectName}' успешно сохранён.
Путь к проекту: C:\Users\{userName}\Documents\{projectName}\";

Console.WriteLine(message);
/*
Результат:
Привет, Max!
Ваш проект 'Important-Docs' успешно сохранён.
Путь к проекту: C:\Users\Max\Documents\Important-Docs\
*/
```

И опять практика!

Создай консольное приложение `ex0055_verbatim_and_interpolation` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```C#
class VerbatimAndInterpolationDemo
{
    static void Main()
    {
        string userName = "Alex";
        string projectName = "SuperProject";
        string fileName = "results.csv";

        // Формирование файлового пути
        string filePath = $@"C:\Users\{userName}\Projects\{projectName}\{fileName}";

        // Вывод сообщения о сохранении
        string message = $@"
Привет, {userName}!
Ваш проект '{projectName}' был успешно сохранён.
Путь к файлу: {filePath}
Пожалуйста, проверьте содержимое файла.";

        WriteLine(message);
    }
}
```

### Пояснение программы
1. Переменные `userName`, `projectName`, и `fileName` используются внутри строкового литерала.
2. Символы `$` и `@` позволяют одновременно:
   - Выполнять интерполяцию.
   - Указывать обратные слэши дословно.
3. Строка `message` демонстрирует многострочный текст с интерполяцией.

**Результат выполнения программы:**
```
Привет, Alex!
Ваш проект 'SuperProject' был успешно сохранён.
Путь к файлу: C:\Users\Alex\Projects\SuperProject\results.csv
Пожалуйста, проверьте содержимое файла.
```

## Необработанные строковые литералы

В языке C# 11 появились **[необработанный строковый литеральный текст](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/tokens/raw-string)** (Raw string literal text) 
и **[необработанные строковые литералы](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/proposals/csharp-11.0/new-line-in-interpolation)** (Raw string literals), которые значительно упрощают работу с 
многострочными текстами, форматированием, и интерполяцией строк.

### В чем разница между ними?
1. **Необработанный строковый литеральный текст (Raw string literal text):**
   Это текст, записанный внутри строкового литерала, который дословно воспроизводится в строке программы. Он может содержать многострочный текст без необходимости экранирования символов (`\`) или использования escape-последовательностей.

2. **Необработанный строковый литерал (Raw string literal):**
   Это более сложный синтаксис, позволяющий использовать интерполяцию в необработанных строках. Он добавляет поддержку шаблонов, сохранения многострочных блоков кода, а также возможности избегать путаницы с фигурными скобками.

### 1. Необработанный строковый литеральный текст (Raw string literal text)

**Особенности:**
- Вводится с использованием тройных кавычек (`"""`).
- Содержимое между кавычками интерпретируется дословно (raw), включая пробелы, табуляции, переносы строк и специальные символы.
- Удобен для работы с XML, JSON, HTML, SQL запросами или любым другим многострочным текстом.

#### Пример: XML-текст
```C#
var xml = """
<element attr="content">
    <body>
    </body>
</element>
""";
Console.WriteLine(xml);
```
**Результат:**
```
<element attr="content">
    <body>
    </body>
</element>
```

#### Пример: SQL-запрос
```C#
var sqlQuery = """
SELECT * 
FROM Products
WHERE Price > 1000
ORDER BY Name;
""";
Console.WriteLine(sqlQuery);
```
**Результат:**
```
SELECT * 
FROM Products
WHERE Price > 1000
ORDER BY Name;
```

### 2. Необработанный строковый литерал (Raw string literal)

**Особенности:**
- Используется для добавления интерполяции в необработанные строки.
- Поддерживает:
   - **Два знака `$`** для включения интерполяции.
   - **Двойные фигурные скобки `{{` и `}}`** для экранирования `{` и `}` внутри строки.
   - **Тройные фигурные скобки `{{{` и `}}}`** для представления одиночных фигурных скобок в интерполированной строке.

#### Пример: JSON с интерполяцией
```C#
var person = new { FirstName = "John", Age = 30 };
string json = $$"""
{
  "first_name": "{{person.FirstName}}",
  "age": {{person.Age}},
  "calculation": "{{{ 1 + 2 }}}"
}
""";
Console.WriteLine(json);
```
**Результат:**
```json
{
  "first_name": "John",
  "age": 30,
  "calculation": "{3}"
}
```

**Объяснение:**
- `$$` включает интерполяцию.
- `{{person.FirstName}}` и `{{person.Age}}` вставляют значения из объекта.
- `{{{ 1 + 2 }}}` добавляет одинарные фигурные скобки `{}` вокруг результата вычисления.

#### Пример: HTML с вложенной интерполяцией
```C#
string title = "Welcome!";
string message = "This is a raw string literal example.";
var html = $$"""
<html>
  <head><title>{{title}}</title></head>
  <body>
    <p>{{message}}</p>
    <p>Calculation: {{{2 * 5}}}</p>
  </body>
</html>
""";
Console.WriteLine(html);
```
**Результат:**
```html
<html>
  <head><title>Welcome!</title></head>
  <body>
    <p>This is a raw string literal example.</p>
    <p>Calculation: {10}</p>
  </body>
</html>
```

#### Пример: Ещё разметка JSON {id="json_1"}
```C#
string data = "example";
var config = $$"""
{
  "config": {
    "name": "{{data}}",
    "active": true,
    "values": [1, 2, 3]
  }
}
""";
Console.WriteLine(config);
```
**Результат:**
```json
{
  "config": {
    "name": "example",
    "active": true,
    "values": [1, 2, 3]
  }
}
```

Практика!

Создай консольное приложение `ex0056_raw_string_literal` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```C#
class Program
{
    static void Main()
    {
        // 1. Необработанный строковый литеральный текст
        var xml = """
        <element attr="content">
            <body>
            </body>
        </element>
        """;
        WriteLine("Raw String Literal Text (XML):");
        WriteLine(xml);

        var sqlQuery = """
        SELECT * 
        FROM Products
        WHERE Price > 1000
        ORDER BY Name;
        """;
        WriteLine("\nRaw String Literal Text (SQL):");
        WriteLine(sqlQuery);

        // 2. Необработанный строковый литерал с интерполяцией
        var person = new { FirstName = "Alice", Age = 25 };
        string json = $$"""
        {
          "first_name": "{{person.FirstName}}",
          "age": {{person.Age}},
          "calculation": "{{{ 5 + 3 }}}"
        }
        """;
        WriteLine("\nRaw String Literal with Interpolation (JSON):");
        WriteLine(json);

        string title = "Welcome!";
        string message = "Raw string literals in action.";
        var html = $$"""
        <html>
          <head><title>{{title}}</title></head>
          <body>
            <p>{{message}}</p>
            <p>Result of 10 * 2: {{{10 * 2}}}</p>
          </body>
        </html>
        """;
        WriteLine("\nRaw String Literal with Interpolation (HTML):");
        WriteLine(html);
    }
}
```

**Вывод программы:**
```
Raw String Literal Text (XML):
<element attr="content">
    <body>
    </body>
</element>

Raw String Literal Text (SQL):
SELECT *
FROM Products
WHERE Price > 1000
ORDER BY Name;

Raw String Literal with Interpolation (JSON):
{
  "first_name": "Alice",
  "age": 25,
  "calculation": "{8}"
}

Raw String Literal with Interpolation (HTML):
<html>
  <head><title>Welcome!</title></head>       
  <body>
    <p>Raw string literals in action.</p>    
    <p>Result of 10 * 2: {20}</p>
  </body>
</html>
```

### Итог
- **Raw string literal text** используется для работы с многострочным текстом, сохраняя его структуру и формат.
- **Raw string literal** добавляет интерполяцию, поддерживает сложные шаблоны и использование фигурных скобок.
- Эти новые возможности делают код более читаемым и удобным для работы с многострочными данными.

## Строковые литералы UTF-8

**[Строковые литералы UTF-8](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/proposals/csharp-11.0/utf8-string-literals)** 
([UTF-8 String Literals](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-11.0/utf8-string-literals)) 
появились в **C# 11**. Эта новая возможность позволяет задавать строковые литералы в формате **UTF-8** с 
использованием суффикса `u8`.

Сперва мы рассмотрим эту тему как бы концептуально, то есть слелаем обзор этой темы, а затем погрузимся чуть глубже.

### Что такое UTF-8 String Literals? {id="utf-8-string-literals_1"}

UTF-8 String Literals — это строковые литералы, которые компилируются в массивы байтов (`byte[]`) вместо объектов `string`.

#### Основные особенности:
- Строки помечаются суффиксом `u8` (например, `"example"u8`).
- Компилятор автоматически кодирует строку в формате **UTF-8**.
- Позволяет оптимизировать использование строк в сценариях, где требуется байтовое представление данных, например, при взаимодействии с сетевыми протоколами, JSON, бинарными файлами и т. д.


### Зачем нужны UTF-8 String Literals? {id="utf-8-string-literals_2"}

1. **Производительность**:
   - Строки в C# по умолчанию используют **UTF-16**, что может быть избыточным для простых данных.
   - UTF-8 более компактен для большинства сценариев, особенно для ASCII-совместимых текстов.

2. **Совместимость**:
   - Многие сетевые протоколы и форматы файлов используют **UTF-8** как стандартную кодировку.

3. **Удобство разработки**:
   - Устраняет необходимость ручного преобразования строк в массивы байтов.


### Примеры использования UTF-8 String Literals

#### 1. Простой пример {id="1_4"}
```C#
var utf8Bytes = "Hello, UTF-8!"u8;
Console.WriteLine(utf8Bytes.Length); // Вывод: 13
```
**Объяснение**:  
Строка `"Hello, UTF-8!"u8` преобразуется в массив `byte[]`, где каждый символ кодируется в соответствии с UTF-8.

#### 2. Работа с Unicode символами
```C#
var emoji = "😊"u8;
Console.WriteLine(emoji.Length); // Вывод: 4
```
**Объяснение**:  
Эмодзи `😊` кодируется в UTF-8 как 4 байта.

#### 3. Взаимодействие с API, использующими массивы байтов
```C#
var utf8String = "Content-Type: application/json"u8;
SendToApi(utf8String);

void SendToApi(ReadOnlySpan<byte> data)
{
    Console.WriteLine(System.Text.Encoding.UTF8.GetString(data));
}
```
**Объяснение**:  
Массив байтов `utf8String` передаётся в метод `SendToApi`, который работает с `ReadOnlySpan<byte>`.

#### 4. Использование необработанных строковых литералов
```C#
var json = """
{
    "name": "Alice",
    "age": 30
}
"""u8;

Console.WriteLine(System.Text.Encoding.UTF8.GetString(json));
// Вывод:
// {
//     "name": "Alice",
//     "age": 30
// }
```
**Объяснение**:  
Необработанные строки (`"""`) могут быть помечены как UTF-8, что удобно для JSON, XML и других текстов, где требуется UTF-8.

И снова практика!

Создай консольное приложение `ex0057_utf8_big_pucture` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```C#
using System;
using System.Text;

class Program
{
    static void Main()
    {
        // Пример 1: Простая строка UTF-8 как массив байт
        byte[] utf8Bytes = "Hello, UTF-8!"u8.ToArray(); // Преобразуем ReadOnlySpan<byte> в byte[]
        WriteLine($"Length of UTF-8 array: {utf8Bytes.Length}");

        // Пример 2: Работа с Unicode, тоже преобразование в byte[]
        byte[] emoji = "😊"u8.ToArray();
        WriteLine($"Length of emoji in UTF-8: {emoji.Length}");

        // Пример 3: Взаимодействие с API
        var utf8String = "Content-Type: application/json"u8;
        SendToApi(utf8String);

        // Пример 4: Конкатенация UTF-8 строк только через свои реализации
        var part1 = "Hello, "u8.ToArray();
        var part2 = "world!"u8.ToArray();
        var fullMessage = CombineByteArrays(part1, part2); // используем свой метод
        WriteLine(Encoding.UTF8.GetString(fullMessage));

        // Пример 5: Интерполяция строк не работает с использованием суффикса u8
        var name = "Alice";
        // var greeting = $"Hello, {name}!"u8; // так работать не будет
        // проэтому получаем масиив байт другим спосбобом
        var greeting = Encoding.UTF8.GetBytes($"Hello, {name}!");
        WriteLine(Encoding.UTF8.GetString(greeting));

        // Пример 6: Необработанный строковый литерал
        var json = """
        {
            "name": "Alice",
            "age": 30
        }
        """u8;
        WriteLine(Encoding.UTF8.GetString(json));
    }

    // Вспомогательный метод для объединения массивов байтов
    static byte[] CombineByteArrays(byte[] first, byte[] second)
    {
        var combined = new byte[first.Length + second.Length];
        Buffer.BlockCopy(first, 0, combined, 0, first.Length);
        Buffer.BlockCopy(second, 0, combined, first.Length, second.Length);
        return combined;
    }

    // Метод для отправки байтового массива в API
    static void SendToApi(ReadOnlySpan<byte> data)
    {
        WriteLine($"Sending to API: {Encoding.UTF8.GetString(data)}");
    }
}
```

Вывод программы:
```
Length of UTF-8 array: 13
Length of emoji in UTF-8: 4
Sending to API: Content-Type: application/json
Hello, world!
Hello, Alice!
{
    "name": "Alice",
    "age": 30
}
```

>Опять же, возможно, что-то не будет понятно в этой программе. Например, методы, которые мы сами написали. Но ни чего,
> скоро вы это всё узнаете.
> {style="note"}

### Выводы обзорной части

**UTF-8 String Literals** в C# добавлены для упрощения работы с байтовыми строками, повышения производительности и улучшения совместимости. Они особенно полезны для сценариев, где строки передаются в формате UTF-8 или требуется прямое манипулирование массивами байтов.

Теперь давайте более подробно разберем тему **UTF8-строковых литералов** в C#. Хотя этот функционал находится ещё на стадии разработки, но его уже можно использовать в  C# 11 и выше. UTF8-строковые литералы добавляют новый уровень удобства и производительности при работе с текстом в формате UTF-8, что особенно актуально для сетевых и веб-приложений.

### **Что такое UTF8-строковые литералы под капотом?**

**UTF8-строковые литералы** — это строковые константы, которые преобразуются в массивы байтов UTF-8 **во время компиляции**, а не выполнения. Они используют специальный суффикс `u8`, который преобразует строку в объект типа `ReadOnlySpan<byte>`. Например:

```C#
var utf8String = "hello"u8; // Тип: ReadOnlySpan<byte>
```

Кстати именно по этому суффикс `u8` не может быть использован с интеполяцией строк, так как значение строки должно быть известно на **этапе компиляции**.

### **Почему это важно?**

До появления UTF8-строковых литералов разработчики сталкивались с несколькими подходами, которые имели свои недостатки:

1. **Эффективный, но громоздкий и подверженный ошибкам подход:**
   ```C#
   static ReadOnlySpan<byte> Auth => new byte[] { 0x41, 0x55, 0x54, 0x48, 0x20 };
   WriteBytes(Auth);
   ```

2. **Производительный, но требующий аллокаций:**
   ```C#
   static readonly byte[] Auth = Encoding.UTF8.GetBytes("AUTH ");
   WriteBytes(Auth);
   ```

3. **Простой, но неэффективный:**
   ```C#
   WriteBytes(Encoding.UTF8.GetBytes("AUTH "));
   ```

UTF8-строковые литералы решают эту проблему, позволяя записывать строковые константы более кратко, сохраняя при этом высокую производительность:

```C#
WriteBytes("AUTH "u8); // Эффективно и удобно
```

### **Тип данных `ReadOnlySpan<byte>`** {id="readonlyspan_1"}

Тип `ReadOnlySpan<byte>` — это "чтение только" представление последовательности байтов в памяти. Он:

- Не является строкой.
- Не поддерживает изменения данных.
- Не аллоцирует память, что делает его очень эффективным для использования в реальном времени.

Пример:

```C#
ReadOnlySpan<byte> data = "example"u8;
```

#### **Особенности `ReadOnlySpan<byte>`** {id="readonlyspan_2"}

1. **Неявное преобразование недопустимо:**
   ```C#
   byte[] bytes = "example"u8; // Ошибка
   ```

   Чтобы получить массив байтов, нужно вызвать метод `ToArray()`:
   ```C#
   byte[] bytes = "example"u8.ToArray(); // Допустимо
   ```

2. **Не работает со `Span<byte>`:**
   ```C#
   Span<byte> span = "example"u8; // Ошибка
   ```

### **Константность и ограничения**

UTF8-литералы не могут быть использованы в качестве констант, так как `ReadOnlySpan<byte>` не является допустимым 
типом для `const`. Например:

```C#
// Ошибка: Аргумент не является константой
void Write(ReadOnlySpan<byte> message = "missing"u8) { }
```

### **Обработка некорректных строк**

UTF8-литералы требуют корректного формата входной строки UTF-16. В противном случае компилятор выдаст ошибку:

```C#
var bytes = "hello \uD8\uD8"u8; // Ошибка: некорректная строка UTF-16
```

Однако корректно сформированные, но невалидные UTF-16 строки допустимы:

```C#
var bytes = "hello \uD801\uD802"u8; // Допустимо
```

### **Оператор сложения**

Введен новый оператор `+`, который объединяет два `ReadOnlySpan<byte>`:

```C#
ReadOnlySpan<byte> combined = "hello"u8 + " world"u8;
```

Этот код эквивалентен следующему:

```C#
ReadOnlySpan<byte> combined = new ReadOnlySpan<byte>(new byte[] { 
    0x68, 0x65, 0x6c, 0x6c, 0x6f, // "hello"
    0x20,                         // " "
    0x77, 0x6f, 0x72, 0x6c, 0x64  // "world"
}).Slice(0, 11);
```

Компилятор автоматически оптимизирует такие выражения.

### **Снижение кода**

Компилятор обрабатывает UTF8-литералы так же, как если бы разработчик вручную писал `byte[]`. Это означает:

- Отсутствие выделения памяти во время выполнения.
- Оптимизация для хранения данных в PE-файле программы.

Пример:

```C#
ReadOnlySpan<byte> span = "hello"u8;

// Эквивалентно:
ReadOnlySpan<byte> span = new ReadOnlySpan<byte>(new byte[] { 
    0x68, 0x65, 0x6c, 0x6c, 0x6f 
}).Slice(0, 5);
```

### **Будущее: Utf8String**

Хотя `ReadOnlySpan<byte>` сейчас стандарт для работы с UTF-8, возможно, в будущем будет введен новый тип `Utf8String`. 
Однако это пока только обсуждается.

Ну и конечно же практика, падаван! Куда без неё.

Создай консольное приложение ex0058_utf8_in_deep при помощи шаблона tinyconsole в папке episode02 и добавь его в 
файл решения episode02.sln. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```C#
using System;
using System.Text;

class Program
{
    static void Main()
    {
        // Литерал UTF8
        var utf8Literal = "HTTP/1.1\r\n"u8;

        // Передача в метод
        WriteBytes(utf8Literal);
        WriteLine($"\n {Encoding.UTF8.GetString(utf8Literal)}");

        // Объединение
        var combined = "Content-Length: "u8 + "1108"u8;
        WriteBytes(combined);
        WriteLine($"\n{Encoding.UTF8.GetString(combined)}\n");

        // Конвертация в массив байтов
        byte[] bytes = combined.ToArray();
        WriteBytes(bytes);
        WriteLine($"\n {Encoding.UTF8.GetString(bytes)}");
    }

    // Метод для записи байтов
    static void WriteBytes(ReadOnlySpan<byte> data)
    {
        foreach (byte b in data)
        {
            Write($"{b:X2} ");
        }
    }
}

```

Вывод программы:
```
48 54 54 50 2F 31 2E 31 0D 0A 
 HTTP/1.1

43 6F 6E 74 65 6E 74 2D 4C 65 6E 67 74 68 3A 20 31 31 30 38
Content-Length: 1108

43 6F 6E 74 65 6E 74 2D 4C 65 6E 67 74 68 3A 20 31 31 30 38
 Content-Length: 1108
```

### **Заключение**
UTF8-строковые литералы — мощное нововведение, упрощающее работу с байтовыми строками UTF-8. Они делают код более читаемым, производительным и легким в обслуживании.

### Что такое снижение кода?

**Снижение кода** (англ. *Lowering*) — это процесс, при котором высокоуровневый синтаксис или конструкции языка программирования преобразуются в более низкоуровневые эквиваленты. Это делается компилятором для упрощения обработки и оптимизации кода на более поздних этапах компиляции.

В контексте C# и литералов UTF-8 (с суффиксом `u8`), снижение означает, что компилятор автоматически преобразует такие высокоуровневые конструкции в эквивалентный низкоуровневый код на этапе компиляции. Это позволяет избежать выполнения сложных операций в процессе выполнения программы (runtime), повышая производительность.

#### Пример снижения кода с литералом UTF-8 {id="utf-8_1"}

В C# литералы UTF-8 вроде `"hello"u8` представляют собой `ReadOnlySpan<byte>` и снижаются компилятором до создания массива байтов с последующей обрезкой (`Slice`).

#### Код, написанный разработчиком:

```C#
ReadOnlySpan<byte> span = "hello"u8;
```

##### Как это будет выглядеть после снижения:

```C#
ReadOnlySpan<byte> span = new ReadOnlySpan<byte>(new byte[] { 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00 })
                               .Slice(0, 5);
```

Компилятор создаёт массив байтов `new byte[] { 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00 }` (UTF-8 представление строки `"hello"`) и обрезает его до нужной длины (без учёта нулевого байта-терминатора).

#### Зачем нужно снижение кода?
1. **Оптимизация**: Компилятор создаёт код, который эффективнее исполняется, например, за счёт размещения массива байтов в секции `.data` файла PE (Portable Executable), что исключает создание объекта в куче.
2. **Упрощение реализации**: Высокоуровневый синтаксис скрывает сложные детали, такие как работа с массивами байтов и указателями. Эти операции реализуются через снижение.
3. **Компактность**: Одно высокоуровневое выражение заменяется на оптимизированный низкоуровневый эквивалент, что исключает избыточное выделение памяти.

#### Пример объединения литералов UTF-8 {id="utf-8_2"}
Снижение поддерживает объединение (конкатенацию) литералов UTF-8 с помощью оператора `+`.

##### Исходный код:
```C#
ReadOnlySpan<byte> span = "h"u8 + "el"u8 + "lo"u8;
```

##### После снижения:
```C#
ReadOnlySpan<byte> span = new ReadOnlySpan<byte>(new byte[] { 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00 })
                               .Slice(0, 5);
```

Компилятор объединяет строки `"h"`, `"el"` и `"lo"` в один массив байтов `new byte[] { 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00 }`.

### Преимущества снижения для литералов UTF-8 {id="utf-8_3"}
- **Отсутствие накладных расходов во время выполнения**: Константы UTF-8 обрабатываются на этапе компиляции.
- **Быстродействие**: Кодировка строки в UTF-8 выполняется один раз компилятором, а не на старте программы.
- **Использование памяти**: Литералы размещаются в статической памяти, а не создаются в куче.

Таким образом, снижение делает использование литералов UTF-8 удобным и производительным для разработчиков.

## Обрезка и удаление символов

Команды обрезки и удаления символов из строк в C# позволяют упростить работу со строками, убирая ненужные пробелы или символы. Рассмотрим основные методы и их использование как по умолчанию, так и с дополнительными параметрами.

Строки в C# представляют собой массив символов, где каждый символ имеет индекс. Индексация начинается с нуля — это означает, что первый символ строки имеет индекс `0`, второй — `1`, и так далее.

Для методов, таких как `Remove`, важно помнить, что удаление символов включает начальный индекс, но длина удаления определяет, сколько символов будет удалено, начиная с этого индекса. Это позволяет точно управлять обрезкой или изменением строк.

### **[Trim](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.trim)**
Метод `Trim()` удаляет все начальные и конечные пробелы из строки. Если передать массив символов, он удаляет все указанные символы из начала и конца строки.

#### **По умолчанию**
```c#
string myString = "   Hello World!   ";
Console.WriteLine($"[{myString}]"); // [   Hello World!   ]
string trimmedString = myString.Trim();
Console.WriteLine($"[{trimmedString}]"); // [Hello World!]
```

#### **С дополнительными параметрами**
```c#
string header = "**...Welcome!...**";
char[] trimChars = { '*', '.', '!' };
Console.WriteLine(header);                       // **...Welcome!...**
Console.WriteLine(header.Trim(trimChars));       // Welcome
```

**Объяснение:**
- Без параметров: Убирает пробелы.
- С параметрами: Удаляет указанные символы (включая повторы) с начала и конца строки.

### **[TrimStart](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.trimstart)**
Метод `TrimStart()` удаляет указанные символы только с начала строки.

#### **По умолчанию**
```c#
string myString = "   Hello World!";
string newString = myString.TrimStart();
Console.WriteLine($"[{newString}]"); // [Hello World!]
```

#### **С дополнительными параметрами**
```c#
string myString = "!!!Hello World!!!";
char[] trimChars = { '!', 'H' };
string newString = myString.TrimStart(trimChars);
Console.WriteLine(newString); // ello World!!!
```

**Объяснение:**
- Без параметров: Убирает пробелы только с начала строки.
- С параметрами: Удаляет указанные символы только в начале строки.

### **[TrimEnd](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.trimend)**
Метод `TrimEnd()` удаляет указанные символы только с конца строки.

#### **По умолчанию**
```c#
string myString = "Hello World!   ";
string newString = myString.TrimEnd();
Console.WriteLine($"[{newString}]"); // [Hello World!]
```

#### **С дополнительными параметрами**
```c#
string myString = "Hello World!!!";
char[] trimChars = { '!', 'd' };
string newString = myString.TrimEnd(trimChars);
Console.WriteLine(newString); // Hello Worl
```

**Объяснение:**
- Без параметров: Убирает пробелы только с конца строки.
- С параметрами: Удаляет указанные символы только в конце строки.

### **[Remove](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.remove)**
Метод `Remove()` удаляет символы, начиная с указанного индекса.

#### **Пример с указанием индекса и длины**
```c#
string myString = "Hello Beautiful World!";
string result = myString.Remove(6, 10);
Console.WriteLine(result); // Hello World!
```

#### **Пример с указанием только индекса**
```c#
string myString = "Hello Beautiful World!";
string result = myString.Remove(5);
Console.WriteLine(result); // Hello
```

**Объяснение:**
- Первый параметр — начальный индекс удаления.
- Второй параметр (необязательный) — количество символов для удаления.

### **[Replace](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.replace)**
Метод `Replace()` заменяет все вхождения указанного символа или подстроки на другую подстроку. Иногда используется как альтернатива `Remove()`.

#### **Пример**
```c#
string phrase = "Hello, Beautiful World!";
string result = phrase.Replace("Beautiful ", "");
Console.WriteLine(result); // Hello, World!
```

### **Итог**
- **`Trim`**: Убирает символы с начала и конца строки.
- **`TrimStart`**: Убирает символы только с начала строки.
- **`TrimEnd`**: Убирает символы только с конца строки.
- **`Remove`**: Удаляет символы по индексу.
- **`Replace`**: Заменяет символы или подстроки.

Теперь поупражняемся!

Создай консольное приложение ex0059_string_trim_replace при помощи шаблона tinyconsole в папке episode02 и добавь его в
файл решения episode02.sln. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```C#
public class Example
{
    public static void Main()
    {
        // Пример Trim
        string myString = "   Hello World!   ";
        WriteLine($"Исходная строка: [{myString}]");
        string trimmedString = myString.Trim();
        WriteLine($"После Trim: [{trimmedString}]");

        string header = "**...Welcome!...**";
        char[] trimChars = { '*', '.', '!' };
        WriteLine($"Исходная строка: [{header}]");
        WriteLine($"После Trim с символами: [{header.Trim(trimChars)}]");

        // Пример TrimStart
        string myStringStart = "!!!Hello World!!!";
        char[] trimStartChars = { '!', 'H' };
        WriteLine($"Исходная строка: [{myStringStart}]");
        WriteLine($"После TrimStart: [{myStringStart.TrimStart(trimStartChars)}]");

        // Пример TrimEnd
        string myStringEnd = "Hello World!!!";
        char[] trimEndChars = { '!', 'd' };
        WriteLine($"Исходная строка: [{myStringEnd}]");
        WriteLine($"После TrimEnd: [{myStringEnd.TrimEnd(trimEndChars)}]");

        // Пример Remove
        string myStringRemove = "Hello Beautiful World!";
        WriteLine($"Исходная строка: [{myStringRemove}]");
        WriteLine($"После Remove(6, 10): [{myStringRemove.Remove(6, 10)}]");
        WriteLine($"После Remove(5): [{myStringRemove.Remove(5)}]");

        // Пример Replace
        string phrase = "a cold, dark night";
        WriteLine($"Исходная строка: [{phrase}]");
        WriteLine($"После Replace: [{phrase.Replace(",", "")}]");

        // Основная программа
        string text = "=== Hello, World! ===";

        WriteLine($"Исходная строка: [{text}]");

        // Удаление начальных и конечных символов
        string trimmedText = text.Trim('=');
        WriteLine($"После Trim: [{trimmedText}]");

        // Удаление начальных символов
        string trimmedStart = text.TrimStart('=');
        WriteLine($"После TrimStart: [{trimmedStart}]");

        // Удаление конечных символов
        string trimmedEnd = text.TrimEnd('=');
        WriteLine($"После TrimEnd: [{trimmedEnd}]");

        // Удаление части строки
        string removedText = text.Remove(4, 12); // Удаляем " Hello, World"
        WriteLine($"После Remove: [{removedText}]");

        // Замена символов
        string replacedText = text.Replace("=", "");
        WriteLine($"После Replace: [{replacedText}]");
    }
}
```

#### Вывод программы:

```
Исходная строка: [   Hello World!   ]
После Trim: [Hello World!]
Исходная строка: [**...Welcome!...**]
После Trim с символами: [Welcome]
Исходная строка: [!!!Hello World!!!]
После TrimStart: [ello World!!!]
Исходная строка: [Hello World!!!]
После TrimEnd: [Hello Worl]
Исходная строка: [Hello Beautiful World!]
После Remove(6, 10): [Hello World!]
После Remove(5): [Hello]
Исходная строка: [a cold, dark night]
После Replace: [a cold dark night]
Исходная строка: [=== Hello, World! ===]
После Trim: [ Hello, World! ]
После TrimStart: [ Hello, World! ===]
После TrimEnd: [=== Hello, World! ]
После Remove: [=== ! ===]
После Replace: [ Hello, World! ]
```
Падаван, рекомендую тебе самостоятельно проанализировать почему такой вывод у каждой строки. Тут не сложно, просто надо
немного вдуматься в код, а так же, возможно, и поэкспериментировать. Или как говорят программисты поиграться. В общем
считай это домашним заданием 😊

## Дополнение строк

Методы **`PadLeft`** и **`PadRight`** класса `String` позволяют дополнить строку символами с левой или правой стороны, чтобы достигнуть указанной длины. Эти методы удобны для форматирования строк, например, для создания таблиц с выравниванием, добавления ведущих нулей или центрирования текста.

### **Как работают [PadLeft](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.padleft) и [PadRight](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.padright)**
1. **`PadLeft`**:
   - Дополняет строку символами с левой стороны до указанной длины.
   - Если символ заполнения не указан, используется пробел.
   - Если длина исходной строки больше или равна указанной, строка возвращается без изменений.

2. **`PadRight`**:
   - Дополняет строку символами с правой стороны до указанной длины.
   - По умолчанию используется пробел, если символ заполнения не указан.
   - Аналогично `PadLeft`, строка остается неизменной, если её длина уже соответствует или превышает заданную.

### **Сигнатура методов**
```c#
string PadLeft(int totalWidth);
string PadLeft(int totalWidth, char paddingChar);
string PadRight(int totalWidth);
string PadRight(int totalWidth, char paddingChar);
```

- **`totalWidth`**: Итоговая длина строки после заполнения.
- **`paddingChar`**: Символ, используемый для заполнения (опционально).

### **Примеры использования**

1. **Заполнение символами**
   ```c#
   string text = "Hello";
   Console.WriteLine(text.PadLeft(10, '-')); // -----Hello
   Console.WriteLine(text.PadRight(10, '*')); // Hello*****
   ```

2. **Заполнение пробелами (по умолчанию)**
   ```c#
   string text = "Hello";
   Console.WriteLine($"[{text.PadLeft(10)}]"); // [     Hello]
   Console.WriteLine($"[{text.PadRight(10)}]"); // [Hello     ]
   ```

3. **Исходная строка длиннее заданной ширины**
   ```c#
   string longText = "LongString";
   Console.WriteLine(longText.PadLeft(5)); // LongString (без изменений)
   Console.WriteLine(longText.PadRight(5)); // LongString (без изменений)
   ```

4. **Форматирование чисел**
   ```c#
   string number = "42";
   Console.WriteLine(number.PadLeft(5, '0')); // 00042
   Console.WriteLine(number.PadRight(5, '0')); // 42000
   ```

5. **Комбинированное использование для центрирования**
   ```c#
   string title = "C#";
   string centeredTitle = title.PadLeft(10).PadRight(20, '*');
   Console.WriteLine(centeredTitle); //        C#*********
   ```

Практика!

Создай консольное приложение `ex0060_string_padding` при помощи шаблона `tinyconsole` в папке `episode02` и добавь его в
файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:


```c#
public class Example
{
    public static void Main()
    {
        // Методы PadLeft и PadRight позволяют дополнить строку символами для достижения заданной длины.
        // Символы могут добавляться как слева (PadLeft), так и справа (PadRight).

        // Пример PadLeft
        string original = "Hello";
        string paddedLeft = original.PadLeft(10, '-');
        WriteLine($"Исходная строка: [{original}]");
        WriteLine($"После PadLeft: [{paddedLeft}]");

        // Пример PadRight
        string paddedRight = original.PadRight(10, '*');
        WriteLine($"После PadRight: [{paddedRight}]");

        // Пример с пробелами
        string paddedLeftSpaces = original.PadLeft(15);
        string paddedRightSpaces = original.PadRight(15);
        WriteLine($"После PadLeft с пробелами: [{paddedLeftSpaces}]");
        WriteLine($"После PadRight с пробелами: [{paddedRightSpaces}]");

        // Пример строки с длиной больше заданной
        string longString = "LongString";
        WriteLine($"Исходная строка: [{longString}]");
        WriteLine($"После PadLeft (без изменений): [{longString.PadLeft(5)}]");
        WriteLine($"После PadRight (без изменений): [{longString.PadRight(5)}]");

        // Пример с числовыми значениями для форматирования
        string number = "42";
        WriteLine($"Число без изменений: [{number}]");
        WriteLine($"После PadLeft для выравнивания: [{number.PadLeft(5, '0')}]");
        WriteLine($"После PadRight для выравнивания: [{number.PadRight(5, '0')}]");

        // Основная демонстрационная программа
        string title = "C# Padding";
        WriteLine($"Исходная строка: [{title}]");

        string paddedTitleLeft = title.PadLeft(20, '-');
        WriteLine($"После PadLeft с '-': [{paddedTitleLeft}]");

        string paddedTitleRight = title.PadRight(20, '=');
        WriteLine($"После PadRight с '=': [{paddedTitleRight}]");

        // Пример комбинированного использования PadLeft и PadRight
        string centeredTitle = title.PadLeft(15).PadRight(20, ' ');
        WriteLine($"Центрированная строка: [{centeredTitle}]");
    }
}

```

#### Вывод программы:
```
Исходная строка: [Hello]
После PadLeft: [-----Hello]
После PadRight: [Hello*****]
После PadLeft с пробелами: [          Hello]
После PadRight с пробелами: [Hello          ]
Исходная строка: [LongString]
После PadLeft (без изменений): [LongString]
После PadRight (без изменений): [LongString]
Число без изменений: [42]
После PadLeft для выравнивания: [00042]
После PadRight для выравнивания: [42000]
Исходная строка: [C# Padding]
После PadLeft с '-': [----------C# Padding]
После PadRight с '=': [C# Padding==========]
Центрированная строка: [     C# Padding     ]
```

### Заключение
Методы **PadLeft** и **PadRight** удобны для работы с текстовым форматированием, особенно когда требуется добиться 
выравнивания или дополнения строки до заданной длины. Эти методы работают интуитивно и предоставляют гибкость за счёт 
использования как стандартного символа пробела, так и указанных пользователем символов.

## Изменение регистра
В языке C# для изменения регистра символов в строках используются следующие методы:

### 1. `String.ToUpper()`

Метод [ToUpper()](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.toupper) преобразует все символы строки в верхний регистр.

**Пример использования:**

```c#
string original = "Hello World!";
string upper = original.ToUpper();
Console.WriteLine(upper); // Выведет: HELLO WORLD!
```

### 2. `String.ToLower()`

Метод [ToLower()](https://learn.microsoft.com/ru-ru/dotnet/api/system.string.tolower) преобразует все символы строки в нижний регистр.

**Пример использования:**

```c#
string original = "Hello World!";
string lower = original.ToLower();
Console.WriteLine(lower); // Выведет: hello world!
```

### 3. `TextInfo.ToTitleCase()`

Метод [ToTitleCase()](https://learn.microsoft.com/ru-ru/dotnet/api/system.globalization.textinfo.totitlecase) из класса `TextInfo` преобразует первые символы всех слов в строке в заглавные, а остальные символы делает строчными.

**Пример использования:**

```c#
using System.Globalization;

string original = "hello world!";
TextInfo textInfo = CultureInfo.CurrentCulture.TextInfo;
string titleCase = textInfo.ToTitleCase(original);
Console.WriteLine(titleCase); // Выведет: Hello World!
```

**Примечание:** Слова, состоящие полностью из заглавных букв, считаются аббревиатурами и не изменяются.

### 4. `Char.ToUpper()` и `Char.ToLower()`

Для изменения регистра отдельных символов используются методы `Char.ToUpper()` и `Char.ToLower()`.

**Пример использования:**

```c#
char lowerChar = 'a';
char upperChar = Char.ToUpper(lowerChar);
Console.WriteLine(upperChar); // Выведет: A
```

Попрактикуемся!

Создай консольное приложение `ex0062_string_cahange_case` при помощи шаблона `tinyconsole` в папке `episode02` и добавь его в
файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи Program.cs к следующему виду:

```c#
using System;
using System.Globalization;

class Program
{
    static void Main()
    {
        string original = "hello world!";

        // Преобразование в верхний регистр
        string upper = original.ToUpper();
        WriteLine("Верхний регистр: " + upper);

        // Преобразование в нижний регистр
        string lower = upper.ToLower();
        WriteLine("Нижний регистр: " + lower);

        // Преобразование в заглавные буквы каждого слова
        TextInfo textInfo = CultureInfo.CurrentCulture.TextInfo;
        string titleCase = textInfo.ToTitleCase(original);
        WriteLine("Заглавные буквы каждого слова: " + titleCase);

        // Преобразование первого символа строки в верхний регистр
        if (original.Length > 0)
        {
            char firstChar = original[0];
            char upperFirstChar = Char.ToUpper(firstChar);
            string result = upperFirstChar + original.Substring(1);
            WriteLine("Первый символ в верхнем регистре: " + result);
        }
    }
}
```

#### Вывод программы:

```
Верхний регистр: HELLO WORLD!
Нижний регистр: hello world!
Заглавные буквы каждого слова: Hello World!   
Первый символ в верхнем регистре: Hello world!!
```



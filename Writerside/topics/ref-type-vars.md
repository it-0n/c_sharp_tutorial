# Переменные ссылочных типов

Ссылочные типы и типы значений в C# отличаются тем, как данные хранятся в памяти и передаются в программе.
Чтобы понять это, представь, что у тебя есть два ящика: один для хранения самого предмета, 
а другой (очень маленький) — для хранения листочка с адресом, где этот предмет находится.

Падаван, ты уже смекнул что ящик где хранится сам предмет это типы значений, а маленький ящик, где хранится листок с адресом
предмета - это ссылочные типы. То есть ссылочный тип хранит ссылку (адрес) где хранятся данные.

Переменные типов значений ты уже должен были изучить. А вот ссылочные типы мы будем изучать гораздо дольше поскольку это
требует изучения ООП (объектно ориентированного программирования).

**В этом разделе мы лишь слегка познакомимся с ними чтобы ты имел представление**. 

Для этого сперва надо лучше понять разницу между типами значений и ссылочными типами.

## Разница между типами значений и ссылочными типами

### 1. **Типы значений**
Переменные типов значений хранят сами данные, если можно так сказать, прямо в себе (пример с ящиком где хранится сам предмет). 
Если переменная значимого типа копируется, создается новая независимая копия данных.

#### Хранение в памяти:
- Данные типа значения хранятся в **стеке** (stack).
- Каждый экземпляр типа значения имеет свою собственную копию данных.

#### Примеры:
- Примитивные типы: `int`, `float`, `double`, `bool`, `char`.
- Структуры (`struct`): Например, `DateTime`, `Point`.
- Перечисления (`enum`).

#### Пример кода:
```c#
int a = 10;
int b = a; // Копируется значение
b = 20;
Console.WriteLine(a); // 10, значение a не изменилось
```

#### Особенности:
- **Локальность:** Значимые типы используют стек, что делает операции с ними быстрыми.
- **Изолированность:** Копирование значимого типа создает независимый объект.

### 2. **Ссылочные типы** {id="2_1"}
Переменные ссылочных типы хранят не сами данные, а **ссылку** (адрес) на область памяти в куче (heap), где данные находятся
(пример с ящиком, где хранится листок с адресом предмета).

#### Хранение в памяти:
- Ссылка (указатель на объект) хранится в **стеке**.
- Сам объект размещается в **куче**, которая используется для долгосрочного хранения.

#### Примеры:
- Классы (`class`).
- Интерфейсы (`interface`).
- Делегаты (`delegate`).
- Строки (`string`).

#### Пример кода:
```c#
class Person { public string Name; }

Person p1 = new Person { Name = "Alice" };
Person p2 = p1; // Копируется ссылка
p2.Name = "Bob"; // Изменяется объект через ссылку
Console.WriteLine(p1.Name); // Bob, объект один и тот же
```

#### Особенности:
- **Общая ссылка:** При копировании ссылочного типа передается ссылка, а не сам объект. Поэтому изменения через одну переменную видны через другую.
- **Гибкость:** Ссылочные типы позволяют работать с большими и сложными структурами данных.

### 3. **Сравнение типов значений и ссылочных типов** {id="3_1"}

| **Характеристика**        | **Типы значений**                          | **Ссылочные типы**                    |
|---------------------------|--------------------------------------------|---------------------------------------|
| **Хранение данных**       | В памяти переменной (в стеке).             | В куче, ссылка в стеке.              |
| **Копирование**           | Создает копию данных.                     | Копирует ссылку на объект.           |
| **Передача в методы**     | Передается копия данных.                  | Передается копия ссылки.             |
| **Примеры**               | `int`, `double`, `bool`, `DateTime`.       | `string`, массивы, классы, делегаты. |
| **Изменение объекта**     | Не влияет на другие переменные.            | Видимо для всех ссылок на объект.    |

### 4. **Особенности переменных ссылочного типа** {id="4_1"}
Переменная ссылочного типа хранит **только ссылку** на область памяти в куче, где находится объект. Это приводит к тому, что:
- При присваивании другой переменной передается ссылка, а не сам объект.
- Если объект изменяется через одну ссылку, эти изменения видны через все другие ссылки на этот объект.

Время практики, падаван.

Создай консольное приложение `ex0041_ref_types` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи `Program.cs` к следующему виду:

```c#
class Program
{
    static void Main()
    {
        // Пример типа значения
        int value1 = 10;
        int value2 = value1;
        value2 += 5;
        WriteLine($"Тип значения: value1 = {value1}, value2 = {value2}"); // value1 = 10, value2 = 15

        // Пример ссылочного типа Class
        Person p1 = new Person { Name = "Alice" };
        Person p2 = p1; // Копируется ссылка на объект
        p2.Name = "Bob";
        WriteLine($"Ссылочный тип: p1.Name = {p1.Name}, p2.Name = {p2.Name}"); // p1.Name = Bob, p2.Name = Bob
    }
}

class Person
{
    public string Name;
}
```

Вывод программы:

```
Тип значения: value1 = 10, value2 = 15
Ссылочный тип: p1.Name = Bob, p2.Name = Bob
```

#### Объяснение:
1. **Тип значения (`int`):**
    - `value1` хранит значение `10`.
    - При присваивании `value2 = value1` копируется **само значение**, а не ссылка.
    - Изменение `value2` не затрагивает `value1`.

2. **Ссылочный тип (`Person`):**
    - `p1` хранит ссылку на объект `Person` в куче.
    - При присваивании `p2 = p1` копируется ссылка. Теперь обе переменные указывают на один и тот же объект.
    - Изменение объекта через `p2` влияет на `p1`.

### Вывод:
- **Типы значений** используются для простых данных, которые копируются без связи друг с другом.
- **Ссылочные типы** позволяют работать с объектами в куче, но требуют внимательности, так как изменения через одну ссылку видны через все остальные ссылки на этот объект.

## Виды ссылочных типов

В C# ссылочные типы условно разделают на два вида: пользовательские и [встроенные](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/builtin-types/reference-types).

**Встроенные ссылочные типы**, включая массивы, выделяют из-за их уникальных свойств, поддержки на уровне языка и 
универсального применения.

**Пользовательские ссылочные типы** дают разработчикам возможность определять сложные структуры данных, которых нет 
в стандартной библиотеке.

Теперь подробнее о каждом из видов.

## Встроенные ссылочные типы

В C# встроенные ссылочные типы (такие, как `object`, `string`, `dynamic` и массивы) выделяются в отдельную категорию, 
поскольку они обладают особыми характеристиками, встроенными в язык, и играют ключевую роль в базовой инфраструктуре .NET. 
Рассмотрим их отличия от пользовательских ссылочных типов, таких как `class`, `interface`, `delegate` и `record`.


### 1. Общие свойства встроенных ссылочных типов {id="1_1"}
Эти типы обеспечивают фундаментальные возможности и широко используются в повседневном программировании. Вот их основные характеристики:

- **`object`**:
   - Это базовый тип для всех типов в C# (включая как ссылочные, так и значимые).
   - Каждый тип неявно наследуется от `object`, что позволяет обрабатывать любые данные через общий интерфейс.
   - Основные методы: `ToString()`, `Equals()`, `GetHashCode()`.

- **`string`**:
   - Тип для работы с неизменяемыми строками.
   - Поддерживает широкий набор операций: конкатенация, подстроки, замена символов и т.д.
   - Имеет оптимизацию на уровне компилятора, например, **интернирование строк** (одинаковые строковые литералы ссылаются на одну область памяти).

- **`dynamic`**:
   - Позволяет выполнять операции, проверяемые только во время выполнения (runtime).
   - Удобен для взаимодействия с COM-объектами, динамическими библиотеками или в сценариях, где строгая типизация мешает гибкости.

- **Массивы**:
   - Особый вид встроенных ссылочных типов, автоматически поддерживаемый компилятором и средой выполнения.
   - Массивы являются объектами, а их элементы могут быть как значимыми, так и ссылочными типами.
   - Поддерживают индексный доступ, многомерность и свойства (например, `Length`).

### 2. Отличия от пользовательских ссылочных типов
Встроенные типы выделяются благодаря своей роли в языке и оптимизациям на уровне CLR (Common Language Runtime).

**Основные особенности встроенных ссылочных типов:**

- **Создание**: Встроенные типы уже определены в .NET и не требуют определения программистом. Пользовательские ссылочные типы (такие как классы, интерфейсы и делегаты) создаются вручную для конкретных задач.
- **Особая поддержка**:
   - Для `string` встроена оптимизация работы с текстами, включая интернирование (для экономии памяти одинаковые строки указывают на одну область памяти).
   - Для `dynamic` компилятор и рантайм обеспечивают поддержку "позднего связывания".
- **Наследование**:
   - Пользовательские классы, интерфейсы и записи могут расширять функциональность, наследуясь друг от друга.
   - `object` не может быть унаследован напрямую, так как это конечный базовый класс для всех типов.
   - `string` и `dynamic` являются запечатанными (sealed) и не могут быть унаследованы.
- **Специальные методы и поведение**:
   - Методы `object` доступны для всех типов, включая пользовательские.
   - Для `string` определены перегруженные операторы (`+`, `==` и другие) для удобной работы с текстами.
   - `dynamic` позволяет игнорировать строгую проверку типов компилятором.
- **Функциональсть "из коробки"**. Встроенные типы предоставляют готовую функциональность:
   - `string` предоставляет методы для работы с текстом (Substring, Replace и т.д.).
   - Массивы поддерживают многомерность и обработку данных через `foreach`.
- **Неявная оптимизация**: Типы, такие как `string` и массивы, могут быть оптимизированы на уровне CLR (Common Language Runtime) для повышения производительности.

| **Особенность**            | **Встроенные (object, string, dynamic, массивы)**       | **Пользовательские (class, interface, record, delegate)** |
|-----------------------------|---------------------------------------------------------|----------------------------------------------------------|
| **Определение**            | Часть .NET и языка                                      | Определяются программистом                               |
| **Особая поддержка**       | Методы, оптимизация (интернирование строк, поддержка массивов) | Базовые возможности языка                                |
| **Изменяемость**           | `string` неизменяем, массивы изменяемы                 | Определяется разработчиком                               |
| **Наследование**           | Наследование от `object`, некоторые типы запечатаны     | Возможность создания иерархий классов и интерфейсов      |
| **Расположение в памяти**  | Управляется CLR                                         | Зависит от структуры и логики программы                  |


### 3. Особенности массивов как встроенных ссылочных типов

Массивы относятся к встроенным ссылочным типам. Когда вы создаете массив, переменная хранит ссылку на область памяти в куче, где хранятся элементы массива. Это делает массив ссылочным типом, даже если его элементы – типы значений.

Массивы обладают следующими характеристиками:
- **Ссылочный тип**: Переменная массива хранит ссылку на область памяти в куче, где хранятся его элементы.
- **Автоматическая инициализация**: Элементы массива автоматически инициализируются значениями по умолчанию (`null` для ссылочных типов и `0` для значимых).
- **Свойства и методы**: Массивы предоставляют свойство `Length`, методы `Clone`, `CopyTo`, а также поддерживают цикл `foreach`.

### Примеры использования
#### Встроенные ссылочные типы:
```c#
object obj = 42; // Любой тип может быть сохранён как object
string text = "Привет, мир!";
dynamic dyn = 10;
dyn = "Теперь строка"; // Изменение типа значения динамически

// Массивы
int[] array = new int[] { 1, 2, 3 };
array[1] = 42; // Индексация и изменение элементов
Console.WriteLine(array.Length); // Выводит 3
```

#### Пользовательские ссылочные типы:
```c#
class MyClass
{
    public string Name { get; set; }
}

interface IExample
{
    void DoSomething();
}

record MyRecord(string Name);

delegate void MyDelegate(string message);
```

## Пользовательские ссылочные типы

### **1. Класс (`class`)**
**Метафора**:  
Представь форму для выпечки кексов.
- **Форма для выпечки** — это класс. Она определяет, каким будет кекс: круглый, квадратный или с сердечком.
- **Кексы**, которые ты выпекаешь с её помощью, — это экземпляры класса.

**Пример в коде:**
```c#
class Cupcake
{
    public string Flavor { get; set; } // Вкус
    public string Color { get; set; } // Цвет

    public void Eat()
    {
        Console.WriteLine($"Ммм, {Flavor} кекс цвета {Color}!");
    }
}

// Использование
Cupcake myCupcake = new Cupcake { Flavor = "шоколадный", Color = "коричневый" };
myCupcake.Eat(); // Ммм, шоколадный кекс цвета коричневого!
```

**Объяснение**:  
Класс описывает свойства и поведение, а экземпляры — это конкретные объекты, созданные на его основе.

### **2. Интерфейс (`interface`)**
**Метафора**:  
Интерфейс — это контракт или инструкция, в которой говорится, что нужно сделать, но не объясняется, как это сделать.  
Например, "рецепт торта" говорит, что нужно:
1. Замесить тесто.
2. Испечь его.
3. Украсить.  
   Но не указывает, какими конкретно ингредиентами пользоваться.

**Пример в коде:**
```c#
interface IRecipe
{
    void MixIngredients();
    void Bake();
    void Decorate();
}

class Cake : IRecipe
{
    public void MixIngredients() => Console.WriteLine("Смешиваю муку, кефир и сахар...");
    public void Bake() => Console.WriteLine("Выпекаю в духовке...");
    public void Decorate() => Console.WriteLine("Украшаю кремом!");
}
```

**Объяснение**:  
Интерфейс описывает набор методов, которые должны быть реализованы. А класс решает, как именно выполнять эти методы.

### **3. Делегат (`delegate`)**
**Метафора**:  
Делегат похож на пульт управления, который можно запрограммировать выполнять разные действия. Например:
- У тебя есть пульт, и ты можешь настроить его включать телевизор, свет или музыкальную колонку.
- Делегат позволяет "переключать" методы, которые нужно выполнить.

**Пример в коде:**
```c#
delegate void ActionDelegate(string message);

class Program
{
    static void SayHello(string message) => Console.WriteLine($"Привет: {message}");
    static void SayGoodbye(string message) => Console.WriteLine($"Пока: {message}");

    static void Main()
    {
        ActionDelegate action = SayHello; // Пульт настроен на "Привет"
        action("Мир!"); // Привет: Мир!
        action = SayGoodbye; // Переключаем пульт на "Пока"
        action("Мир!"); // Пока: Мир!
    }
}
```

**Объяснение**:  
Делегат — это способ передать метод в переменную и вызывать его позже, как будто ты управляешь им с пульта.

### **4. Запись (`record`)**
**Метафора**:  
Запись похожа на карточку с фиксированной информацией, например, о рецепте.
- Ты можешь сделать копию карточки и слегка изменить её.
- Но вся карточка предназначена для хранения данных, а не поведения.

**Пример в коде:**
```c#
record Recipe(string Name, string Ingredients);

class Program
{
    static void Main()
    {
        Recipe chocolateCake = new("Шоколадный торт", "Мука, кефир, шоколад");
        Console.WriteLine(chocolateCake); // Recipe { Name = Шоколадный торт, Ingredients = Мука, кефир, шоколад }

        Recipe vanillaCake = chocolateCake with { Name = "Ванильный торт" };
        Console.WriteLine(vanillaCake); // Recipe { Name = Ванильный торт, Ingredients = Мука, кефир, шоколад }
    }
}
```

**Объяснение**:  
`record` — это специальный тип класса, который используется для работы с данными. Он автоматически создаёт полезные методы вроде сравнения и копирования, что удобно для хранения неизменяемой информации.


### Итоговая таблица

| Тип        | Метафора                     | Главная идея                                                   |
|------------|------------------------------|----------------------------------------------------------------|
| `class`    | Форма и кексы                | Описывает структуру и поведение объектов.                     |
| `interface`| Рецепт торта                 | Определяет, что нужно сделать, но не как.                     |
| `delegate` | Пульт управления             | Указывает, какой метод вызывать.                              |
| `record`   | Карточка с рецептом          | Хранит неизменяемую информацию и позволяет легко копировать. |

## Итог по ссылочным типам

### **Пользовательские ссылочные типы** — это как создавать свои собственные предметы.

Представь, что у тебя есть конструктор, например LEGO. Ты можешь собирать из него все, что угодно: машинки, дома, роботов. Но сначала тебе нужно придумать, что именно ты хочешь построить, и как это будет работать. **Класс**, **интерфейс**, **делегат** и **запись** — это как инструкции, которые ты сам придумываешь и записываешь для своих LEGO-изобретений. Вот почему их называют "пользовательскими" типами: ты должен их **проектировать сам**.

- **Класс**: Ты создаешь схему для чего-то сложного. Например, ты можешь описать "Торт" — из чего он состоит, как его готовить. Потом ты по этой схеме можешь "выпекать" настоящие торты.
- **Интерфейс**: Это как план действий. Ты говоришь: "Все, кто хочет стать тортами, должны уметь готовиться, выпекаться и украшаться". Но детали ты пока не описываешь — это сделает тот, кто "подпишется" на этот план.
- **Делегат**: Это как передача задания. Представь, что ты попросил друга сказать, когда торт готов. Твой друг будет использовать твои инструкции, чтобы передать это сообщение (например, он может закричать: "Торт готов!").
- **Запись**: Это готовая карточка рецепта, где ты записал название торта и его ингредиенты. Ты не можешь её изменить, но всегда можешь её использовать.

Пользовательские типы — это твоё творчество! Ты придумываешь, как всё будет работать.

### **Встроенные ссылочные типы** — это как готовые кирпичики LEGO.

Ты покупаешь коробку, в которой уже есть определённые детали: колеса, окна, дверцы. Ты не можешь изменить их форму, но можешь их использовать, чтобы построить свои изобретения. Встроенные типы в C# — это то, что уже "встроено" в язык программирования. Например:

- **string** — готовый кирпичик, который хранит текст.
- **array** — это как коробка, куда можно сложить много однотипных деталей, например, ингредиенты для торта.
- **object** — самый универсальный кирпичик, который подходит ко всему, но не всегда удобен.
- **dynamic** — волшебный кирпичик, который может менять свою форму в зависимости от ситуации.

Ты просто берёшь эти встроенные типы и используешь их в своих пользовательских типах.

### Сравнение:
- **Пользовательские типы** — это как придумать и создать свои уникальные изобретения из LEGO.
- **Встроенные типы** — это как готовые детали, которые ты используешь для своих изобретений.

## Пример использования переменных ссылочных типов

Теперь, падаван, создадим программу на C#, которая демонстрирует использование различных ссылочных 
типов: `class`, `interface`, `delegate`, `record`, `dynamic`, `object`, `string` и массивов. 
Мы объединим их в одной программе, связанной с темой приготовления тортов.

Не переживай если что-то будет не понятно. Пока просто выполни упражнение.

Создай консольное приложение `ex0042_ref_vars` при помощи шаблона `tinyconsole` в папке
`episode02` и добавь его в файл решения `episode02.sln`. Это можно сделать как в командной строке, так и в любой IDE.

Приведи `Program.cs` к следующему виду:

```c#
namespace CakeBakery
{
    // Интерфейс, описывающий основные действия по приготовлению торта
    interface ICake
    {
        void Prepare();
        void Bake();
        void Decorate();
    }

    // Класс, представляющий торт
    class Cake : ICake
    {
        public string Name { get; set; }
        public string[] Ingredients { get; set; }

        public Cake(string name, string[] ingredients)
        {
            Name = name;
            Ingredients = ingredients;
        }

        public void Prepare()
        {
            WriteLine($"Готовим торт '{Name}' с ингредиентами: {string.Join(", ", Ingredients)}.");
        }

        public void Bake()
        {
            WriteLine($"Выпекаем торт '{Name}'.");
        }

        public void Decorate()
        {
            WriteLine($"Украшаем торт '{Name}'.");
        }
    }

    // Делегат, представляющий метод уведомления
    delegate void Notify(string message);

    // Запись, представляющая рецепт торта
    record Recipe(string Name, string[] Ingredients);

    class Program
    {
        static void Main(string[] args)
        {
            // Использование строки
            string cakeName = "Шоколадный торт";

            // Использование массива
            string[] ingredients = { "Мука", "Сахар", "Какао", "Кефир", "Масло" };

            // Создание экземпляра класса Cake
            ICake myCake = new Cake(cakeName, ingredients);

            // Использование делегата для уведомления
            Notify notifier = message => WriteLine($"[Уведомление]: {message}");

            // Динамический тип для хранения дополнительной информации
            dynamic additionalInfo = new System.Dynamic.ExpandoObject();
            additionalInfo.PreparationTime = "2 часа";
            additionalInfo.Difficulty = "Средний";

            // Использование записи для хранения рецепта
            Recipe cakeRecipe = new(cakeName, ingredients);

            // Процесс приготовления торта
            notifier("Начинаем процесс приготовления торта.");
            myCake.Prepare();
            myCake.Bake();
            myCake.Decorate();
            notifier($"Торт '{cakeRecipe.Name}' готов!");

            // Вывод дополнительной информации
            WriteLine($"Время приготовления: {additionalInfo.PreparationTime}");
            WriteLine($"Сложность: {additionalInfo.Difficulty}");

            // Использование типа object
            object cakeObject = myCake;
            WriteLine($"Тип объекта cakeObject: {cakeObject.GetType().Name}");
        }
    }
}
```

**Объяснение:**

1. **Интерфейс (`interface`)**: `ICake` определяет методы `Prepare`, `Bake` и `Decorate`, которые должен реализовать любой класс, представляющий торт.

2. **Класс (`class`)**: `Cake` реализует интерфейс `ICake` и содержит свойства `Name` и `Ingredients`, а также методы для подготовки, выпекания и украшения торта.

3. **Делегат (`delegate`)**: `Notify` представляет метод, который принимает строковое сообщение. В программе используется для уведомлений о процессе приготовления.

4. **Запись (`record`)**: `Recipe` представляет неизменяемый рецепт торта с названием и списком ингредиентов.

5. **Строка (`string`)**: `cakeName` хранит название торта.

6. **Массив (`array`)**: `ingredients` содержит список ингредиентов для торта.

7. **Динамический тип (`dynamic`)**: `additionalInfo` используется для хранения дополнительной информации о торте, такой как время приготовления и сложность. Используется `ExpandoObject` для динамического добавления свойств.

8. **Объект (`object`)**: `cakeObject` демонстрирует, что экземпляр класса `Cake` можно хранить в переменной типа `object`, поскольку `object` является базовым типом для всех типов в C#.

**Вывод программы:**

```
Уведомление]: Начинаем процесс приготовления торта.
Готовим торт 'Шоколадный торт' с ингредиентами: Мука, Сахар, Какао, Кефир, Масло.
Выпекаем торт 'Шоколадный торт'.
Украшаем торт 'Шоколадный торт'.
[Уведомление]: Торт 'Шоколадный торт' готов!
Время приготовления: 2 часа
Сложность: Средний
Тип объекта cakeObject: Cake
```

